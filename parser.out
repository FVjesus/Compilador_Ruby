Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program statment
Rule 2     program -> <empty>
Rule 3     bloco -> INDENT program DEDENT
Rule 4     statment -> conditional
Rule 5     statment -> loops
Rule 6     statment -> stop
Rule 7     statment -> conti
Rule 8     statment -> argumentlist
Rule 9     statment -> bloco
Rule 10    statment -> expression
Rule 11    statment -> declaration
Rule 12    statment -> read_gets
Rule 13    statment -> create_puts
Rule 14    stop -> break
Rule 15    conti -> continue
Rule 16    declaration -> simple_declaration
Rule 17    declaration -> complex_declaration
Rule 18    declaration -> declaration_pointer
Rule 19    declaration -> acess_pointer
Rule 20    simple_declaration -> matrix_declaration
Rule 21    simple_declaration -> expression_declaration
Rule 22    matrix_declaration -> ID ASSIGNMENT matrix
Rule 23    expression_declaration -> ID ASSIGNMENT expression
Rule 24    complex_declaration -> int_declaration
Rule 25    complex_declaration -> float_declaration
Rule 26    complex_declaration -> boolean_declaration
Rule 27    int_declaration -> int ID ASSIGNMENT expression
Rule 28    float_declaration -> float ID ASSIGNMENT expression
Rule 29    boolean_declaration -> boolean ID ASSIGNMENT expression_declaration
Rule 30    conditional -> if expression begin bloco end SEMICOLON
Rule 31    conditional -> if expression begin bloco else bloco end SEMICOLON
Rule 32    conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON
Rule 33    loops -> fors
Rule 34    loops -> whiles
Rule 35    loops -> repeats
Rule 36    loops -> unlesss
Rule 37    fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end
Rule 38    fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end
Rule 39    whiles -> while expression do bloco end
Rule 40    whiles -> do bloco break if expression end
Rule 41    repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON
Rule 42    unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end
Rule 43    expression -> expression_binop
Rule 44    expression -> expression_unitary
Rule 45    expression -> expression_const_real
Rule 46    expression -> expression_const_interger
Rule 47    expression -> expression_const_string
Rule 48    expression -> expression_true
Rule 49    expression -> expression_false
Rule 50    expression -> expression_variable
Rule 51    expression -> expression_land
Rule 52    expression_unitary -> unitary_not
Rule 53    expression_unitary -> unitary_asterisk
Rule 54    expression_unitary -> unitary_plus
Rule 55    expression_unitary -> unitary_minus
Rule 56    expression_binop -> expression_and
Rule 57    expression_binop -> expression_or
Rule 58    expression_binop -> expression_gt
Rule 59    expression_binop -> expression_ge
Rule 60    expression_binop -> expression_lt
Rule 61    expression_binop -> expression_le
Rule 62    expression_binop -> expression_minus
Rule 63    expression_binop -> expression_plus
Rule 64    expression_binop -> expression_mult
Rule 65    expression_binop -> expression_divide
Rule 66    expression_binop -> expression_module
Rule 67    expression_binop -> expression_equals
Rule 68    expression_binop -> expression_different
Rule 69    unitary_minus -> MINUS expression
Rule 70    unitary_plus -> PLUS expression
Rule 71    unitary_asterisk -> ASTERISK expression
Rule 72    unitary_not -> NOT expression
Rule 73    expression_and -> expression AND expression
Rule 74    expression_or -> expression OR expression
Rule 75    expression_gt -> expression GT expression
Rule 76    expression_ge -> expression GE expression
Rule 77    expression_lt -> expression LT expression
Rule 78    expression_le -> expression LE expression
Rule 79    expression_land -> LAND expression
Rule 80    expression_const_real -> CONST_REAL
Rule 81    expression_const_interger -> CONST_INTERGER
Rule 82    expression_const_string -> CONST_STRING
Rule 83    expression_true -> True
Rule 84    expression_false -> False
Rule 85    expression_plus -> expression PLUS expression
Rule 86    expression_equals -> expression EQUALS expression
Rule 87    expression_different -> expression DIFFERENT expression
Rule 88    expression_minus -> expression MINUS expression
Rule 89    expression_mult -> expression ASTERISK expression
Rule 90    expression_divide -> expression DIVIDE expression
Rule 91    expression_module -> expression MODULE expression
Rule 92    argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET
Rule 93    argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET
Rule 94    argumentlist -> LBRACKET LAND ID RBRACKET
Rule 95    expression_variable -> ID
Rule 96    expression_variable -> DSING ID
Rule 97    read_gets -> ID ASSIGNMENT gets
Rule 98    create_puts -> puts_const_string
Rule 99    create_puts -> puts_expression
Rule 100   create_puts -> puts_quotation
Rule 101   create_puts -> puts_dquotation
Rule 102   puts_const_string -> puts CONST_STRING
Rule 103   puts_expression -> puts expression_variable
Rule 104   puts_quotation -> puts_string
Rule 105   puts_quotation -> puts_expressionq
Rule 106   puts_string -> puts QUOTATION CONST_STRING QUOTATION
Rule 107   puts_expressionq -> puts QUOTATION expression_variable QUOTATION
Rule 108   puts_dquotation -> puts_string_dq
Rule 109   puts_dquotation -> puts_expression_dq
Rule 110   puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION
Rule 111   puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION
Rule 112   pointer -> ASTERISK pointer
Rule 113   pointer -> ASTERISK
Rule 114   pointer_acess -> and pointer_acess
Rule 115   pointer_acess -> and
Rule 116   and -> token_and
Rule 117   and -> token_land
Rule 118   token_and -> AND
Rule 119   token_land -> LAND
Rule 120   declaration_pointer -> pointer ID
Rule 121   acess_pointer -> pointer_acess ID
Rule 122   matrix -> matrix_arg
Rule 123   matrix -> matrix_rec
Rule 124   matrix -> LBRACKET argument RBRACKET matrix
Rule 125   matrix -> LBRACKET argument RBRACKET COMMA matrix
Rule 126   matrix_arg -> LBRACKET argument RBRACKET
Rule 127   matrix_rec -> LBRACKET matrix RBRACKET
Rule 128   argument -> expression
Rule 129   argument -> argument COMMA expression
Rule 130   argument -> argument POINT expression
Rule 131   argument -> <empty>

Terminals, with rules where they appear

AND                  : 73 118
ASSIGNMENT           : 22 23 27 28 29 97
ASTERISK             : 71 89 92 92 93 112 113
COMMA                : 92 92 92 93 125 129
CONST_INTERGER       : 38 38 41 81
CONST_REAL           : 80
CONST_STRING         : 82 102 106 110
DEDENT               : 3
DIFFERENT            : 87
DIVIDE               : 90
DPOINT               : 41
DQUOTATION           : 110 110 111 111
DSING                : 96
EQUALS               : 86
False                : 84
GE                   : 76
GT                   : 75
ID                   : 22 23 27 28 29 92 92 92 92 93 93 94 95 96 97 120 121
INDENT               : 3
LAND                 : 79 92 93 94 119
LBRACKET             : 37 37 42 92 92 92 93 94 124 125 126 127
LE                   : 78
LPAREN               : 92
LT                   : 77
MINUS                : 69 88
MODULE               : 91
NOT                  : 72
OR                   : 74
PLUS                 : 70 85
POINT                : 130
POINTPOINT           : 38
QUOTATION            : 106 106 107 107
RBRACKET             : 37 37 42 92 92 92 93 94 124 125 126 127
RPAREN               : 92
SEMICOLON            : 30 31 32 41
True                 : 83
begin                : 30 31 32 37
boolean              : 29
break                : 14 40
continue             : 15
do                   : 37 39 40
else                 : 31 32 42
elsif                : 32
end                  : 30 31 32 37 38 39 40 41 42
error                : 
float                : 28
for                  : 37 38
gets                 : 97
if                   : 30 31 32 40
in                   : 37 38
int                  : 27
puts                 : 102 103 106 107 110 111
repeat               : 41
then                 : 42
unless               : 42
while                : 39

Nonterminals, with rules where they appear

acess_pointer        : 19
and                  : 114 115
argument             : 124 125 126 129 130
argumentlist         : 8
bloco                : 9 30 31 31 32 32 32 37 38 39 40 41 42 42
boolean_declaration  : 26
complex_declaration  : 17
conditional          : 4
conti                : 7
create_puts          : 13
declaration          : 11
declaration_pointer  : 18
expression           : 10 23 27 28 30 31 32 32 37 38 39 40 42 69 70 71 72 73 73 74 74 75 75 76 76 77 77 78 78 79 85 85 86 86 87 87 88 88 89 89 90 90 91 91 128 129 130
expression_and       : 56
expression_binop     : 43
expression_const_interger : 46
expression_const_real : 45
expression_const_string : 47
expression_declaration : 21 29
expression_different : 68
expression_divide    : 65
expression_equals    : 67
expression_false     : 49
expression_ge        : 59
expression_gt        : 58
expression_land      : 51
expression_le        : 61
expression_lt        : 60
expression_minus     : 62
expression_module    : 66
expression_mult      : 64
expression_or        : 57
expression_plus      : 63
expression_true      : 48
expression_unitary   : 44
expression_variable  : 37 37 50 103 107 111
float_declaration    : 25
fors                 : 33
int_declaration      : 24
loops                : 5
matrix               : 22 124 125 127
matrix_arg           : 122
matrix_declaration   : 20
matrix_rec           : 123
pointer              : 112 120
pointer_acess        : 114 121
program              : 1 3 0
puts_const_string    : 98
puts_dquotation      : 101
puts_expression      : 99
puts_expression_dq   : 109
puts_expressionq     : 105
puts_quotation       : 100
puts_string          : 104
puts_string_dq       : 108
read_gets            : 12
repeats              : 35
simple_declaration   : 16
statment             : 1
stop                 : 6
token_and            : 116
token_land           : 117
unitary_asterisk     : 53
unitary_minus        : 55
unitary_not          : 52
unitary_plus         : 54
unlesss              : 36
whiles               : 34

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program statment
    (2) program -> .

    if              reduce using rule 2 (program -> .)
    break           reduce using rule 2 (program -> .)
    continue        reduce using rule 2 (program -> .)
    ID              reduce using rule 2 (program -> .)
    ASTERISK        reduce using rule 2 (program -> .)
    LBRACKET        reduce using rule 2 (program -> .)
    INDENT          reduce using rule 2 (program -> .)
    for             reduce using rule 2 (program -> .)
    while           reduce using rule 2 (program -> .)
    do              reduce using rule 2 (program -> .)
    repeat          reduce using rule 2 (program -> .)
    unless          reduce using rule 2 (program -> .)
    CONST_REAL      reduce using rule 2 (program -> .)
    CONST_INTERGER  reduce using rule 2 (program -> .)
    CONST_STRING    reduce using rule 2 (program -> .)
    True            reduce using rule 2 (program -> .)
    False           reduce using rule 2 (program -> .)
    DSING           reduce using rule 2 (program -> .)
    LAND            reduce using rule 2 (program -> .)
    puts            reduce using rule 2 (program -> .)
    NOT             reduce using rule 2 (program -> .)
    PLUS            reduce using rule 2 (program -> .)
    MINUS           reduce using rule 2 (program -> .)
    int             reduce using rule 2 (program -> .)
    float           reduce using rule 2 (program -> .)
    boolean         reduce using rule 2 (program -> .)
    AND             reduce using rule 2 (program -> .)
    $end            reduce using rule 2 (program -> .)

    program                        shift and go to state 1

state 1

    (0) S' -> program .
    (1) program -> program . statment
    (4) statment -> . conditional
    (5) statment -> . loops
    (6) statment -> . stop
    (7) statment -> . conti
    (8) statment -> . argumentlist
    (9) statment -> . bloco
    (10) statment -> . expression
    (11) statment -> . declaration
    (12) statment -> . read_gets
    (13) statment -> . create_puts
    (30) conditional -> . if expression begin bloco end SEMICOLON
    (31) conditional -> . if expression begin bloco else bloco end SEMICOLON
    (32) conditional -> . if expression begin bloco elsif expression bloco else bloco end SEMICOLON
    (33) loops -> . fors
    (34) loops -> . whiles
    (35) loops -> . repeats
    (36) loops -> . unlesss
    (14) stop -> . break
    (15) conti -> . continue
    (92) argumentlist -> . ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET
    (93) argumentlist -> . ASTERISK ID LBRACKET COMMA LAND ID RBRACKET
    (94) argumentlist -> . LBRACKET LAND ID RBRACKET
    (3) bloco -> . INDENT program DEDENT
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (16) declaration -> . simple_declaration
    (17) declaration -> . complex_declaration
    (18) declaration -> . declaration_pointer
    (19) declaration -> . acess_pointer
    (97) read_gets -> . ID ASSIGNMENT gets
    (98) create_puts -> . puts_const_string
    (99) create_puts -> . puts_expression
    (100) create_puts -> . puts_quotation
    (101) create_puts -> . puts_dquotation
    (37) fors -> . for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end
    (38) fors -> . for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end
    (39) whiles -> . while expression do bloco end
    (40) whiles -> . do bloco break if expression end
    (41) repeats -> . repeat CONST_INTERGER DPOINT bloco end SEMICOLON
    (42) unlesss -> . unless expression then bloco RBRACKET else bloco LBRACKET end
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (20) simple_declaration -> . matrix_declaration
    (21) simple_declaration -> . expression_declaration
    (24) complex_declaration -> . int_declaration
    (25) complex_declaration -> . float_declaration
    (26) complex_declaration -> . boolean_declaration
    (120) declaration_pointer -> . pointer ID
    (121) acess_pointer -> . pointer_acess ID
    (102) puts_const_string -> . puts CONST_STRING
    (103) puts_expression -> . puts expression_variable
    (104) puts_quotation -> . puts_string
    (105) puts_quotation -> . puts_expressionq
    (108) puts_dquotation -> . puts_string_dq
    (109) puts_dquotation -> . puts_expression_dq
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression
    (22) matrix_declaration -> . ID ASSIGNMENT matrix
    (23) expression_declaration -> . ID ASSIGNMENT expression
    (27) int_declaration -> . int ID ASSIGNMENT expression
    (28) float_declaration -> . float ID ASSIGNMENT expression
    (29) boolean_declaration -> . boolean ID ASSIGNMENT expression_declaration
    (112) pointer -> . ASTERISK pointer
    (113) pointer -> . ASTERISK
    (114) pointer_acess -> . and pointer_acess
    (115) pointer_acess -> . and
    (106) puts_string -> . puts QUOTATION CONST_STRING QUOTATION
    (107) puts_expressionq -> . puts QUOTATION expression_variable QUOTATION
    (110) puts_string_dq -> . puts DQUOTATION CONST_STRING DQUOTATION
    (111) puts_expression_dq -> . puts DQUOTATION expression_variable DQUOTATION
    (116) and -> . token_and
    (117) and -> . token_land
    (118) token_and -> . AND
    (119) token_land -> . LAND

    if              shift and go to state 13
    break           shift and go to state 18
    continue        shift and go to state 19
    ID              shift and go to state 20
    ASTERISK        shift and go to state 21
    LBRACKET        shift and go to state 22
    INDENT          shift and go to state 24
    for             shift and go to state 42
    while           shift and go to state 45
    do              shift and go to state 43
    repeat          shift and go to state 46
    unless          shift and go to state 47
    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    DSING           shift and go to state 69
    LAND            shift and go to state 23
    puts            shift and go to state 77
    NOT             shift and go to state 85
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83
    int             shift and go to state 86
    float           shift and go to state 87
    boolean         shift and go to state 88
    AND             shift and go to state 82

    statment                       shift and go to state 2
    conditional                    shift and go to state 3
    loops                          shift and go to state 4
    stop                           shift and go to state 5
    conti                          shift and go to state 6
    argumentlist                   shift and go to state 7
    bloco                          shift and go to state 8
    expression                     shift and go to state 9
    declaration                    shift and go to state 10
    read_gets                      shift and go to state 11
    create_puts                    shift and go to state 12
    fors                           shift and go to state 14
    whiles                         shift and go to state 15
    repeats                        shift and go to state 16
    unlesss                        shift and go to state 17
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    simple_declaration             shift and go to state 34
    complex_declaration            shift and go to state 35
    declaration_pointer            shift and go to state 36
    acess_pointer                  shift and go to state 37
    puts_const_string              shift and go to state 38
    puts_expression                shift and go to state 39
    puts_quotation                 shift and go to state 40
    puts_dquotation                shift and go to state 41
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64
    matrix_declaration             shift and go to state 70
    expression_declaration         shift and go to state 71
    int_declaration                shift and go to state 72
    float_declaration              shift and go to state 73
    boolean_declaration            shift and go to state 74
    pointer                        shift and go to state 75
    pointer_acess                  shift and go to state 76
    puts_string                    shift and go to state 78
    puts_expressionq               shift and go to state 79
    puts_string_dq                 shift and go to state 80
    puts_expression_dq             shift and go to state 81
    and                            shift and go to state 89
    token_and                      shift and go to state 90
    token_land                     shift and go to state 91

state 2

    (1) program -> program statment .

    if              reduce using rule 1 (program -> program statment .)
    break           reduce using rule 1 (program -> program statment .)
    continue        reduce using rule 1 (program -> program statment .)
    ID              reduce using rule 1 (program -> program statment .)
    ASTERISK        reduce using rule 1 (program -> program statment .)
    LBRACKET        reduce using rule 1 (program -> program statment .)
    INDENT          reduce using rule 1 (program -> program statment .)
    for             reduce using rule 1 (program -> program statment .)
    while           reduce using rule 1 (program -> program statment .)
    do              reduce using rule 1 (program -> program statment .)
    repeat          reduce using rule 1 (program -> program statment .)
    unless          reduce using rule 1 (program -> program statment .)
    CONST_REAL      reduce using rule 1 (program -> program statment .)
    CONST_INTERGER  reduce using rule 1 (program -> program statment .)
    CONST_STRING    reduce using rule 1 (program -> program statment .)
    True            reduce using rule 1 (program -> program statment .)
    False           reduce using rule 1 (program -> program statment .)
    DSING           reduce using rule 1 (program -> program statment .)
    LAND            reduce using rule 1 (program -> program statment .)
    puts            reduce using rule 1 (program -> program statment .)
    NOT             reduce using rule 1 (program -> program statment .)
    PLUS            reduce using rule 1 (program -> program statment .)
    MINUS           reduce using rule 1 (program -> program statment .)
    int             reduce using rule 1 (program -> program statment .)
    float           reduce using rule 1 (program -> program statment .)
    boolean         reduce using rule 1 (program -> program statment .)
    AND             reduce using rule 1 (program -> program statment .)
    $end            reduce using rule 1 (program -> program statment .)
    DEDENT          reduce using rule 1 (program -> program statment .)


state 3

    (4) statment -> conditional .

    if              reduce using rule 4 (statment -> conditional .)
    break           reduce using rule 4 (statment -> conditional .)
    continue        reduce using rule 4 (statment -> conditional .)
    ID              reduce using rule 4 (statment -> conditional .)
    ASTERISK        reduce using rule 4 (statment -> conditional .)
    LBRACKET        reduce using rule 4 (statment -> conditional .)
    INDENT          reduce using rule 4 (statment -> conditional .)
    for             reduce using rule 4 (statment -> conditional .)
    while           reduce using rule 4 (statment -> conditional .)
    do              reduce using rule 4 (statment -> conditional .)
    repeat          reduce using rule 4 (statment -> conditional .)
    unless          reduce using rule 4 (statment -> conditional .)
    CONST_REAL      reduce using rule 4 (statment -> conditional .)
    CONST_INTERGER  reduce using rule 4 (statment -> conditional .)
    CONST_STRING    reduce using rule 4 (statment -> conditional .)
    True            reduce using rule 4 (statment -> conditional .)
    False           reduce using rule 4 (statment -> conditional .)
    DSING           reduce using rule 4 (statment -> conditional .)
    LAND            reduce using rule 4 (statment -> conditional .)
    puts            reduce using rule 4 (statment -> conditional .)
    NOT             reduce using rule 4 (statment -> conditional .)
    PLUS            reduce using rule 4 (statment -> conditional .)
    MINUS           reduce using rule 4 (statment -> conditional .)
    int             reduce using rule 4 (statment -> conditional .)
    float           reduce using rule 4 (statment -> conditional .)
    boolean         reduce using rule 4 (statment -> conditional .)
    AND             reduce using rule 4 (statment -> conditional .)
    $end            reduce using rule 4 (statment -> conditional .)
    DEDENT          reduce using rule 4 (statment -> conditional .)


state 4

    (5) statment -> loops .

    if              reduce using rule 5 (statment -> loops .)
    break           reduce using rule 5 (statment -> loops .)
    continue        reduce using rule 5 (statment -> loops .)
    ID              reduce using rule 5 (statment -> loops .)
    ASTERISK        reduce using rule 5 (statment -> loops .)
    LBRACKET        reduce using rule 5 (statment -> loops .)
    INDENT          reduce using rule 5 (statment -> loops .)
    for             reduce using rule 5 (statment -> loops .)
    while           reduce using rule 5 (statment -> loops .)
    do              reduce using rule 5 (statment -> loops .)
    repeat          reduce using rule 5 (statment -> loops .)
    unless          reduce using rule 5 (statment -> loops .)
    CONST_REAL      reduce using rule 5 (statment -> loops .)
    CONST_INTERGER  reduce using rule 5 (statment -> loops .)
    CONST_STRING    reduce using rule 5 (statment -> loops .)
    True            reduce using rule 5 (statment -> loops .)
    False           reduce using rule 5 (statment -> loops .)
    DSING           reduce using rule 5 (statment -> loops .)
    LAND            reduce using rule 5 (statment -> loops .)
    puts            reduce using rule 5 (statment -> loops .)
    NOT             reduce using rule 5 (statment -> loops .)
    PLUS            reduce using rule 5 (statment -> loops .)
    MINUS           reduce using rule 5 (statment -> loops .)
    int             reduce using rule 5 (statment -> loops .)
    float           reduce using rule 5 (statment -> loops .)
    boolean         reduce using rule 5 (statment -> loops .)
    AND             reduce using rule 5 (statment -> loops .)
    $end            reduce using rule 5 (statment -> loops .)
    DEDENT          reduce using rule 5 (statment -> loops .)


state 5

    (6) statment -> stop .

    if              reduce using rule 6 (statment -> stop .)
    break           reduce using rule 6 (statment -> stop .)
    continue        reduce using rule 6 (statment -> stop .)
    ID              reduce using rule 6 (statment -> stop .)
    ASTERISK        reduce using rule 6 (statment -> stop .)
    LBRACKET        reduce using rule 6 (statment -> stop .)
    INDENT          reduce using rule 6 (statment -> stop .)
    for             reduce using rule 6 (statment -> stop .)
    while           reduce using rule 6 (statment -> stop .)
    do              reduce using rule 6 (statment -> stop .)
    repeat          reduce using rule 6 (statment -> stop .)
    unless          reduce using rule 6 (statment -> stop .)
    CONST_REAL      reduce using rule 6 (statment -> stop .)
    CONST_INTERGER  reduce using rule 6 (statment -> stop .)
    CONST_STRING    reduce using rule 6 (statment -> stop .)
    True            reduce using rule 6 (statment -> stop .)
    False           reduce using rule 6 (statment -> stop .)
    DSING           reduce using rule 6 (statment -> stop .)
    LAND            reduce using rule 6 (statment -> stop .)
    puts            reduce using rule 6 (statment -> stop .)
    NOT             reduce using rule 6 (statment -> stop .)
    PLUS            reduce using rule 6 (statment -> stop .)
    MINUS           reduce using rule 6 (statment -> stop .)
    int             reduce using rule 6 (statment -> stop .)
    float           reduce using rule 6 (statment -> stop .)
    boolean         reduce using rule 6 (statment -> stop .)
    AND             reduce using rule 6 (statment -> stop .)
    $end            reduce using rule 6 (statment -> stop .)
    DEDENT          reduce using rule 6 (statment -> stop .)


state 6

    (7) statment -> conti .

    if              reduce using rule 7 (statment -> conti .)
    break           reduce using rule 7 (statment -> conti .)
    continue        reduce using rule 7 (statment -> conti .)
    ID              reduce using rule 7 (statment -> conti .)
    ASTERISK        reduce using rule 7 (statment -> conti .)
    LBRACKET        reduce using rule 7 (statment -> conti .)
    INDENT          reduce using rule 7 (statment -> conti .)
    for             reduce using rule 7 (statment -> conti .)
    while           reduce using rule 7 (statment -> conti .)
    do              reduce using rule 7 (statment -> conti .)
    repeat          reduce using rule 7 (statment -> conti .)
    unless          reduce using rule 7 (statment -> conti .)
    CONST_REAL      reduce using rule 7 (statment -> conti .)
    CONST_INTERGER  reduce using rule 7 (statment -> conti .)
    CONST_STRING    reduce using rule 7 (statment -> conti .)
    True            reduce using rule 7 (statment -> conti .)
    False           reduce using rule 7 (statment -> conti .)
    DSING           reduce using rule 7 (statment -> conti .)
    LAND            reduce using rule 7 (statment -> conti .)
    puts            reduce using rule 7 (statment -> conti .)
    NOT             reduce using rule 7 (statment -> conti .)
    PLUS            reduce using rule 7 (statment -> conti .)
    MINUS           reduce using rule 7 (statment -> conti .)
    int             reduce using rule 7 (statment -> conti .)
    float           reduce using rule 7 (statment -> conti .)
    boolean         reduce using rule 7 (statment -> conti .)
    AND             reduce using rule 7 (statment -> conti .)
    $end            reduce using rule 7 (statment -> conti .)
    DEDENT          reduce using rule 7 (statment -> conti .)


state 7

    (8) statment -> argumentlist .

    if              reduce using rule 8 (statment -> argumentlist .)
    break           reduce using rule 8 (statment -> argumentlist .)
    continue        reduce using rule 8 (statment -> argumentlist .)
    ID              reduce using rule 8 (statment -> argumentlist .)
    ASTERISK        reduce using rule 8 (statment -> argumentlist .)
    LBRACKET        reduce using rule 8 (statment -> argumentlist .)
    INDENT          reduce using rule 8 (statment -> argumentlist .)
    for             reduce using rule 8 (statment -> argumentlist .)
    while           reduce using rule 8 (statment -> argumentlist .)
    do              reduce using rule 8 (statment -> argumentlist .)
    repeat          reduce using rule 8 (statment -> argumentlist .)
    unless          reduce using rule 8 (statment -> argumentlist .)
    CONST_REAL      reduce using rule 8 (statment -> argumentlist .)
    CONST_INTERGER  reduce using rule 8 (statment -> argumentlist .)
    CONST_STRING    reduce using rule 8 (statment -> argumentlist .)
    True            reduce using rule 8 (statment -> argumentlist .)
    False           reduce using rule 8 (statment -> argumentlist .)
    DSING           reduce using rule 8 (statment -> argumentlist .)
    LAND            reduce using rule 8 (statment -> argumentlist .)
    puts            reduce using rule 8 (statment -> argumentlist .)
    NOT             reduce using rule 8 (statment -> argumentlist .)
    PLUS            reduce using rule 8 (statment -> argumentlist .)
    MINUS           reduce using rule 8 (statment -> argumentlist .)
    int             reduce using rule 8 (statment -> argumentlist .)
    float           reduce using rule 8 (statment -> argumentlist .)
    boolean         reduce using rule 8 (statment -> argumentlist .)
    AND             reduce using rule 8 (statment -> argumentlist .)
    $end            reduce using rule 8 (statment -> argumentlist .)
    DEDENT          reduce using rule 8 (statment -> argumentlist .)


state 8

    (9) statment -> bloco .

    if              reduce using rule 9 (statment -> bloco .)
    break           reduce using rule 9 (statment -> bloco .)
    continue        reduce using rule 9 (statment -> bloco .)
    ID              reduce using rule 9 (statment -> bloco .)
    ASTERISK        reduce using rule 9 (statment -> bloco .)
    LBRACKET        reduce using rule 9 (statment -> bloco .)
    INDENT          reduce using rule 9 (statment -> bloco .)
    for             reduce using rule 9 (statment -> bloco .)
    while           reduce using rule 9 (statment -> bloco .)
    do              reduce using rule 9 (statment -> bloco .)
    repeat          reduce using rule 9 (statment -> bloco .)
    unless          reduce using rule 9 (statment -> bloco .)
    CONST_REAL      reduce using rule 9 (statment -> bloco .)
    CONST_INTERGER  reduce using rule 9 (statment -> bloco .)
    CONST_STRING    reduce using rule 9 (statment -> bloco .)
    True            reduce using rule 9 (statment -> bloco .)
    False           reduce using rule 9 (statment -> bloco .)
    DSING           reduce using rule 9 (statment -> bloco .)
    LAND            reduce using rule 9 (statment -> bloco .)
    puts            reduce using rule 9 (statment -> bloco .)
    NOT             reduce using rule 9 (statment -> bloco .)
    PLUS            reduce using rule 9 (statment -> bloco .)
    MINUS           reduce using rule 9 (statment -> bloco .)
    int             reduce using rule 9 (statment -> bloco .)
    float           reduce using rule 9 (statment -> bloco .)
    boolean         reduce using rule 9 (statment -> bloco .)
    AND             reduce using rule 9 (statment -> bloco .)
    $end            reduce using rule 9 (statment -> bloco .)
    DEDENT          reduce using rule 9 (statment -> bloco .)


state 9

    (10) statment -> expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
    if              reduce using rule 10 (statment -> expression .)
    break           reduce using rule 10 (statment -> expression .)
    continue        reduce using rule 10 (statment -> expression .)
    ID              reduce using rule 10 (statment -> expression .)
    LBRACKET        reduce using rule 10 (statment -> expression .)
    INDENT          reduce using rule 10 (statment -> expression .)
    for             reduce using rule 10 (statment -> expression .)
    while           reduce using rule 10 (statment -> expression .)
    do              reduce using rule 10 (statment -> expression .)
    repeat          reduce using rule 10 (statment -> expression .)
    unless          reduce using rule 10 (statment -> expression .)
    CONST_REAL      reduce using rule 10 (statment -> expression .)
    CONST_INTERGER  reduce using rule 10 (statment -> expression .)
    CONST_STRING    reduce using rule 10 (statment -> expression .)
    True            reduce using rule 10 (statment -> expression .)
    False           reduce using rule 10 (statment -> expression .)
    DSING           reduce using rule 10 (statment -> expression .)
    LAND            reduce using rule 10 (statment -> expression .)
    puts            reduce using rule 10 (statment -> expression .)
    NOT             reduce using rule 10 (statment -> expression .)
    int             reduce using rule 10 (statment -> expression .)
    float           reduce using rule 10 (statment -> expression .)
    boolean         reduce using rule 10 (statment -> expression .)
    $end            reduce using rule 10 (statment -> expression .)
    DEDENT          reduce using rule 10 (statment -> expression .)
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104

  ! ASTERISK        [ reduce using rule 10 (statment -> expression .) ]
  ! PLUS            [ reduce using rule 10 (statment -> expression .) ]
  ! MINUS           [ reduce using rule 10 (statment -> expression .) ]
  ! AND             [ reduce using rule 10 (statment -> expression .) ]


state 10

    (11) statment -> declaration .

    if              reduce using rule 11 (statment -> declaration .)
    break           reduce using rule 11 (statment -> declaration .)
    continue        reduce using rule 11 (statment -> declaration .)
    ID              reduce using rule 11 (statment -> declaration .)
    ASTERISK        reduce using rule 11 (statment -> declaration .)
    LBRACKET        reduce using rule 11 (statment -> declaration .)
    INDENT          reduce using rule 11 (statment -> declaration .)
    for             reduce using rule 11 (statment -> declaration .)
    while           reduce using rule 11 (statment -> declaration .)
    do              reduce using rule 11 (statment -> declaration .)
    repeat          reduce using rule 11 (statment -> declaration .)
    unless          reduce using rule 11 (statment -> declaration .)
    CONST_REAL      reduce using rule 11 (statment -> declaration .)
    CONST_INTERGER  reduce using rule 11 (statment -> declaration .)
    CONST_STRING    reduce using rule 11 (statment -> declaration .)
    True            reduce using rule 11 (statment -> declaration .)
    False           reduce using rule 11 (statment -> declaration .)
    DSING           reduce using rule 11 (statment -> declaration .)
    LAND            reduce using rule 11 (statment -> declaration .)
    puts            reduce using rule 11 (statment -> declaration .)
    NOT             reduce using rule 11 (statment -> declaration .)
    PLUS            reduce using rule 11 (statment -> declaration .)
    MINUS           reduce using rule 11 (statment -> declaration .)
    int             reduce using rule 11 (statment -> declaration .)
    float           reduce using rule 11 (statment -> declaration .)
    boolean         reduce using rule 11 (statment -> declaration .)
    AND             reduce using rule 11 (statment -> declaration .)
    $end            reduce using rule 11 (statment -> declaration .)
    DEDENT          reduce using rule 11 (statment -> declaration .)


state 11

    (12) statment -> read_gets .

    if              reduce using rule 12 (statment -> read_gets .)
    break           reduce using rule 12 (statment -> read_gets .)
    continue        reduce using rule 12 (statment -> read_gets .)
    ID              reduce using rule 12 (statment -> read_gets .)
    ASTERISK        reduce using rule 12 (statment -> read_gets .)
    LBRACKET        reduce using rule 12 (statment -> read_gets .)
    INDENT          reduce using rule 12 (statment -> read_gets .)
    for             reduce using rule 12 (statment -> read_gets .)
    while           reduce using rule 12 (statment -> read_gets .)
    do              reduce using rule 12 (statment -> read_gets .)
    repeat          reduce using rule 12 (statment -> read_gets .)
    unless          reduce using rule 12 (statment -> read_gets .)
    CONST_REAL      reduce using rule 12 (statment -> read_gets .)
    CONST_INTERGER  reduce using rule 12 (statment -> read_gets .)
    CONST_STRING    reduce using rule 12 (statment -> read_gets .)
    True            reduce using rule 12 (statment -> read_gets .)
    False           reduce using rule 12 (statment -> read_gets .)
    DSING           reduce using rule 12 (statment -> read_gets .)
    LAND            reduce using rule 12 (statment -> read_gets .)
    puts            reduce using rule 12 (statment -> read_gets .)
    NOT             reduce using rule 12 (statment -> read_gets .)
    PLUS            reduce using rule 12 (statment -> read_gets .)
    MINUS           reduce using rule 12 (statment -> read_gets .)
    int             reduce using rule 12 (statment -> read_gets .)
    float           reduce using rule 12 (statment -> read_gets .)
    boolean         reduce using rule 12 (statment -> read_gets .)
    AND             reduce using rule 12 (statment -> read_gets .)
    $end            reduce using rule 12 (statment -> read_gets .)
    DEDENT          reduce using rule 12 (statment -> read_gets .)


state 12

    (13) statment -> create_puts .

    if              reduce using rule 13 (statment -> create_puts .)
    break           reduce using rule 13 (statment -> create_puts .)
    continue        reduce using rule 13 (statment -> create_puts .)
    ID              reduce using rule 13 (statment -> create_puts .)
    ASTERISK        reduce using rule 13 (statment -> create_puts .)
    LBRACKET        reduce using rule 13 (statment -> create_puts .)
    INDENT          reduce using rule 13 (statment -> create_puts .)
    for             reduce using rule 13 (statment -> create_puts .)
    while           reduce using rule 13 (statment -> create_puts .)
    do              reduce using rule 13 (statment -> create_puts .)
    repeat          reduce using rule 13 (statment -> create_puts .)
    unless          reduce using rule 13 (statment -> create_puts .)
    CONST_REAL      reduce using rule 13 (statment -> create_puts .)
    CONST_INTERGER  reduce using rule 13 (statment -> create_puts .)
    CONST_STRING    reduce using rule 13 (statment -> create_puts .)
    True            reduce using rule 13 (statment -> create_puts .)
    False           reduce using rule 13 (statment -> create_puts .)
    DSING           reduce using rule 13 (statment -> create_puts .)
    LAND            reduce using rule 13 (statment -> create_puts .)
    puts            reduce using rule 13 (statment -> create_puts .)
    NOT             reduce using rule 13 (statment -> create_puts .)
    PLUS            reduce using rule 13 (statment -> create_puts .)
    MINUS           reduce using rule 13 (statment -> create_puts .)
    int             reduce using rule 13 (statment -> create_puts .)
    float           reduce using rule 13 (statment -> create_puts .)
    boolean         reduce using rule 13 (statment -> create_puts .)
    AND             reduce using rule 13 (statment -> create_puts .)
    $end            reduce using rule 13 (statment -> create_puts .)
    DEDENT          reduce using rule 13 (statment -> create_puts .)


state 13

    (30) conditional -> if . expression begin bloco end SEMICOLON
    (31) conditional -> if . expression begin bloco else bloco end SEMICOLON
    (32) conditional -> if . expression begin bloco elsif expression bloco else bloco end SEMICOLON
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 105
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 14

    (33) loops -> fors .

    if              reduce using rule 33 (loops -> fors .)
    break           reduce using rule 33 (loops -> fors .)
    continue        reduce using rule 33 (loops -> fors .)
    ID              reduce using rule 33 (loops -> fors .)
    ASTERISK        reduce using rule 33 (loops -> fors .)
    LBRACKET        reduce using rule 33 (loops -> fors .)
    INDENT          reduce using rule 33 (loops -> fors .)
    for             reduce using rule 33 (loops -> fors .)
    while           reduce using rule 33 (loops -> fors .)
    do              reduce using rule 33 (loops -> fors .)
    repeat          reduce using rule 33 (loops -> fors .)
    unless          reduce using rule 33 (loops -> fors .)
    CONST_REAL      reduce using rule 33 (loops -> fors .)
    CONST_INTERGER  reduce using rule 33 (loops -> fors .)
    CONST_STRING    reduce using rule 33 (loops -> fors .)
    True            reduce using rule 33 (loops -> fors .)
    False           reduce using rule 33 (loops -> fors .)
    DSING           reduce using rule 33 (loops -> fors .)
    LAND            reduce using rule 33 (loops -> fors .)
    puts            reduce using rule 33 (loops -> fors .)
    NOT             reduce using rule 33 (loops -> fors .)
    PLUS            reduce using rule 33 (loops -> fors .)
    MINUS           reduce using rule 33 (loops -> fors .)
    int             reduce using rule 33 (loops -> fors .)
    float           reduce using rule 33 (loops -> fors .)
    boolean         reduce using rule 33 (loops -> fors .)
    AND             reduce using rule 33 (loops -> fors .)
    $end            reduce using rule 33 (loops -> fors .)
    DEDENT          reduce using rule 33 (loops -> fors .)


state 15

    (34) loops -> whiles .

    if              reduce using rule 34 (loops -> whiles .)
    break           reduce using rule 34 (loops -> whiles .)
    continue        reduce using rule 34 (loops -> whiles .)
    ID              reduce using rule 34 (loops -> whiles .)
    ASTERISK        reduce using rule 34 (loops -> whiles .)
    LBRACKET        reduce using rule 34 (loops -> whiles .)
    INDENT          reduce using rule 34 (loops -> whiles .)
    for             reduce using rule 34 (loops -> whiles .)
    while           reduce using rule 34 (loops -> whiles .)
    do              reduce using rule 34 (loops -> whiles .)
    repeat          reduce using rule 34 (loops -> whiles .)
    unless          reduce using rule 34 (loops -> whiles .)
    CONST_REAL      reduce using rule 34 (loops -> whiles .)
    CONST_INTERGER  reduce using rule 34 (loops -> whiles .)
    CONST_STRING    reduce using rule 34 (loops -> whiles .)
    True            reduce using rule 34 (loops -> whiles .)
    False           reduce using rule 34 (loops -> whiles .)
    DSING           reduce using rule 34 (loops -> whiles .)
    LAND            reduce using rule 34 (loops -> whiles .)
    puts            reduce using rule 34 (loops -> whiles .)
    NOT             reduce using rule 34 (loops -> whiles .)
    PLUS            reduce using rule 34 (loops -> whiles .)
    MINUS           reduce using rule 34 (loops -> whiles .)
    int             reduce using rule 34 (loops -> whiles .)
    float           reduce using rule 34 (loops -> whiles .)
    boolean         reduce using rule 34 (loops -> whiles .)
    AND             reduce using rule 34 (loops -> whiles .)
    $end            reduce using rule 34 (loops -> whiles .)
    DEDENT          reduce using rule 34 (loops -> whiles .)


state 16

    (35) loops -> repeats .

    if              reduce using rule 35 (loops -> repeats .)
    break           reduce using rule 35 (loops -> repeats .)
    continue        reduce using rule 35 (loops -> repeats .)
    ID              reduce using rule 35 (loops -> repeats .)
    ASTERISK        reduce using rule 35 (loops -> repeats .)
    LBRACKET        reduce using rule 35 (loops -> repeats .)
    INDENT          reduce using rule 35 (loops -> repeats .)
    for             reduce using rule 35 (loops -> repeats .)
    while           reduce using rule 35 (loops -> repeats .)
    do              reduce using rule 35 (loops -> repeats .)
    repeat          reduce using rule 35 (loops -> repeats .)
    unless          reduce using rule 35 (loops -> repeats .)
    CONST_REAL      reduce using rule 35 (loops -> repeats .)
    CONST_INTERGER  reduce using rule 35 (loops -> repeats .)
    CONST_STRING    reduce using rule 35 (loops -> repeats .)
    True            reduce using rule 35 (loops -> repeats .)
    False           reduce using rule 35 (loops -> repeats .)
    DSING           reduce using rule 35 (loops -> repeats .)
    LAND            reduce using rule 35 (loops -> repeats .)
    puts            reduce using rule 35 (loops -> repeats .)
    NOT             reduce using rule 35 (loops -> repeats .)
    PLUS            reduce using rule 35 (loops -> repeats .)
    MINUS           reduce using rule 35 (loops -> repeats .)
    int             reduce using rule 35 (loops -> repeats .)
    float           reduce using rule 35 (loops -> repeats .)
    boolean         reduce using rule 35 (loops -> repeats .)
    AND             reduce using rule 35 (loops -> repeats .)
    $end            reduce using rule 35 (loops -> repeats .)
    DEDENT          reduce using rule 35 (loops -> repeats .)


state 17

    (36) loops -> unlesss .

    if              reduce using rule 36 (loops -> unlesss .)
    break           reduce using rule 36 (loops -> unlesss .)
    continue        reduce using rule 36 (loops -> unlesss .)
    ID              reduce using rule 36 (loops -> unlesss .)
    ASTERISK        reduce using rule 36 (loops -> unlesss .)
    LBRACKET        reduce using rule 36 (loops -> unlesss .)
    INDENT          reduce using rule 36 (loops -> unlesss .)
    for             reduce using rule 36 (loops -> unlesss .)
    while           reduce using rule 36 (loops -> unlesss .)
    do              reduce using rule 36 (loops -> unlesss .)
    repeat          reduce using rule 36 (loops -> unlesss .)
    unless          reduce using rule 36 (loops -> unlesss .)
    CONST_REAL      reduce using rule 36 (loops -> unlesss .)
    CONST_INTERGER  reduce using rule 36 (loops -> unlesss .)
    CONST_STRING    reduce using rule 36 (loops -> unlesss .)
    True            reduce using rule 36 (loops -> unlesss .)
    False           reduce using rule 36 (loops -> unlesss .)
    DSING           reduce using rule 36 (loops -> unlesss .)
    LAND            reduce using rule 36 (loops -> unlesss .)
    puts            reduce using rule 36 (loops -> unlesss .)
    NOT             reduce using rule 36 (loops -> unlesss .)
    PLUS            reduce using rule 36 (loops -> unlesss .)
    MINUS           reduce using rule 36 (loops -> unlesss .)
    int             reduce using rule 36 (loops -> unlesss .)
    float           reduce using rule 36 (loops -> unlesss .)
    boolean         reduce using rule 36 (loops -> unlesss .)
    AND             reduce using rule 36 (loops -> unlesss .)
    $end            reduce using rule 36 (loops -> unlesss .)
    DEDENT          reduce using rule 36 (loops -> unlesss .)


state 18

    (14) stop -> break .

    if              reduce using rule 14 (stop -> break .)
    break           reduce using rule 14 (stop -> break .)
    continue        reduce using rule 14 (stop -> break .)
    ID              reduce using rule 14 (stop -> break .)
    ASTERISK        reduce using rule 14 (stop -> break .)
    LBRACKET        reduce using rule 14 (stop -> break .)
    INDENT          reduce using rule 14 (stop -> break .)
    for             reduce using rule 14 (stop -> break .)
    while           reduce using rule 14 (stop -> break .)
    do              reduce using rule 14 (stop -> break .)
    repeat          reduce using rule 14 (stop -> break .)
    unless          reduce using rule 14 (stop -> break .)
    CONST_REAL      reduce using rule 14 (stop -> break .)
    CONST_INTERGER  reduce using rule 14 (stop -> break .)
    CONST_STRING    reduce using rule 14 (stop -> break .)
    True            reduce using rule 14 (stop -> break .)
    False           reduce using rule 14 (stop -> break .)
    DSING           reduce using rule 14 (stop -> break .)
    LAND            reduce using rule 14 (stop -> break .)
    puts            reduce using rule 14 (stop -> break .)
    NOT             reduce using rule 14 (stop -> break .)
    PLUS            reduce using rule 14 (stop -> break .)
    MINUS           reduce using rule 14 (stop -> break .)
    int             reduce using rule 14 (stop -> break .)
    float           reduce using rule 14 (stop -> break .)
    boolean         reduce using rule 14 (stop -> break .)
    AND             reduce using rule 14 (stop -> break .)
    $end            reduce using rule 14 (stop -> break .)
    DEDENT          reduce using rule 14 (stop -> break .)


state 19

    (15) conti -> continue .

    if              reduce using rule 15 (conti -> continue .)
    break           reduce using rule 15 (conti -> continue .)
    continue        reduce using rule 15 (conti -> continue .)
    ID              reduce using rule 15 (conti -> continue .)
    ASTERISK        reduce using rule 15 (conti -> continue .)
    LBRACKET        reduce using rule 15 (conti -> continue .)
    INDENT          reduce using rule 15 (conti -> continue .)
    for             reduce using rule 15 (conti -> continue .)
    while           reduce using rule 15 (conti -> continue .)
    do              reduce using rule 15 (conti -> continue .)
    repeat          reduce using rule 15 (conti -> continue .)
    unless          reduce using rule 15 (conti -> continue .)
    CONST_REAL      reduce using rule 15 (conti -> continue .)
    CONST_INTERGER  reduce using rule 15 (conti -> continue .)
    CONST_STRING    reduce using rule 15 (conti -> continue .)
    True            reduce using rule 15 (conti -> continue .)
    False           reduce using rule 15 (conti -> continue .)
    DSING           reduce using rule 15 (conti -> continue .)
    LAND            reduce using rule 15 (conti -> continue .)
    puts            reduce using rule 15 (conti -> continue .)
    NOT             reduce using rule 15 (conti -> continue .)
    PLUS            reduce using rule 15 (conti -> continue .)
    MINUS           reduce using rule 15 (conti -> continue .)
    int             reduce using rule 15 (conti -> continue .)
    float           reduce using rule 15 (conti -> continue .)
    boolean         reduce using rule 15 (conti -> continue .)
    AND             reduce using rule 15 (conti -> continue .)
    $end            reduce using rule 15 (conti -> continue .)
    DEDENT          reduce using rule 15 (conti -> continue .)


state 20

    (92) argumentlist -> ID . LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET
    (97) read_gets -> ID . ASSIGNMENT gets
    (95) expression_variable -> ID .
    (22) matrix_declaration -> ID . ASSIGNMENT matrix
    (23) expression_declaration -> ID . ASSIGNMENT expression

    LPAREN          shift and go to state 109
    ASSIGNMENT      shift and go to state 110
    AND             reduce using rule 95 (expression_variable -> ID .)
    OR              reduce using rule 95 (expression_variable -> ID .)
    GT              reduce using rule 95 (expression_variable -> ID .)
    GE              reduce using rule 95 (expression_variable -> ID .)
    LT              reduce using rule 95 (expression_variable -> ID .)
    LE              reduce using rule 95 (expression_variable -> ID .)
    MINUS           reduce using rule 95 (expression_variable -> ID .)
    PLUS            reduce using rule 95 (expression_variable -> ID .)
    ASTERISK        reduce using rule 95 (expression_variable -> ID .)
    DIVIDE          reduce using rule 95 (expression_variable -> ID .)
    MODULE          reduce using rule 95 (expression_variable -> ID .)
    EQUALS          reduce using rule 95 (expression_variable -> ID .)
    DIFFERENT       reduce using rule 95 (expression_variable -> ID .)
    if              reduce using rule 95 (expression_variable -> ID .)
    break           reduce using rule 95 (expression_variable -> ID .)
    continue        reduce using rule 95 (expression_variable -> ID .)
    ID              reduce using rule 95 (expression_variable -> ID .)
    LBRACKET        reduce using rule 95 (expression_variable -> ID .)
    INDENT          reduce using rule 95 (expression_variable -> ID .)
    for             reduce using rule 95 (expression_variable -> ID .)
    while           reduce using rule 95 (expression_variable -> ID .)
    do              reduce using rule 95 (expression_variable -> ID .)
    repeat          reduce using rule 95 (expression_variable -> ID .)
    unless          reduce using rule 95 (expression_variable -> ID .)
    CONST_REAL      reduce using rule 95 (expression_variable -> ID .)
    CONST_INTERGER  reduce using rule 95 (expression_variable -> ID .)
    CONST_STRING    reduce using rule 95 (expression_variable -> ID .)
    True            reduce using rule 95 (expression_variable -> ID .)
    False           reduce using rule 95 (expression_variable -> ID .)
    DSING           reduce using rule 95 (expression_variable -> ID .)
    LAND            reduce using rule 95 (expression_variable -> ID .)
    puts            reduce using rule 95 (expression_variable -> ID .)
    NOT             reduce using rule 95 (expression_variable -> ID .)
    int             reduce using rule 95 (expression_variable -> ID .)
    float           reduce using rule 95 (expression_variable -> ID .)
    boolean         reduce using rule 95 (expression_variable -> ID .)
    $end            reduce using rule 95 (expression_variable -> ID .)
    DEDENT          reduce using rule 95 (expression_variable -> ID .)


state 21

    (93) argumentlist -> ASTERISK . ID LBRACKET COMMA LAND ID RBRACKET
    (71) unitary_asterisk -> ASTERISK . expression
    (112) pointer -> ASTERISK . pointer
    (113) pointer -> ASTERISK .
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (112) pointer -> . ASTERISK pointer
    (113) pointer -> . ASTERISK
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    ID              reduce using rule 113 (pointer -> ASTERISK .)
    ASTERISK        shift and go to state 111
    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

  ! ID              [ shift and go to state 112 ]

    expression                     shift and go to state 113
    pointer                        shift and go to state 114
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 22

    (94) argumentlist -> LBRACKET . LAND ID RBRACKET

    LAND            shift and go to state 115


state 23

    (79) expression_land -> LAND . expression
    (119) token_land -> LAND .
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    AND             reduce using rule 119 (token_land -> LAND .)
    ID              reduce using rule 119 (token_land -> LAND .)
    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

  ! LAND            [ reduce using rule 119 (token_land -> LAND .) ]
  ! ID              [ shift and go to state 106 ]

    expression                     shift and go to state 116
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 24

    (3) bloco -> INDENT . program DEDENT
    (1) program -> . program statment
    (2) program -> .

    DEDENT          reduce using rule 2 (program -> .)
    if              reduce using rule 2 (program -> .)
    break           reduce using rule 2 (program -> .)
    continue        reduce using rule 2 (program -> .)
    ID              reduce using rule 2 (program -> .)
    ASTERISK        reduce using rule 2 (program -> .)
    LBRACKET        reduce using rule 2 (program -> .)
    INDENT          reduce using rule 2 (program -> .)
    for             reduce using rule 2 (program -> .)
    while           reduce using rule 2 (program -> .)
    do              reduce using rule 2 (program -> .)
    repeat          reduce using rule 2 (program -> .)
    unless          reduce using rule 2 (program -> .)
    CONST_REAL      reduce using rule 2 (program -> .)
    CONST_INTERGER  reduce using rule 2 (program -> .)
    CONST_STRING    reduce using rule 2 (program -> .)
    True            reduce using rule 2 (program -> .)
    False           reduce using rule 2 (program -> .)
    DSING           reduce using rule 2 (program -> .)
    LAND            reduce using rule 2 (program -> .)
    puts            reduce using rule 2 (program -> .)
    NOT             reduce using rule 2 (program -> .)
    PLUS            reduce using rule 2 (program -> .)
    MINUS           reduce using rule 2 (program -> .)
    int             reduce using rule 2 (program -> .)
    float           reduce using rule 2 (program -> .)
    boolean         reduce using rule 2 (program -> .)
    AND             reduce using rule 2 (program -> .)

    program                        shift and go to state 117

state 25

    (43) expression -> expression_binop .

    AND             reduce using rule 43 (expression -> expression_binop .)
    OR              reduce using rule 43 (expression -> expression_binop .)
    GT              reduce using rule 43 (expression -> expression_binop .)
    GE              reduce using rule 43 (expression -> expression_binop .)
    LT              reduce using rule 43 (expression -> expression_binop .)
    LE              reduce using rule 43 (expression -> expression_binop .)
    MINUS           reduce using rule 43 (expression -> expression_binop .)
    PLUS            reduce using rule 43 (expression -> expression_binop .)
    ASTERISK        reduce using rule 43 (expression -> expression_binop .)
    DIVIDE          reduce using rule 43 (expression -> expression_binop .)
    MODULE          reduce using rule 43 (expression -> expression_binop .)
    EQUALS          reduce using rule 43 (expression -> expression_binop .)
    DIFFERENT       reduce using rule 43 (expression -> expression_binop .)
    if              reduce using rule 43 (expression -> expression_binop .)
    break           reduce using rule 43 (expression -> expression_binop .)
    continue        reduce using rule 43 (expression -> expression_binop .)
    ID              reduce using rule 43 (expression -> expression_binop .)
    LBRACKET        reduce using rule 43 (expression -> expression_binop .)
    INDENT          reduce using rule 43 (expression -> expression_binop .)
    for             reduce using rule 43 (expression -> expression_binop .)
    while           reduce using rule 43 (expression -> expression_binop .)
    do              reduce using rule 43 (expression -> expression_binop .)
    repeat          reduce using rule 43 (expression -> expression_binop .)
    unless          reduce using rule 43 (expression -> expression_binop .)
    CONST_REAL      reduce using rule 43 (expression -> expression_binop .)
    CONST_INTERGER  reduce using rule 43 (expression -> expression_binop .)
    CONST_STRING    reduce using rule 43 (expression -> expression_binop .)
    True            reduce using rule 43 (expression -> expression_binop .)
    False           reduce using rule 43 (expression -> expression_binop .)
    DSING           reduce using rule 43 (expression -> expression_binop .)
    LAND            reduce using rule 43 (expression -> expression_binop .)
    puts            reduce using rule 43 (expression -> expression_binop .)
    NOT             reduce using rule 43 (expression -> expression_binop .)
    int             reduce using rule 43 (expression -> expression_binop .)
    float           reduce using rule 43 (expression -> expression_binop .)
    boolean         reduce using rule 43 (expression -> expression_binop .)
    $end            reduce using rule 43 (expression -> expression_binop .)
    begin           reduce using rule 43 (expression -> expression_binop .)
    DEDENT          reduce using rule 43 (expression -> expression_binop .)
    in              reduce using rule 43 (expression -> expression_binop .)
    then            reduce using rule 43 (expression -> expression_binop .)
    RBRACKET        reduce using rule 43 (expression -> expression_binop .)
    COMMA           reduce using rule 43 (expression -> expression_binop .)
    POINT           reduce using rule 43 (expression -> expression_binop .)
    end             reduce using rule 43 (expression -> expression_binop .)


state 26

    (44) expression -> expression_unitary .

    AND             reduce using rule 44 (expression -> expression_unitary .)
    OR              reduce using rule 44 (expression -> expression_unitary .)
    GT              reduce using rule 44 (expression -> expression_unitary .)
    GE              reduce using rule 44 (expression -> expression_unitary .)
    LT              reduce using rule 44 (expression -> expression_unitary .)
    LE              reduce using rule 44 (expression -> expression_unitary .)
    MINUS           reduce using rule 44 (expression -> expression_unitary .)
    PLUS            reduce using rule 44 (expression -> expression_unitary .)
    ASTERISK        reduce using rule 44 (expression -> expression_unitary .)
    DIVIDE          reduce using rule 44 (expression -> expression_unitary .)
    MODULE          reduce using rule 44 (expression -> expression_unitary .)
    EQUALS          reduce using rule 44 (expression -> expression_unitary .)
    DIFFERENT       reduce using rule 44 (expression -> expression_unitary .)
    if              reduce using rule 44 (expression -> expression_unitary .)
    break           reduce using rule 44 (expression -> expression_unitary .)
    continue        reduce using rule 44 (expression -> expression_unitary .)
    ID              reduce using rule 44 (expression -> expression_unitary .)
    LBRACKET        reduce using rule 44 (expression -> expression_unitary .)
    INDENT          reduce using rule 44 (expression -> expression_unitary .)
    for             reduce using rule 44 (expression -> expression_unitary .)
    while           reduce using rule 44 (expression -> expression_unitary .)
    do              reduce using rule 44 (expression -> expression_unitary .)
    repeat          reduce using rule 44 (expression -> expression_unitary .)
    unless          reduce using rule 44 (expression -> expression_unitary .)
    CONST_REAL      reduce using rule 44 (expression -> expression_unitary .)
    CONST_INTERGER  reduce using rule 44 (expression -> expression_unitary .)
    CONST_STRING    reduce using rule 44 (expression -> expression_unitary .)
    True            reduce using rule 44 (expression -> expression_unitary .)
    False           reduce using rule 44 (expression -> expression_unitary .)
    DSING           reduce using rule 44 (expression -> expression_unitary .)
    LAND            reduce using rule 44 (expression -> expression_unitary .)
    puts            reduce using rule 44 (expression -> expression_unitary .)
    NOT             reduce using rule 44 (expression -> expression_unitary .)
    int             reduce using rule 44 (expression -> expression_unitary .)
    float           reduce using rule 44 (expression -> expression_unitary .)
    boolean         reduce using rule 44 (expression -> expression_unitary .)
    $end            reduce using rule 44 (expression -> expression_unitary .)
    begin           reduce using rule 44 (expression -> expression_unitary .)
    DEDENT          reduce using rule 44 (expression -> expression_unitary .)
    in              reduce using rule 44 (expression -> expression_unitary .)
    then            reduce using rule 44 (expression -> expression_unitary .)
    RBRACKET        reduce using rule 44 (expression -> expression_unitary .)
    COMMA           reduce using rule 44 (expression -> expression_unitary .)
    POINT           reduce using rule 44 (expression -> expression_unitary .)
    end             reduce using rule 44 (expression -> expression_unitary .)


state 27

    (45) expression -> expression_const_real .

    AND             reduce using rule 45 (expression -> expression_const_real .)
    OR              reduce using rule 45 (expression -> expression_const_real .)
    GT              reduce using rule 45 (expression -> expression_const_real .)
    GE              reduce using rule 45 (expression -> expression_const_real .)
    LT              reduce using rule 45 (expression -> expression_const_real .)
    LE              reduce using rule 45 (expression -> expression_const_real .)
    MINUS           reduce using rule 45 (expression -> expression_const_real .)
    PLUS            reduce using rule 45 (expression -> expression_const_real .)
    ASTERISK        reduce using rule 45 (expression -> expression_const_real .)
    DIVIDE          reduce using rule 45 (expression -> expression_const_real .)
    MODULE          reduce using rule 45 (expression -> expression_const_real .)
    EQUALS          reduce using rule 45 (expression -> expression_const_real .)
    DIFFERENT       reduce using rule 45 (expression -> expression_const_real .)
    if              reduce using rule 45 (expression -> expression_const_real .)
    break           reduce using rule 45 (expression -> expression_const_real .)
    continue        reduce using rule 45 (expression -> expression_const_real .)
    ID              reduce using rule 45 (expression -> expression_const_real .)
    LBRACKET        reduce using rule 45 (expression -> expression_const_real .)
    INDENT          reduce using rule 45 (expression -> expression_const_real .)
    for             reduce using rule 45 (expression -> expression_const_real .)
    while           reduce using rule 45 (expression -> expression_const_real .)
    do              reduce using rule 45 (expression -> expression_const_real .)
    repeat          reduce using rule 45 (expression -> expression_const_real .)
    unless          reduce using rule 45 (expression -> expression_const_real .)
    CONST_REAL      reduce using rule 45 (expression -> expression_const_real .)
    CONST_INTERGER  reduce using rule 45 (expression -> expression_const_real .)
    CONST_STRING    reduce using rule 45 (expression -> expression_const_real .)
    True            reduce using rule 45 (expression -> expression_const_real .)
    False           reduce using rule 45 (expression -> expression_const_real .)
    DSING           reduce using rule 45 (expression -> expression_const_real .)
    LAND            reduce using rule 45 (expression -> expression_const_real .)
    puts            reduce using rule 45 (expression -> expression_const_real .)
    NOT             reduce using rule 45 (expression -> expression_const_real .)
    int             reduce using rule 45 (expression -> expression_const_real .)
    float           reduce using rule 45 (expression -> expression_const_real .)
    boolean         reduce using rule 45 (expression -> expression_const_real .)
    $end            reduce using rule 45 (expression -> expression_const_real .)
    begin           reduce using rule 45 (expression -> expression_const_real .)
    DEDENT          reduce using rule 45 (expression -> expression_const_real .)
    in              reduce using rule 45 (expression -> expression_const_real .)
    then            reduce using rule 45 (expression -> expression_const_real .)
    RBRACKET        reduce using rule 45 (expression -> expression_const_real .)
    COMMA           reduce using rule 45 (expression -> expression_const_real .)
    POINT           reduce using rule 45 (expression -> expression_const_real .)
    end             reduce using rule 45 (expression -> expression_const_real .)


state 28

    (46) expression -> expression_const_interger .

    AND             reduce using rule 46 (expression -> expression_const_interger .)
    OR              reduce using rule 46 (expression -> expression_const_interger .)
    GT              reduce using rule 46 (expression -> expression_const_interger .)
    GE              reduce using rule 46 (expression -> expression_const_interger .)
    LT              reduce using rule 46 (expression -> expression_const_interger .)
    LE              reduce using rule 46 (expression -> expression_const_interger .)
    MINUS           reduce using rule 46 (expression -> expression_const_interger .)
    PLUS            reduce using rule 46 (expression -> expression_const_interger .)
    ASTERISK        reduce using rule 46 (expression -> expression_const_interger .)
    DIVIDE          reduce using rule 46 (expression -> expression_const_interger .)
    MODULE          reduce using rule 46 (expression -> expression_const_interger .)
    EQUALS          reduce using rule 46 (expression -> expression_const_interger .)
    DIFFERENT       reduce using rule 46 (expression -> expression_const_interger .)
    if              reduce using rule 46 (expression -> expression_const_interger .)
    break           reduce using rule 46 (expression -> expression_const_interger .)
    continue        reduce using rule 46 (expression -> expression_const_interger .)
    ID              reduce using rule 46 (expression -> expression_const_interger .)
    LBRACKET        reduce using rule 46 (expression -> expression_const_interger .)
    INDENT          reduce using rule 46 (expression -> expression_const_interger .)
    for             reduce using rule 46 (expression -> expression_const_interger .)
    while           reduce using rule 46 (expression -> expression_const_interger .)
    do              reduce using rule 46 (expression -> expression_const_interger .)
    repeat          reduce using rule 46 (expression -> expression_const_interger .)
    unless          reduce using rule 46 (expression -> expression_const_interger .)
    CONST_REAL      reduce using rule 46 (expression -> expression_const_interger .)
    CONST_INTERGER  reduce using rule 46 (expression -> expression_const_interger .)
    CONST_STRING    reduce using rule 46 (expression -> expression_const_interger .)
    True            reduce using rule 46 (expression -> expression_const_interger .)
    False           reduce using rule 46 (expression -> expression_const_interger .)
    DSING           reduce using rule 46 (expression -> expression_const_interger .)
    LAND            reduce using rule 46 (expression -> expression_const_interger .)
    puts            reduce using rule 46 (expression -> expression_const_interger .)
    NOT             reduce using rule 46 (expression -> expression_const_interger .)
    int             reduce using rule 46 (expression -> expression_const_interger .)
    float           reduce using rule 46 (expression -> expression_const_interger .)
    boolean         reduce using rule 46 (expression -> expression_const_interger .)
    $end            reduce using rule 46 (expression -> expression_const_interger .)
    begin           reduce using rule 46 (expression -> expression_const_interger .)
    DEDENT          reduce using rule 46 (expression -> expression_const_interger .)
    in              reduce using rule 46 (expression -> expression_const_interger .)
    then            reduce using rule 46 (expression -> expression_const_interger .)
    RBRACKET        reduce using rule 46 (expression -> expression_const_interger .)
    COMMA           reduce using rule 46 (expression -> expression_const_interger .)
    POINT           reduce using rule 46 (expression -> expression_const_interger .)
    end             reduce using rule 46 (expression -> expression_const_interger .)


state 29

    (47) expression -> expression_const_string .

    AND             reduce using rule 47 (expression -> expression_const_string .)
    OR              reduce using rule 47 (expression -> expression_const_string .)
    GT              reduce using rule 47 (expression -> expression_const_string .)
    GE              reduce using rule 47 (expression -> expression_const_string .)
    LT              reduce using rule 47 (expression -> expression_const_string .)
    LE              reduce using rule 47 (expression -> expression_const_string .)
    MINUS           reduce using rule 47 (expression -> expression_const_string .)
    PLUS            reduce using rule 47 (expression -> expression_const_string .)
    ASTERISK        reduce using rule 47 (expression -> expression_const_string .)
    DIVIDE          reduce using rule 47 (expression -> expression_const_string .)
    MODULE          reduce using rule 47 (expression -> expression_const_string .)
    EQUALS          reduce using rule 47 (expression -> expression_const_string .)
    DIFFERENT       reduce using rule 47 (expression -> expression_const_string .)
    if              reduce using rule 47 (expression -> expression_const_string .)
    break           reduce using rule 47 (expression -> expression_const_string .)
    continue        reduce using rule 47 (expression -> expression_const_string .)
    ID              reduce using rule 47 (expression -> expression_const_string .)
    LBRACKET        reduce using rule 47 (expression -> expression_const_string .)
    INDENT          reduce using rule 47 (expression -> expression_const_string .)
    for             reduce using rule 47 (expression -> expression_const_string .)
    while           reduce using rule 47 (expression -> expression_const_string .)
    do              reduce using rule 47 (expression -> expression_const_string .)
    repeat          reduce using rule 47 (expression -> expression_const_string .)
    unless          reduce using rule 47 (expression -> expression_const_string .)
    CONST_REAL      reduce using rule 47 (expression -> expression_const_string .)
    CONST_INTERGER  reduce using rule 47 (expression -> expression_const_string .)
    CONST_STRING    reduce using rule 47 (expression -> expression_const_string .)
    True            reduce using rule 47 (expression -> expression_const_string .)
    False           reduce using rule 47 (expression -> expression_const_string .)
    DSING           reduce using rule 47 (expression -> expression_const_string .)
    LAND            reduce using rule 47 (expression -> expression_const_string .)
    puts            reduce using rule 47 (expression -> expression_const_string .)
    NOT             reduce using rule 47 (expression -> expression_const_string .)
    int             reduce using rule 47 (expression -> expression_const_string .)
    float           reduce using rule 47 (expression -> expression_const_string .)
    boolean         reduce using rule 47 (expression -> expression_const_string .)
    $end            reduce using rule 47 (expression -> expression_const_string .)
    begin           reduce using rule 47 (expression -> expression_const_string .)
    DEDENT          reduce using rule 47 (expression -> expression_const_string .)
    in              reduce using rule 47 (expression -> expression_const_string .)
    then            reduce using rule 47 (expression -> expression_const_string .)
    RBRACKET        reduce using rule 47 (expression -> expression_const_string .)
    COMMA           reduce using rule 47 (expression -> expression_const_string .)
    POINT           reduce using rule 47 (expression -> expression_const_string .)
    end             reduce using rule 47 (expression -> expression_const_string .)


state 30

    (48) expression -> expression_true .

    AND             reduce using rule 48 (expression -> expression_true .)
    OR              reduce using rule 48 (expression -> expression_true .)
    GT              reduce using rule 48 (expression -> expression_true .)
    GE              reduce using rule 48 (expression -> expression_true .)
    LT              reduce using rule 48 (expression -> expression_true .)
    LE              reduce using rule 48 (expression -> expression_true .)
    MINUS           reduce using rule 48 (expression -> expression_true .)
    PLUS            reduce using rule 48 (expression -> expression_true .)
    ASTERISK        reduce using rule 48 (expression -> expression_true .)
    DIVIDE          reduce using rule 48 (expression -> expression_true .)
    MODULE          reduce using rule 48 (expression -> expression_true .)
    EQUALS          reduce using rule 48 (expression -> expression_true .)
    DIFFERENT       reduce using rule 48 (expression -> expression_true .)
    if              reduce using rule 48 (expression -> expression_true .)
    break           reduce using rule 48 (expression -> expression_true .)
    continue        reduce using rule 48 (expression -> expression_true .)
    ID              reduce using rule 48 (expression -> expression_true .)
    LBRACKET        reduce using rule 48 (expression -> expression_true .)
    INDENT          reduce using rule 48 (expression -> expression_true .)
    for             reduce using rule 48 (expression -> expression_true .)
    while           reduce using rule 48 (expression -> expression_true .)
    do              reduce using rule 48 (expression -> expression_true .)
    repeat          reduce using rule 48 (expression -> expression_true .)
    unless          reduce using rule 48 (expression -> expression_true .)
    CONST_REAL      reduce using rule 48 (expression -> expression_true .)
    CONST_INTERGER  reduce using rule 48 (expression -> expression_true .)
    CONST_STRING    reduce using rule 48 (expression -> expression_true .)
    True            reduce using rule 48 (expression -> expression_true .)
    False           reduce using rule 48 (expression -> expression_true .)
    DSING           reduce using rule 48 (expression -> expression_true .)
    LAND            reduce using rule 48 (expression -> expression_true .)
    puts            reduce using rule 48 (expression -> expression_true .)
    NOT             reduce using rule 48 (expression -> expression_true .)
    int             reduce using rule 48 (expression -> expression_true .)
    float           reduce using rule 48 (expression -> expression_true .)
    boolean         reduce using rule 48 (expression -> expression_true .)
    $end            reduce using rule 48 (expression -> expression_true .)
    begin           reduce using rule 48 (expression -> expression_true .)
    DEDENT          reduce using rule 48 (expression -> expression_true .)
    in              reduce using rule 48 (expression -> expression_true .)
    then            reduce using rule 48 (expression -> expression_true .)
    RBRACKET        reduce using rule 48 (expression -> expression_true .)
    COMMA           reduce using rule 48 (expression -> expression_true .)
    POINT           reduce using rule 48 (expression -> expression_true .)
    end             reduce using rule 48 (expression -> expression_true .)


state 31

    (49) expression -> expression_false .

    AND             reduce using rule 49 (expression -> expression_false .)
    OR              reduce using rule 49 (expression -> expression_false .)
    GT              reduce using rule 49 (expression -> expression_false .)
    GE              reduce using rule 49 (expression -> expression_false .)
    LT              reduce using rule 49 (expression -> expression_false .)
    LE              reduce using rule 49 (expression -> expression_false .)
    MINUS           reduce using rule 49 (expression -> expression_false .)
    PLUS            reduce using rule 49 (expression -> expression_false .)
    ASTERISK        reduce using rule 49 (expression -> expression_false .)
    DIVIDE          reduce using rule 49 (expression -> expression_false .)
    MODULE          reduce using rule 49 (expression -> expression_false .)
    EQUALS          reduce using rule 49 (expression -> expression_false .)
    DIFFERENT       reduce using rule 49 (expression -> expression_false .)
    if              reduce using rule 49 (expression -> expression_false .)
    break           reduce using rule 49 (expression -> expression_false .)
    continue        reduce using rule 49 (expression -> expression_false .)
    ID              reduce using rule 49 (expression -> expression_false .)
    LBRACKET        reduce using rule 49 (expression -> expression_false .)
    INDENT          reduce using rule 49 (expression -> expression_false .)
    for             reduce using rule 49 (expression -> expression_false .)
    while           reduce using rule 49 (expression -> expression_false .)
    do              reduce using rule 49 (expression -> expression_false .)
    repeat          reduce using rule 49 (expression -> expression_false .)
    unless          reduce using rule 49 (expression -> expression_false .)
    CONST_REAL      reduce using rule 49 (expression -> expression_false .)
    CONST_INTERGER  reduce using rule 49 (expression -> expression_false .)
    CONST_STRING    reduce using rule 49 (expression -> expression_false .)
    True            reduce using rule 49 (expression -> expression_false .)
    False           reduce using rule 49 (expression -> expression_false .)
    DSING           reduce using rule 49 (expression -> expression_false .)
    LAND            reduce using rule 49 (expression -> expression_false .)
    puts            reduce using rule 49 (expression -> expression_false .)
    NOT             reduce using rule 49 (expression -> expression_false .)
    int             reduce using rule 49 (expression -> expression_false .)
    float           reduce using rule 49 (expression -> expression_false .)
    boolean         reduce using rule 49 (expression -> expression_false .)
    $end            reduce using rule 49 (expression -> expression_false .)
    begin           reduce using rule 49 (expression -> expression_false .)
    DEDENT          reduce using rule 49 (expression -> expression_false .)
    in              reduce using rule 49 (expression -> expression_false .)
    then            reduce using rule 49 (expression -> expression_false .)
    RBRACKET        reduce using rule 49 (expression -> expression_false .)
    COMMA           reduce using rule 49 (expression -> expression_false .)
    POINT           reduce using rule 49 (expression -> expression_false .)
    end             reduce using rule 49 (expression -> expression_false .)


state 32

    (50) expression -> expression_variable .

    AND             reduce using rule 50 (expression -> expression_variable .)
    OR              reduce using rule 50 (expression -> expression_variable .)
    GT              reduce using rule 50 (expression -> expression_variable .)
    GE              reduce using rule 50 (expression -> expression_variable .)
    LT              reduce using rule 50 (expression -> expression_variable .)
    LE              reduce using rule 50 (expression -> expression_variable .)
    MINUS           reduce using rule 50 (expression -> expression_variable .)
    PLUS            reduce using rule 50 (expression -> expression_variable .)
    ASTERISK        reduce using rule 50 (expression -> expression_variable .)
    DIVIDE          reduce using rule 50 (expression -> expression_variable .)
    MODULE          reduce using rule 50 (expression -> expression_variable .)
    EQUALS          reduce using rule 50 (expression -> expression_variable .)
    DIFFERENT       reduce using rule 50 (expression -> expression_variable .)
    if              reduce using rule 50 (expression -> expression_variable .)
    break           reduce using rule 50 (expression -> expression_variable .)
    continue        reduce using rule 50 (expression -> expression_variable .)
    ID              reduce using rule 50 (expression -> expression_variable .)
    LBRACKET        reduce using rule 50 (expression -> expression_variable .)
    INDENT          reduce using rule 50 (expression -> expression_variable .)
    for             reduce using rule 50 (expression -> expression_variable .)
    while           reduce using rule 50 (expression -> expression_variable .)
    do              reduce using rule 50 (expression -> expression_variable .)
    repeat          reduce using rule 50 (expression -> expression_variable .)
    unless          reduce using rule 50 (expression -> expression_variable .)
    CONST_REAL      reduce using rule 50 (expression -> expression_variable .)
    CONST_INTERGER  reduce using rule 50 (expression -> expression_variable .)
    CONST_STRING    reduce using rule 50 (expression -> expression_variable .)
    True            reduce using rule 50 (expression -> expression_variable .)
    False           reduce using rule 50 (expression -> expression_variable .)
    DSING           reduce using rule 50 (expression -> expression_variable .)
    LAND            reduce using rule 50 (expression -> expression_variable .)
    puts            reduce using rule 50 (expression -> expression_variable .)
    NOT             reduce using rule 50 (expression -> expression_variable .)
    int             reduce using rule 50 (expression -> expression_variable .)
    float           reduce using rule 50 (expression -> expression_variable .)
    boolean         reduce using rule 50 (expression -> expression_variable .)
    $end            reduce using rule 50 (expression -> expression_variable .)
    begin           reduce using rule 50 (expression -> expression_variable .)
    DEDENT          reduce using rule 50 (expression -> expression_variable .)
    then            reduce using rule 50 (expression -> expression_variable .)
    in              reduce using rule 50 (expression -> expression_variable .)
    RBRACKET        reduce using rule 50 (expression -> expression_variable .)
    COMMA           reduce using rule 50 (expression -> expression_variable .)
    POINT           reduce using rule 50 (expression -> expression_variable .)
    end             reduce using rule 50 (expression -> expression_variable .)


state 33

    (51) expression -> expression_land .

    AND             reduce using rule 51 (expression -> expression_land .)
    OR              reduce using rule 51 (expression -> expression_land .)
    GT              reduce using rule 51 (expression -> expression_land .)
    GE              reduce using rule 51 (expression -> expression_land .)
    LT              reduce using rule 51 (expression -> expression_land .)
    LE              reduce using rule 51 (expression -> expression_land .)
    MINUS           reduce using rule 51 (expression -> expression_land .)
    PLUS            reduce using rule 51 (expression -> expression_land .)
    ASTERISK        reduce using rule 51 (expression -> expression_land .)
    DIVIDE          reduce using rule 51 (expression -> expression_land .)
    MODULE          reduce using rule 51 (expression -> expression_land .)
    EQUALS          reduce using rule 51 (expression -> expression_land .)
    DIFFERENT       reduce using rule 51 (expression -> expression_land .)
    if              reduce using rule 51 (expression -> expression_land .)
    break           reduce using rule 51 (expression -> expression_land .)
    continue        reduce using rule 51 (expression -> expression_land .)
    ID              reduce using rule 51 (expression -> expression_land .)
    LBRACKET        reduce using rule 51 (expression -> expression_land .)
    INDENT          reduce using rule 51 (expression -> expression_land .)
    for             reduce using rule 51 (expression -> expression_land .)
    while           reduce using rule 51 (expression -> expression_land .)
    do              reduce using rule 51 (expression -> expression_land .)
    repeat          reduce using rule 51 (expression -> expression_land .)
    unless          reduce using rule 51 (expression -> expression_land .)
    CONST_REAL      reduce using rule 51 (expression -> expression_land .)
    CONST_INTERGER  reduce using rule 51 (expression -> expression_land .)
    CONST_STRING    reduce using rule 51 (expression -> expression_land .)
    True            reduce using rule 51 (expression -> expression_land .)
    False           reduce using rule 51 (expression -> expression_land .)
    DSING           reduce using rule 51 (expression -> expression_land .)
    LAND            reduce using rule 51 (expression -> expression_land .)
    puts            reduce using rule 51 (expression -> expression_land .)
    NOT             reduce using rule 51 (expression -> expression_land .)
    int             reduce using rule 51 (expression -> expression_land .)
    float           reduce using rule 51 (expression -> expression_land .)
    boolean         reduce using rule 51 (expression -> expression_land .)
    $end            reduce using rule 51 (expression -> expression_land .)
    begin           reduce using rule 51 (expression -> expression_land .)
    DEDENT          reduce using rule 51 (expression -> expression_land .)
    in              reduce using rule 51 (expression -> expression_land .)
    then            reduce using rule 51 (expression -> expression_land .)
    RBRACKET        reduce using rule 51 (expression -> expression_land .)
    COMMA           reduce using rule 51 (expression -> expression_land .)
    POINT           reduce using rule 51 (expression -> expression_land .)
    end             reduce using rule 51 (expression -> expression_land .)


state 34

    (16) declaration -> simple_declaration .

    if              reduce using rule 16 (declaration -> simple_declaration .)
    break           reduce using rule 16 (declaration -> simple_declaration .)
    continue        reduce using rule 16 (declaration -> simple_declaration .)
    ID              reduce using rule 16 (declaration -> simple_declaration .)
    ASTERISK        reduce using rule 16 (declaration -> simple_declaration .)
    LBRACKET        reduce using rule 16 (declaration -> simple_declaration .)
    INDENT          reduce using rule 16 (declaration -> simple_declaration .)
    for             reduce using rule 16 (declaration -> simple_declaration .)
    while           reduce using rule 16 (declaration -> simple_declaration .)
    do              reduce using rule 16 (declaration -> simple_declaration .)
    repeat          reduce using rule 16 (declaration -> simple_declaration .)
    unless          reduce using rule 16 (declaration -> simple_declaration .)
    CONST_REAL      reduce using rule 16 (declaration -> simple_declaration .)
    CONST_INTERGER  reduce using rule 16 (declaration -> simple_declaration .)
    CONST_STRING    reduce using rule 16 (declaration -> simple_declaration .)
    True            reduce using rule 16 (declaration -> simple_declaration .)
    False           reduce using rule 16 (declaration -> simple_declaration .)
    DSING           reduce using rule 16 (declaration -> simple_declaration .)
    LAND            reduce using rule 16 (declaration -> simple_declaration .)
    puts            reduce using rule 16 (declaration -> simple_declaration .)
    NOT             reduce using rule 16 (declaration -> simple_declaration .)
    PLUS            reduce using rule 16 (declaration -> simple_declaration .)
    MINUS           reduce using rule 16 (declaration -> simple_declaration .)
    int             reduce using rule 16 (declaration -> simple_declaration .)
    float           reduce using rule 16 (declaration -> simple_declaration .)
    boolean         reduce using rule 16 (declaration -> simple_declaration .)
    AND             reduce using rule 16 (declaration -> simple_declaration .)
    $end            reduce using rule 16 (declaration -> simple_declaration .)
    DEDENT          reduce using rule 16 (declaration -> simple_declaration .)


state 35

    (17) declaration -> complex_declaration .

    if              reduce using rule 17 (declaration -> complex_declaration .)
    break           reduce using rule 17 (declaration -> complex_declaration .)
    continue        reduce using rule 17 (declaration -> complex_declaration .)
    ID              reduce using rule 17 (declaration -> complex_declaration .)
    ASTERISK        reduce using rule 17 (declaration -> complex_declaration .)
    LBRACKET        reduce using rule 17 (declaration -> complex_declaration .)
    INDENT          reduce using rule 17 (declaration -> complex_declaration .)
    for             reduce using rule 17 (declaration -> complex_declaration .)
    while           reduce using rule 17 (declaration -> complex_declaration .)
    do              reduce using rule 17 (declaration -> complex_declaration .)
    repeat          reduce using rule 17 (declaration -> complex_declaration .)
    unless          reduce using rule 17 (declaration -> complex_declaration .)
    CONST_REAL      reduce using rule 17 (declaration -> complex_declaration .)
    CONST_INTERGER  reduce using rule 17 (declaration -> complex_declaration .)
    CONST_STRING    reduce using rule 17 (declaration -> complex_declaration .)
    True            reduce using rule 17 (declaration -> complex_declaration .)
    False           reduce using rule 17 (declaration -> complex_declaration .)
    DSING           reduce using rule 17 (declaration -> complex_declaration .)
    LAND            reduce using rule 17 (declaration -> complex_declaration .)
    puts            reduce using rule 17 (declaration -> complex_declaration .)
    NOT             reduce using rule 17 (declaration -> complex_declaration .)
    PLUS            reduce using rule 17 (declaration -> complex_declaration .)
    MINUS           reduce using rule 17 (declaration -> complex_declaration .)
    int             reduce using rule 17 (declaration -> complex_declaration .)
    float           reduce using rule 17 (declaration -> complex_declaration .)
    boolean         reduce using rule 17 (declaration -> complex_declaration .)
    AND             reduce using rule 17 (declaration -> complex_declaration .)
    $end            reduce using rule 17 (declaration -> complex_declaration .)
    DEDENT          reduce using rule 17 (declaration -> complex_declaration .)


state 36

    (18) declaration -> declaration_pointer .

    if              reduce using rule 18 (declaration -> declaration_pointer .)
    break           reduce using rule 18 (declaration -> declaration_pointer .)
    continue        reduce using rule 18 (declaration -> declaration_pointer .)
    ID              reduce using rule 18 (declaration -> declaration_pointer .)
    ASTERISK        reduce using rule 18 (declaration -> declaration_pointer .)
    LBRACKET        reduce using rule 18 (declaration -> declaration_pointer .)
    INDENT          reduce using rule 18 (declaration -> declaration_pointer .)
    for             reduce using rule 18 (declaration -> declaration_pointer .)
    while           reduce using rule 18 (declaration -> declaration_pointer .)
    do              reduce using rule 18 (declaration -> declaration_pointer .)
    repeat          reduce using rule 18 (declaration -> declaration_pointer .)
    unless          reduce using rule 18 (declaration -> declaration_pointer .)
    CONST_REAL      reduce using rule 18 (declaration -> declaration_pointer .)
    CONST_INTERGER  reduce using rule 18 (declaration -> declaration_pointer .)
    CONST_STRING    reduce using rule 18 (declaration -> declaration_pointer .)
    True            reduce using rule 18 (declaration -> declaration_pointer .)
    False           reduce using rule 18 (declaration -> declaration_pointer .)
    DSING           reduce using rule 18 (declaration -> declaration_pointer .)
    LAND            reduce using rule 18 (declaration -> declaration_pointer .)
    puts            reduce using rule 18 (declaration -> declaration_pointer .)
    NOT             reduce using rule 18 (declaration -> declaration_pointer .)
    PLUS            reduce using rule 18 (declaration -> declaration_pointer .)
    MINUS           reduce using rule 18 (declaration -> declaration_pointer .)
    int             reduce using rule 18 (declaration -> declaration_pointer .)
    float           reduce using rule 18 (declaration -> declaration_pointer .)
    boolean         reduce using rule 18 (declaration -> declaration_pointer .)
    AND             reduce using rule 18 (declaration -> declaration_pointer .)
    $end            reduce using rule 18 (declaration -> declaration_pointer .)
    DEDENT          reduce using rule 18 (declaration -> declaration_pointer .)


state 37

    (19) declaration -> acess_pointer .

    if              reduce using rule 19 (declaration -> acess_pointer .)
    break           reduce using rule 19 (declaration -> acess_pointer .)
    continue        reduce using rule 19 (declaration -> acess_pointer .)
    ID              reduce using rule 19 (declaration -> acess_pointer .)
    ASTERISK        reduce using rule 19 (declaration -> acess_pointer .)
    LBRACKET        reduce using rule 19 (declaration -> acess_pointer .)
    INDENT          reduce using rule 19 (declaration -> acess_pointer .)
    for             reduce using rule 19 (declaration -> acess_pointer .)
    while           reduce using rule 19 (declaration -> acess_pointer .)
    do              reduce using rule 19 (declaration -> acess_pointer .)
    repeat          reduce using rule 19 (declaration -> acess_pointer .)
    unless          reduce using rule 19 (declaration -> acess_pointer .)
    CONST_REAL      reduce using rule 19 (declaration -> acess_pointer .)
    CONST_INTERGER  reduce using rule 19 (declaration -> acess_pointer .)
    CONST_STRING    reduce using rule 19 (declaration -> acess_pointer .)
    True            reduce using rule 19 (declaration -> acess_pointer .)
    False           reduce using rule 19 (declaration -> acess_pointer .)
    DSING           reduce using rule 19 (declaration -> acess_pointer .)
    LAND            reduce using rule 19 (declaration -> acess_pointer .)
    puts            reduce using rule 19 (declaration -> acess_pointer .)
    NOT             reduce using rule 19 (declaration -> acess_pointer .)
    PLUS            reduce using rule 19 (declaration -> acess_pointer .)
    MINUS           reduce using rule 19 (declaration -> acess_pointer .)
    int             reduce using rule 19 (declaration -> acess_pointer .)
    float           reduce using rule 19 (declaration -> acess_pointer .)
    boolean         reduce using rule 19 (declaration -> acess_pointer .)
    AND             reduce using rule 19 (declaration -> acess_pointer .)
    $end            reduce using rule 19 (declaration -> acess_pointer .)
    DEDENT          reduce using rule 19 (declaration -> acess_pointer .)


state 38

    (98) create_puts -> puts_const_string .

    if              reduce using rule 98 (create_puts -> puts_const_string .)
    break           reduce using rule 98 (create_puts -> puts_const_string .)
    continue        reduce using rule 98 (create_puts -> puts_const_string .)
    ID              reduce using rule 98 (create_puts -> puts_const_string .)
    ASTERISK        reduce using rule 98 (create_puts -> puts_const_string .)
    LBRACKET        reduce using rule 98 (create_puts -> puts_const_string .)
    INDENT          reduce using rule 98 (create_puts -> puts_const_string .)
    for             reduce using rule 98 (create_puts -> puts_const_string .)
    while           reduce using rule 98 (create_puts -> puts_const_string .)
    do              reduce using rule 98 (create_puts -> puts_const_string .)
    repeat          reduce using rule 98 (create_puts -> puts_const_string .)
    unless          reduce using rule 98 (create_puts -> puts_const_string .)
    CONST_REAL      reduce using rule 98 (create_puts -> puts_const_string .)
    CONST_INTERGER  reduce using rule 98 (create_puts -> puts_const_string .)
    CONST_STRING    reduce using rule 98 (create_puts -> puts_const_string .)
    True            reduce using rule 98 (create_puts -> puts_const_string .)
    False           reduce using rule 98 (create_puts -> puts_const_string .)
    DSING           reduce using rule 98 (create_puts -> puts_const_string .)
    LAND            reduce using rule 98 (create_puts -> puts_const_string .)
    puts            reduce using rule 98 (create_puts -> puts_const_string .)
    NOT             reduce using rule 98 (create_puts -> puts_const_string .)
    PLUS            reduce using rule 98 (create_puts -> puts_const_string .)
    MINUS           reduce using rule 98 (create_puts -> puts_const_string .)
    int             reduce using rule 98 (create_puts -> puts_const_string .)
    float           reduce using rule 98 (create_puts -> puts_const_string .)
    boolean         reduce using rule 98 (create_puts -> puts_const_string .)
    AND             reduce using rule 98 (create_puts -> puts_const_string .)
    $end            reduce using rule 98 (create_puts -> puts_const_string .)
    DEDENT          reduce using rule 98 (create_puts -> puts_const_string .)


state 39

    (99) create_puts -> puts_expression .

    if              reduce using rule 99 (create_puts -> puts_expression .)
    break           reduce using rule 99 (create_puts -> puts_expression .)
    continue        reduce using rule 99 (create_puts -> puts_expression .)
    ID              reduce using rule 99 (create_puts -> puts_expression .)
    ASTERISK        reduce using rule 99 (create_puts -> puts_expression .)
    LBRACKET        reduce using rule 99 (create_puts -> puts_expression .)
    INDENT          reduce using rule 99 (create_puts -> puts_expression .)
    for             reduce using rule 99 (create_puts -> puts_expression .)
    while           reduce using rule 99 (create_puts -> puts_expression .)
    do              reduce using rule 99 (create_puts -> puts_expression .)
    repeat          reduce using rule 99 (create_puts -> puts_expression .)
    unless          reduce using rule 99 (create_puts -> puts_expression .)
    CONST_REAL      reduce using rule 99 (create_puts -> puts_expression .)
    CONST_INTERGER  reduce using rule 99 (create_puts -> puts_expression .)
    CONST_STRING    reduce using rule 99 (create_puts -> puts_expression .)
    True            reduce using rule 99 (create_puts -> puts_expression .)
    False           reduce using rule 99 (create_puts -> puts_expression .)
    DSING           reduce using rule 99 (create_puts -> puts_expression .)
    LAND            reduce using rule 99 (create_puts -> puts_expression .)
    puts            reduce using rule 99 (create_puts -> puts_expression .)
    NOT             reduce using rule 99 (create_puts -> puts_expression .)
    PLUS            reduce using rule 99 (create_puts -> puts_expression .)
    MINUS           reduce using rule 99 (create_puts -> puts_expression .)
    int             reduce using rule 99 (create_puts -> puts_expression .)
    float           reduce using rule 99 (create_puts -> puts_expression .)
    boolean         reduce using rule 99 (create_puts -> puts_expression .)
    AND             reduce using rule 99 (create_puts -> puts_expression .)
    $end            reduce using rule 99 (create_puts -> puts_expression .)
    DEDENT          reduce using rule 99 (create_puts -> puts_expression .)


state 40

    (100) create_puts -> puts_quotation .

    if              reduce using rule 100 (create_puts -> puts_quotation .)
    break           reduce using rule 100 (create_puts -> puts_quotation .)
    continue        reduce using rule 100 (create_puts -> puts_quotation .)
    ID              reduce using rule 100 (create_puts -> puts_quotation .)
    ASTERISK        reduce using rule 100 (create_puts -> puts_quotation .)
    LBRACKET        reduce using rule 100 (create_puts -> puts_quotation .)
    INDENT          reduce using rule 100 (create_puts -> puts_quotation .)
    for             reduce using rule 100 (create_puts -> puts_quotation .)
    while           reduce using rule 100 (create_puts -> puts_quotation .)
    do              reduce using rule 100 (create_puts -> puts_quotation .)
    repeat          reduce using rule 100 (create_puts -> puts_quotation .)
    unless          reduce using rule 100 (create_puts -> puts_quotation .)
    CONST_REAL      reduce using rule 100 (create_puts -> puts_quotation .)
    CONST_INTERGER  reduce using rule 100 (create_puts -> puts_quotation .)
    CONST_STRING    reduce using rule 100 (create_puts -> puts_quotation .)
    True            reduce using rule 100 (create_puts -> puts_quotation .)
    False           reduce using rule 100 (create_puts -> puts_quotation .)
    DSING           reduce using rule 100 (create_puts -> puts_quotation .)
    LAND            reduce using rule 100 (create_puts -> puts_quotation .)
    puts            reduce using rule 100 (create_puts -> puts_quotation .)
    NOT             reduce using rule 100 (create_puts -> puts_quotation .)
    PLUS            reduce using rule 100 (create_puts -> puts_quotation .)
    MINUS           reduce using rule 100 (create_puts -> puts_quotation .)
    int             reduce using rule 100 (create_puts -> puts_quotation .)
    float           reduce using rule 100 (create_puts -> puts_quotation .)
    boolean         reduce using rule 100 (create_puts -> puts_quotation .)
    AND             reduce using rule 100 (create_puts -> puts_quotation .)
    $end            reduce using rule 100 (create_puts -> puts_quotation .)
    DEDENT          reduce using rule 100 (create_puts -> puts_quotation .)


state 41

    (101) create_puts -> puts_dquotation .

    if              reduce using rule 101 (create_puts -> puts_dquotation .)
    break           reduce using rule 101 (create_puts -> puts_dquotation .)
    continue        reduce using rule 101 (create_puts -> puts_dquotation .)
    ID              reduce using rule 101 (create_puts -> puts_dquotation .)
    ASTERISK        reduce using rule 101 (create_puts -> puts_dquotation .)
    LBRACKET        reduce using rule 101 (create_puts -> puts_dquotation .)
    INDENT          reduce using rule 101 (create_puts -> puts_dquotation .)
    for             reduce using rule 101 (create_puts -> puts_dquotation .)
    while           reduce using rule 101 (create_puts -> puts_dquotation .)
    do              reduce using rule 101 (create_puts -> puts_dquotation .)
    repeat          reduce using rule 101 (create_puts -> puts_dquotation .)
    unless          reduce using rule 101 (create_puts -> puts_dquotation .)
    CONST_REAL      reduce using rule 101 (create_puts -> puts_dquotation .)
    CONST_INTERGER  reduce using rule 101 (create_puts -> puts_dquotation .)
    CONST_STRING    reduce using rule 101 (create_puts -> puts_dquotation .)
    True            reduce using rule 101 (create_puts -> puts_dquotation .)
    False           reduce using rule 101 (create_puts -> puts_dquotation .)
    DSING           reduce using rule 101 (create_puts -> puts_dquotation .)
    LAND            reduce using rule 101 (create_puts -> puts_dquotation .)
    puts            reduce using rule 101 (create_puts -> puts_dquotation .)
    NOT             reduce using rule 101 (create_puts -> puts_dquotation .)
    PLUS            reduce using rule 101 (create_puts -> puts_dquotation .)
    MINUS           reduce using rule 101 (create_puts -> puts_dquotation .)
    int             reduce using rule 101 (create_puts -> puts_dquotation .)
    float           reduce using rule 101 (create_puts -> puts_dquotation .)
    boolean         reduce using rule 101 (create_puts -> puts_dquotation .)
    AND             reduce using rule 101 (create_puts -> puts_dquotation .)
    $end            reduce using rule 101 (create_puts -> puts_dquotation .)
    DEDENT          reduce using rule 101 (create_puts -> puts_dquotation .)


state 42

    (37) fors -> for . expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end
    (38) fors -> for . expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    ID              shift and go to state 106
    DSING           shift and go to state 69
    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression_variable            shift and go to state 118
    expression                     shift and go to state 119
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 43

    (40) whiles -> do . bloco break if expression end
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 120

state 44

    (81) expression_const_interger -> CONST_INTERGER .

    AND             reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    OR              reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    GT              reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    GE              reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    LT              reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    LE              reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    MINUS           reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    PLUS            reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    ASTERISK        reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    DIVIDE          reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    MODULE          reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    EQUALS          reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    DIFFERENT       reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    if              reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    break           reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    continue        reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    ID              reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    LBRACKET        reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    INDENT          reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    for             reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    while           reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    do              reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    repeat          reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    unless          reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    CONST_REAL      reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    CONST_INTERGER  reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    CONST_STRING    reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    True            reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    False           reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    DSING           reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    LAND            reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    puts            reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    NOT             reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    int             reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    float           reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    boolean         reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    $end            reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    begin           reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    DEDENT          reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    in              reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    then            reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    RBRACKET        reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    COMMA           reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    POINT           reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)
    end             reduce using rule 81 (expression_const_interger -> CONST_INTERGER .)


state 45

    (39) whiles -> while . expression do bloco end
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 121
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 46

    (41) repeats -> repeat . CONST_INTERGER DPOINT bloco end SEMICOLON

    CONST_INTERGER  shift and go to state 122


state 47

    (42) unlesss -> unless . expression then bloco RBRACKET else bloco LBRACKET end
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 123
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 48

    (56) expression_binop -> expression_and .

    AND             reduce using rule 56 (expression_binop -> expression_and .)
    OR              reduce using rule 56 (expression_binop -> expression_and .)
    GT              reduce using rule 56 (expression_binop -> expression_and .)
    GE              reduce using rule 56 (expression_binop -> expression_and .)
    LT              reduce using rule 56 (expression_binop -> expression_and .)
    LE              reduce using rule 56 (expression_binop -> expression_and .)
    MINUS           reduce using rule 56 (expression_binop -> expression_and .)
    PLUS            reduce using rule 56 (expression_binop -> expression_and .)
    ASTERISK        reduce using rule 56 (expression_binop -> expression_and .)
    DIVIDE          reduce using rule 56 (expression_binop -> expression_and .)
    MODULE          reduce using rule 56 (expression_binop -> expression_and .)
    EQUALS          reduce using rule 56 (expression_binop -> expression_and .)
    DIFFERENT       reduce using rule 56 (expression_binop -> expression_and .)
    if              reduce using rule 56 (expression_binop -> expression_and .)
    break           reduce using rule 56 (expression_binop -> expression_and .)
    continue        reduce using rule 56 (expression_binop -> expression_and .)
    ID              reduce using rule 56 (expression_binop -> expression_and .)
    LBRACKET        reduce using rule 56 (expression_binop -> expression_and .)
    INDENT          reduce using rule 56 (expression_binop -> expression_and .)
    for             reduce using rule 56 (expression_binop -> expression_and .)
    while           reduce using rule 56 (expression_binop -> expression_and .)
    do              reduce using rule 56 (expression_binop -> expression_and .)
    repeat          reduce using rule 56 (expression_binop -> expression_and .)
    unless          reduce using rule 56 (expression_binop -> expression_and .)
    CONST_REAL      reduce using rule 56 (expression_binop -> expression_and .)
    CONST_INTERGER  reduce using rule 56 (expression_binop -> expression_and .)
    CONST_STRING    reduce using rule 56 (expression_binop -> expression_and .)
    True            reduce using rule 56 (expression_binop -> expression_and .)
    False           reduce using rule 56 (expression_binop -> expression_and .)
    DSING           reduce using rule 56 (expression_binop -> expression_and .)
    LAND            reduce using rule 56 (expression_binop -> expression_and .)
    puts            reduce using rule 56 (expression_binop -> expression_and .)
    NOT             reduce using rule 56 (expression_binop -> expression_and .)
    int             reduce using rule 56 (expression_binop -> expression_and .)
    float           reduce using rule 56 (expression_binop -> expression_and .)
    boolean         reduce using rule 56 (expression_binop -> expression_and .)
    $end            reduce using rule 56 (expression_binop -> expression_and .)
    begin           reduce using rule 56 (expression_binop -> expression_and .)
    DEDENT          reduce using rule 56 (expression_binop -> expression_and .)
    in              reduce using rule 56 (expression_binop -> expression_and .)
    then            reduce using rule 56 (expression_binop -> expression_and .)
    RBRACKET        reduce using rule 56 (expression_binop -> expression_and .)
    COMMA           reduce using rule 56 (expression_binop -> expression_and .)
    POINT           reduce using rule 56 (expression_binop -> expression_and .)
    end             reduce using rule 56 (expression_binop -> expression_and .)


state 49

    (57) expression_binop -> expression_or .

    AND             reduce using rule 57 (expression_binop -> expression_or .)
    OR              reduce using rule 57 (expression_binop -> expression_or .)
    GT              reduce using rule 57 (expression_binop -> expression_or .)
    GE              reduce using rule 57 (expression_binop -> expression_or .)
    LT              reduce using rule 57 (expression_binop -> expression_or .)
    LE              reduce using rule 57 (expression_binop -> expression_or .)
    MINUS           reduce using rule 57 (expression_binop -> expression_or .)
    PLUS            reduce using rule 57 (expression_binop -> expression_or .)
    ASTERISK        reduce using rule 57 (expression_binop -> expression_or .)
    DIVIDE          reduce using rule 57 (expression_binop -> expression_or .)
    MODULE          reduce using rule 57 (expression_binop -> expression_or .)
    EQUALS          reduce using rule 57 (expression_binop -> expression_or .)
    DIFFERENT       reduce using rule 57 (expression_binop -> expression_or .)
    if              reduce using rule 57 (expression_binop -> expression_or .)
    break           reduce using rule 57 (expression_binop -> expression_or .)
    continue        reduce using rule 57 (expression_binop -> expression_or .)
    ID              reduce using rule 57 (expression_binop -> expression_or .)
    LBRACKET        reduce using rule 57 (expression_binop -> expression_or .)
    INDENT          reduce using rule 57 (expression_binop -> expression_or .)
    for             reduce using rule 57 (expression_binop -> expression_or .)
    while           reduce using rule 57 (expression_binop -> expression_or .)
    do              reduce using rule 57 (expression_binop -> expression_or .)
    repeat          reduce using rule 57 (expression_binop -> expression_or .)
    unless          reduce using rule 57 (expression_binop -> expression_or .)
    CONST_REAL      reduce using rule 57 (expression_binop -> expression_or .)
    CONST_INTERGER  reduce using rule 57 (expression_binop -> expression_or .)
    CONST_STRING    reduce using rule 57 (expression_binop -> expression_or .)
    True            reduce using rule 57 (expression_binop -> expression_or .)
    False           reduce using rule 57 (expression_binop -> expression_or .)
    DSING           reduce using rule 57 (expression_binop -> expression_or .)
    LAND            reduce using rule 57 (expression_binop -> expression_or .)
    puts            reduce using rule 57 (expression_binop -> expression_or .)
    NOT             reduce using rule 57 (expression_binop -> expression_or .)
    int             reduce using rule 57 (expression_binop -> expression_or .)
    float           reduce using rule 57 (expression_binop -> expression_or .)
    boolean         reduce using rule 57 (expression_binop -> expression_or .)
    $end            reduce using rule 57 (expression_binop -> expression_or .)
    begin           reduce using rule 57 (expression_binop -> expression_or .)
    DEDENT          reduce using rule 57 (expression_binop -> expression_or .)
    in              reduce using rule 57 (expression_binop -> expression_or .)
    then            reduce using rule 57 (expression_binop -> expression_or .)
    RBRACKET        reduce using rule 57 (expression_binop -> expression_or .)
    COMMA           reduce using rule 57 (expression_binop -> expression_or .)
    POINT           reduce using rule 57 (expression_binop -> expression_or .)
    end             reduce using rule 57 (expression_binop -> expression_or .)


state 50

    (58) expression_binop -> expression_gt .

    AND             reduce using rule 58 (expression_binop -> expression_gt .)
    OR              reduce using rule 58 (expression_binop -> expression_gt .)
    GT              reduce using rule 58 (expression_binop -> expression_gt .)
    GE              reduce using rule 58 (expression_binop -> expression_gt .)
    LT              reduce using rule 58 (expression_binop -> expression_gt .)
    LE              reduce using rule 58 (expression_binop -> expression_gt .)
    MINUS           reduce using rule 58 (expression_binop -> expression_gt .)
    PLUS            reduce using rule 58 (expression_binop -> expression_gt .)
    ASTERISK        reduce using rule 58 (expression_binop -> expression_gt .)
    DIVIDE          reduce using rule 58 (expression_binop -> expression_gt .)
    MODULE          reduce using rule 58 (expression_binop -> expression_gt .)
    EQUALS          reduce using rule 58 (expression_binop -> expression_gt .)
    DIFFERENT       reduce using rule 58 (expression_binop -> expression_gt .)
    if              reduce using rule 58 (expression_binop -> expression_gt .)
    break           reduce using rule 58 (expression_binop -> expression_gt .)
    continue        reduce using rule 58 (expression_binop -> expression_gt .)
    ID              reduce using rule 58 (expression_binop -> expression_gt .)
    LBRACKET        reduce using rule 58 (expression_binop -> expression_gt .)
    INDENT          reduce using rule 58 (expression_binop -> expression_gt .)
    for             reduce using rule 58 (expression_binop -> expression_gt .)
    while           reduce using rule 58 (expression_binop -> expression_gt .)
    do              reduce using rule 58 (expression_binop -> expression_gt .)
    repeat          reduce using rule 58 (expression_binop -> expression_gt .)
    unless          reduce using rule 58 (expression_binop -> expression_gt .)
    CONST_REAL      reduce using rule 58 (expression_binop -> expression_gt .)
    CONST_INTERGER  reduce using rule 58 (expression_binop -> expression_gt .)
    CONST_STRING    reduce using rule 58 (expression_binop -> expression_gt .)
    True            reduce using rule 58 (expression_binop -> expression_gt .)
    False           reduce using rule 58 (expression_binop -> expression_gt .)
    DSING           reduce using rule 58 (expression_binop -> expression_gt .)
    LAND            reduce using rule 58 (expression_binop -> expression_gt .)
    puts            reduce using rule 58 (expression_binop -> expression_gt .)
    NOT             reduce using rule 58 (expression_binop -> expression_gt .)
    int             reduce using rule 58 (expression_binop -> expression_gt .)
    float           reduce using rule 58 (expression_binop -> expression_gt .)
    boolean         reduce using rule 58 (expression_binop -> expression_gt .)
    $end            reduce using rule 58 (expression_binop -> expression_gt .)
    begin           reduce using rule 58 (expression_binop -> expression_gt .)
    DEDENT          reduce using rule 58 (expression_binop -> expression_gt .)
    in              reduce using rule 58 (expression_binop -> expression_gt .)
    then            reduce using rule 58 (expression_binop -> expression_gt .)
    RBRACKET        reduce using rule 58 (expression_binop -> expression_gt .)
    COMMA           reduce using rule 58 (expression_binop -> expression_gt .)
    POINT           reduce using rule 58 (expression_binop -> expression_gt .)
    end             reduce using rule 58 (expression_binop -> expression_gt .)


state 51

    (59) expression_binop -> expression_ge .

    AND             reduce using rule 59 (expression_binop -> expression_ge .)
    OR              reduce using rule 59 (expression_binop -> expression_ge .)
    GT              reduce using rule 59 (expression_binop -> expression_ge .)
    GE              reduce using rule 59 (expression_binop -> expression_ge .)
    LT              reduce using rule 59 (expression_binop -> expression_ge .)
    LE              reduce using rule 59 (expression_binop -> expression_ge .)
    MINUS           reduce using rule 59 (expression_binop -> expression_ge .)
    PLUS            reduce using rule 59 (expression_binop -> expression_ge .)
    ASTERISK        reduce using rule 59 (expression_binop -> expression_ge .)
    DIVIDE          reduce using rule 59 (expression_binop -> expression_ge .)
    MODULE          reduce using rule 59 (expression_binop -> expression_ge .)
    EQUALS          reduce using rule 59 (expression_binop -> expression_ge .)
    DIFFERENT       reduce using rule 59 (expression_binop -> expression_ge .)
    if              reduce using rule 59 (expression_binop -> expression_ge .)
    break           reduce using rule 59 (expression_binop -> expression_ge .)
    continue        reduce using rule 59 (expression_binop -> expression_ge .)
    ID              reduce using rule 59 (expression_binop -> expression_ge .)
    LBRACKET        reduce using rule 59 (expression_binop -> expression_ge .)
    INDENT          reduce using rule 59 (expression_binop -> expression_ge .)
    for             reduce using rule 59 (expression_binop -> expression_ge .)
    while           reduce using rule 59 (expression_binop -> expression_ge .)
    do              reduce using rule 59 (expression_binop -> expression_ge .)
    repeat          reduce using rule 59 (expression_binop -> expression_ge .)
    unless          reduce using rule 59 (expression_binop -> expression_ge .)
    CONST_REAL      reduce using rule 59 (expression_binop -> expression_ge .)
    CONST_INTERGER  reduce using rule 59 (expression_binop -> expression_ge .)
    CONST_STRING    reduce using rule 59 (expression_binop -> expression_ge .)
    True            reduce using rule 59 (expression_binop -> expression_ge .)
    False           reduce using rule 59 (expression_binop -> expression_ge .)
    DSING           reduce using rule 59 (expression_binop -> expression_ge .)
    LAND            reduce using rule 59 (expression_binop -> expression_ge .)
    puts            reduce using rule 59 (expression_binop -> expression_ge .)
    NOT             reduce using rule 59 (expression_binop -> expression_ge .)
    int             reduce using rule 59 (expression_binop -> expression_ge .)
    float           reduce using rule 59 (expression_binop -> expression_ge .)
    boolean         reduce using rule 59 (expression_binop -> expression_ge .)
    $end            reduce using rule 59 (expression_binop -> expression_ge .)
    begin           reduce using rule 59 (expression_binop -> expression_ge .)
    DEDENT          reduce using rule 59 (expression_binop -> expression_ge .)
    in              reduce using rule 59 (expression_binop -> expression_ge .)
    then            reduce using rule 59 (expression_binop -> expression_ge .)
    RBRACKET        reduce using rule 59 (expression_binop -> expression_ge .)
    COMMA           reduce using rule 59 (expression_binop -> expression_ge .)
    POINT           reduce using rule 59 (expression_binop -> expression_ge .)
    end             reduce using rule 59 (expression_binop -> expression_ge .)


state 52

    (60) expression_binop -> expression_lt .

    AND             reduce using rule 60 (expression_binop -> expression_lt .)
    OR              reduce using rule 60 (expression_binop -> expression_lt .)
    GT              reduce using rule 60 (expression_binop -> expression_lt .)
    GE              reduce using rule 60 (expression_binop -> expression_lt .)
    LT              reduce using rule 60 (expression_binop -> expression_lt .)
    LE              reduce using rule 60 (expression_binop -> expression_lt .)
    MINUS           reduce using rule 60 (expression_binop -> expression_lt .)
    PLUS            reduce using rule 60 (expression_binop -> expression_lt .)
    ASTERISK        reduce using rule 60 (expression_binop -> expression_lt .)
    DIVIDE          reduce using rule 60 (expression_binop -> expression_lt .)
    MODULE          reduce using rule 60 (expression_binop -> expression_lt .)
    EQUALS          reduce using rule 60 (expression_binop -> expression_lt .)
    DIFFERENT       reduce using rule 60 (expression_binop -> expression_lt .)
    if              reduce using rule 60 (expression_binop -> expression_lt .)
    break           reduce using rule 60 (expression_binop -> expression_lt .)
    continue        reduce using rule 60 (expression_binop -> expression_lt .)
    ID              reduce using rule 60 (expression_binop -> expression_lt .)
    LBRACKET        reduce using rule 60 (expression_binop -> expression_lt .)
    INDENT          reduce using rule 60 (expression_binop -> expression_lt .)
    for             reduce using rule 60 (expression_binop -> expression_lt .)
    while           reduce using rule 60 (expression_binop -> expression_lt .)
    do              reduce using rule 60 (expression_binop -> expression_lt .)
    repeat          reduce using rule 60 (expression_binop -> expression_lt .)
    unless          reduce using rule 60 (expression_binop -> expression_lt .)
    CONST_REAL      reduce using rule 60 (expression_binop -> expression_lt .)
    CONST_INTERGER  reduce using rule 60 (expression_binop -> expression_lt .)
    CONST_STRING    reduce using rule 60 (expression_binop -> expression_lt .)
    True            reduce using rule 60 (expression_binop -> expression_lt .)
    False           reduce using rule 60 (expression_binop -> expression_lt .)
    DSING           reduce using rule 60 (expression_binop -> expression_lt .)
    LAND            reduce using rule 60 (expression_binop -> expression_lt .)
    puts            reduce using rule 60 (expression_binop -> expression_lt .)
    NOT             reduce using rule 60 (expression_binop -> expression_lt .)
    int             reduce using rule 60 (expression_binop -> expression_lt .)
    float           reduce using rule 60 (expression_binop -> expression_lt .)
    boolean         reduce using rule 60 (expression_binop -> expression_lt .)
    $end            reduce using rule 60 (expression_binop -> expression_lt .)
    begin           reduce using rule 60 (expression_binop -> expression_lt .)
    DEDENT          reduce using rule 60 (expression_binop -> expression_lt .)
    in              reduce using rule 60 (expression_binop -> expression_lt .)
    then            reduce using rule 60 (expression_binop -> expression_lt .)
    RBRACKET        reduce using rule 60 (expression_binop -> expression_lt .)
    COMMA           reduce using rule 60 (expression_binop -> expression_lt .)
    POINT           reduce using rule 60 (expression_binop -> expression_lt .)
    end             reduce using rule 60 (expression_binop -> expression_lt .)


state 53

    (61) expression_binop -> expression_le .

    AND             reduce using rule 61 (expression_binop -> expression_le .)
    OR              reduce using rule 61 (expression_binop -> expression_le .)
    GT              reduce using rule 61 (expression_binop -> expression_le .)
    GE              reduce using rule 61 (expression_binop -> expression_le .)
    LT              reduce using rule 61 (expression_binop -> expression_le .)
    LE              reduce using rule 61 (expression_binop -> expression_le .)
    MINUS           reduce using rule 61 (expression_binop -> expression_le .)
    PLUS            reduce using rule 61 (expression_binop -> expression_le .)
    ASTERISK        reduce using rule 61 (expression_binop -> expression_le .)
    DIVIDE          reduce using rule 61 (expression_binop -> expression_le .)
    MODULE          reduce using rule 61 (expression_binop -> expression_le .)
    EQUALS          reduce using rule 61 (expression_binop -> expression_le .)
    DIFFERENT       reduce using rule 61 (expression_binop -> expression_le .)
    if              reduce using rule 61 (expression_binop -> expression_le .)
    break           reduce using rule 61 (expression_binop -> expression_le .)
    continue        reduce using rule 61 (expression_binop -> expression_le .)
    ID              reduce using rule 61 (expression_binop -> expression_le .)
    LBRACKET        reduce using rule 61 (expression_binop -> expression_le .)
    INDENT          reduce using rule 61 (expression_binop -> expression_le .)
    for             reduce using rule 61 (expression_binop -> expression_le .)
    while           reduce using rule 61 (expression_binop -> expression_le .)
    do              reduce using rule 61 (expression_binop -> expression_le .)
    repeat          reduce using rule 61 (expression_binop -> expression_le .)
    unless          reduce using rule 61 (expression_binop -> expression_le .)
    CONST_REAL      reduce using rule 61 (expression_binop -> expression_le .)
    CONST_INTERGER  reduce using rule 61 (expression_binop -> expression_le .)
    CONST_STRING    reduce using rule 61 (expression_binop -> expression_le .)
    True            reduce using rule 61 (expression_binop -> expression_le .)
    False           reduce using rule 61 (expression_binop -> expression_le .)
    DSING           reduce using rule 61 (expression_binop -> expression_le .)
    LAND            reduce using rule 61 (expression_binop -> expression_le .)
    puts            reduce using rule 61 (expression_binop -> expression_le .)
    NOT             reduce using rule 61 (expression_binop -> expression_le .)
    int             reduce using rule 61 (expression_binop -> expression_le .)
    float           reduce using rule 61 (expression_binop -> expression_le .)
    boolean         reduce using rule 61 (expression_binop -> expression_le .)
    $end            reduce using rule 61 (expression_binop -> expression_le .)
    begin           reduce using rule 61 (expression_binop -> expression_le .)
    DEDENT          reduce using rule 61 (expression_binop -> expression_le .)
    in              reduce using rule 61 (expression_binop -> expression_le .)
    then            reduce using rule 61 (expression_binop -> expression_le .)
    RBRACKET        reduce using rule 61 (expression_binop -> expression_le .)
    COMMA           reduce using rule 61 (expression_binop -> expression_le .)
    POINT           reduce using rule 61 (expression_binop -> expression_le .)
    end             reduce using rule 61 (expression_binop -> expression_le .)


state 54

    (62) expression_binop -> expression_minus .

    AND             reduce using rule 62 (expression_binop -> expression_minus .)
    OR              reduce using rule 62 (expression_binop -> expression_minus .)
    GT              reduce using rule 62 (expression_binop -> expression_minus .)
    GE              reduce using rule 62 (expression_binop -> expression_minus .)
    LT              reduce using rule 62 (expression_binop -> expression_minus .)
    LE              reduce using rule 62 (expression_binop -> expression_minus .)
    MINUS           reduce using rule 62 (expression_binop -> expression_minus .)
    PLUS            reduce using rule 62 (expression_binop -> expression_minus .)
    ASTERISK        reduce using rule 62 (expression_binop -> expression_minus .)
    DIVIDE          reduce using rule 62 (expression_binop -> expression_minus .)
    MODULE          reduce using rule 62 (expression_binop -> expression_minus .)
    EQUALS          reduce using rule 62 (expression_binop -> expression_minus .)
    DIFFERENT       reduce using rule 62 (expression_binop -> expression_minus .)
    if              reduce using rule 62 (expression_binop -> expression_minus .)
    break           reduce using rule 62 (expression_binop -> expression_minus .)
    continue        reduce using rule 62 (expression_binop -> expression_minus .)
    ID              reduce using rule 62 (expression_binop -> expression_minus .)
    LBRACKET        reduce using rule 62 (expression_binop -> expression_minus .)
    INDENT          reduce using rule 62 (expression_binop -> expression_minus .)
    for             reduce using rule 62 (expression_binop -> expression_minus .)
    while           reduce using rule 62 (expression_binop -> expression_minus .)
    do              reduce using rule 62 (expression_binop -> expression_minus .)
    repeat          reduce using rule 62 (expression_binop -> expression_minus .)
    unless          reduce using rule 62 (expression_binop -> expression_minus .)
    CONST_REAL      reduce using rule 62 (expression_binop -> expression_minus .)
    CONST_INTERGER  reduce using rule 62 (expression_binop -> expression_minus .)
    CONST_STRING    reduce using rule 62 (expression_binop -> expression_minus .)
    True            reduce using rule 62 (expression_binop -> expression_minus .)
    False           reduce using rule 62 (expression_binop -> expression_minus .)
    DSING           reduce using rule 62 (expression_binop -> expression_minus .)
    LAND            reduce using rule 62 (expression_binop -> expression_minus .)
    puts            reduce using rule 62 (expression_binop -> expression_minus .)
    NOT             reduce using rule 62 (expression_binop -> expression_minus .)
    int             reduce using rule 62 (expression_binop -> expression_minus .)
    float           reduce using rule 62 (expression_binop -> expression_minus .)
    boolean         reduce using rule 62 (expression_binop -> expression_minus .)
    $end            reduce using rule 62 (expression_binop -> expression_minus .)
    begin           reduce using rule 62 (expression_binop -> expression_minus .)
    DEDENT          reduce using rule 62 (expression_binop -> expression_minus .)
    in              reduce using rule 62 (expression_binop -> expression_minus .)
    then            reduce using rule 62 (expression_binop -> expression_minus .)
    RBRACKET        reduce using rule 62 (expression_binop -> expression_minus .)
    COMMA           reduce using rule 62 (expression_binop -> expression_minus .)
    POINT           reduce using rule 62 (expression_binop -> expression_minus .)
    end             reduce using rule 62 (expression_binop -> expression_minus .)


state 55

    (63) expression_binop -> expression_plus .

    AND             reduce using rule 63 (expression_binop -> expression_plus .)
    OR              reduce using rule 63 (expression_binop -> expression_plus .)
    GT              reduce using rule 63 (expression_binop -> expression_plus .)
    GE              reduce using rule 63 (expression_binop -> expression_plus .)
    LT              reduce using rule 63 (expression_binop -> expression_plus .)
    LE              reduce using rule 63 (expression_binop -> expression_plus .)
    MINUS           reduce using rule 63 (expression_binop -> expression_plus .)
    PLUS            reduce using rule 63 (expression_binop -> expression_plus .)
    ASTERISK        reduce using rule 63 (expression_binop -> expression_plus .)
    DIVIDE          reduce using rule 63 (expression_binop -> expression_plus .)
    MODULE          reduce using rule 63 (expression_binop -> expression_plus .)
    EQUALS          reduce using rule 63 (expression_binop -> expression_plus .)
    DIFFERENT       reduce using rule 63 (expression_binop -> expression_plus .)
    if              reduce using rule 63 (expression_binop -> expression_plus .)
    break           reduce using rule 63 (expression_binop -> expression_plus .)
    continue        reduce using rule 63 (expression_binop -> expression_plus .)
    ID              reduce using rule 63 (expression_binop -> expression_plus .)
    LBRACKET        reduce using rule 63 (expression_binop -> expression_plus .)
    INDENT          reduce using rule 63 (expression_binop -> expression_plus .)
    for             reduce using rule 63 (expression_binop -> expression_plus .)
    while           reduce using rule 63 (expression_binop -> expression_plus .)
    do              reduce using rule 63 (expression_binop -> expression_plus .)
    repeat          reduce using rule 63 (expression_binop -> expression_plus .)
    unless          reduce using rule 63 (expression_binop -> expression_plus .)
    CONST_REAL      reduce using rule 63 (expression_binop -> expression_plus .)
    CONST_INTERGER  reduce using rule 63 (expression_binop -> expression_plus .)
    CONST_STRING    reduce using rule 63 (expression_binop -> expression_plus .)
    True            reduce using rule 63 (expression_binop -> expression_plus .)
    False           reduce using rule 63 (expression_binop -> expression_plus .)
    DSING           reduce using rule 63 (expression_binop -> expression_plus .)
    LAND            reduce using rule 63 (expression_binop -> expression_plus .)
    puts            reduce using rule 63 (expression_binop -> expression_plus .)
    NOT             reduce using rule 63 (expression_binop -> expression_plus .)
    int             reduce using rule 63 (expression_binop -> expression_plus .)
    float           reduce using rule 63 (expression_binop -> expression_plus .)
    boolean         reduce using rule 63 (expression_binop -> expression_plus .)
    $end            reduce using rule 63 (expression_binop -> expression_plus .)
    begin           reduce using rule 63 (expression_binop -> expression_plus .)
    DEDENT          reduce using rule 63 (expression_binop -> expression_plus .)
    in              reduce using rule 63 (expression_binop -> expression_plus .)
    then            reduce using rule 63 (expression_binop -> expression_plus .)
    RBRACKET        reduce using rule 63 (expression_binop -> expression_plus .)
    COMMA           reduce using rule 63 (expression_binop -> expression_plus .)
    POINT           reduce using rule 63 (expression_binop -> expression_plus .)
    end             reduce using rule 63 (expression_binop -> expression_plus .)


state 56

    (64) expression_binop -> expression_mult .

    AND             reduce using rule 64 (expression_binop -> expression_mult .)
    OR              reduce using rule 64 (expression_binop -> expression_mult .)
    GT              reduce using rule 64 (expression_binop -> expression_mult .)
    GE              reduce using rule 64 (expression_binop -> expression_mult .)
    LT              reduce using rule 64 (expression_binop -> expression_mult .)
    LE              reduce using rule 64 (expression_binop -> expression_mult .)
    MINUS           reduce using rule 64 (expression_binop -> expression_mult .)
    PLUS            reduce using rule 64 (expression_binop -> expression_mult .)
    ASTERISK        reduce using rule 64 (expression_binop -> expression_mult .)
    DIVIDE          reduce using rule 64 (expression_binop -> expression_mult .)
    MODULE          reduce using rule 64 (expression_binop -> expression_mult .)
    EQUALS          reduce using rule 64 (expression_binop -> expression_mult .)
    DIFFERENT       reduce using rule 64 (expression_binop -> expression_mult .)
    if              reduce using rule 64 (expression_binop -> expression_mult .)
    break           reduce using rule 64 (expression_binop -> expression_mult .)
    continue        reduce using rule 64 (expression_binop -> expression_mult .)
    ID              reduce using rule 64 (expression_binop -> expression_mult .)
    LBRACKET        reduce using rule 64 (expression_binop -> expression_mult .)
    INDENT          reduce using rule 64 (expression_binop -> expression_mult .)
    for             reduce using rule 64 (expression_binop -> expression_mult .)
    while           reduce using rule 64 (expression_binop -> expression_mult .)
    do              reduce using rule 64 (expression_binop -> expression_mult .)
    repeat          reduce using rule 64 (expression_binop -> expression_mult .)
    unless          reduce using rule 64 (expression_binop -> expression_mult .)
    CONST_REAL      reduce using rule 64 (expression_binop -> expression_mult .)
    CONST_INTERGER  reduce using rule 64 (expression_binop -> expression_mult .)
    CONST_STRING    reduce using rule 64 (expression_binop -> expression_mult .)
    True            reduce using rule 64 (expression_binop -> expression_mult .)
    False           reduce using rule 64 (expression_binop -> expression_mult .)
    DSING           reduce using rule 64 (expression_binop -> expression_mult .)
    LAND            reduce using rule 64 (expression_binop -> expression_mult .)
    puts            reduce using rule 64 (expression_binop -> expression_mult .)
    NOT             reduce using rule 64 (expression_binop -> expression_mult .)
    int             reduce using rule 64 (expression_binop -> expression_mult .)
    float           reduce using rule 64 (expression_binop -> expression_mult .)
    boolean         reduce using rule 64 (expression_binop -> expression_mult .)
    $end            reduce using rule 64 (expression_binop -> expression_mult .)
    begin           reduce using rule 64 (expression_binop -> expression_mult .)
    DEDENT          reduce using rule 64 (expression_binop -> expression_mult .)
    in              reduce using rule 64 (expression_binop -> expression_mult .)
    then            reduce using rule 64 (expression_binop -> expression_mult .)
    RBRACKET        reduce using rule 64 (expression_binop -> expression_mult .)
    COMMA           reduce using rule 64 (expression_binop -> expression_mult .)
    POINT           reduce using rule 64 (expression_binop -> expression_mult .)
    end             reduce using rule 64 (expression_binop -> expression_mult .)


state 57

    (65) expression_binop -> expression_divide .

    AND             reduce using rule 65 (expression_binop -> expression_divide .)
    OR              reduce using rule 65 (expression_binop -> expression_divide .)
    GT              reduce using rule 65 (expression_binop -> expression_divide .)
    GE              reduce using rule 65 (expression_binop -> expression_divide .)
    LT              reduce using rule 65 (expression_binop -> expression_divide .)
    LE              reduce using rule 65 (expression_binop -> expression_divide .)
    MINUS           reduce using rule 65 (expression_binop -> expression_divide .)
    PLUS            reduce using rule 65 (expression_binop -> expression_divide .)
    ASTERISK        reduce using rule 65 (expression_binop -> expression_divide .)
    DIVIDE          reduce using rule 65 (expression_binop -> expression_divide .)
    MODULE          reduce using rule 65 (expression_binop -> expression_divide .)
    EQUALS          reduce using rule 65 (expression_binop -> expression_divide .)
    DIFFERENT       reduce using rule 65 (expression_binop -> expression_divide .)
    if              reduce using rule 65 (expression_binop -> expression_divide .)
    break           reduce using rule 65 (expression_binop -> expression_divide .)
    continue        reduce using rule 65 (expression_binop -> expression_divide .)
    ID              reduce using rule 65 (expression_binop -> expression_divide .)
    LBRACKET        reduce using rule 65 (expression_binop -> expression_divide .)
    INDENT          reduce using rule 65 (expression_binop -> expression_divide .)
    for             reduce using rule 65 (expression_binop -> expression_divide .)
    while           reduce using rule 65 (expression_binop -> expression_divide .)
    do              reduce using rule 65 (expression_binop -> expression_divide .)
    repeat          reduce using rule 65 (expression_binop -> expression_divide .)
    unless          reduce using rule 65 (expression_binop -> expression_divide .)
    CONST_REAL      reduce using rule 65 (expression_binop -> expression_divide .)
    CONST_INTERGER  reduce using rule 65 (expression_binop -> expression_divide .)
    CONST_STRING    reduce using rule 65 (expression_binop -> expression_divide .)
    True            reduce using rule 65 (expression_binop -> expression_divide .)
    False           reduce using rule 65 (expression_binop -> expression_divide .)
    DSING           reduce using rule 65 (expression_binop -> expression_divide .)
    LAND            reduce using rule 65 (expression_binop -> expression_divide .)
    puts            reduce using rule 65 (expression_binop -> expression_divide .)
    NOT             reduce using rule 65 (expression_binop -> expression_divide .)
    int             reduce using rule 65 (expression_binop -> expression_divide .)
    float           reduce using rule 65 (expression_binop -> expression_divide .)
    boolean         reduce using rule 65 (expression_binop -> expression_divide .)
    $end            reduce using rule 65 (expression_binop -> expression_divide .)
    begin           reduce using rule 65 (expression_binop -> expression_divide .)
    DEDENT          reduce using rule 65 (expression_binop -> expression_divide .)
    in              reduce using rule 65 (expression_binop -> expression_divide .)
    then            reduce using rule 65 (expression_binop -> expression_divide .)
    RBRACKET        reduce using rule 65 (expression_binop -> expression_divide .)
    COMMA           reduce using rule 65 (expression_binop -> expression_divide .)
    POINT           reduce using rule 65 (expression_binop -> expression_divide .)
    end             reduce using rule 65 (expression_binop -> expression_divide .)


state 58

    (66) expression_binop -> expression_module .

    AND             reduce using rule 66 (expression_binop -> expression_module .)
    OR              reduce using rule 66 (expression_binop -> expression_module .)
    GT              reduce using rule 66 (expression_binop -> expression_module .)
    GE              reduce using rule 66 (expression_binop -> expression_module .)
    LT              reduce using rule 66 (expression_binop -> expression_module .)
    LE              reduce using rule 66 (expression_binop -> expression_module .)
    MINUS           reduce using rule 66 (expression_binop -> expression_module .)
    PLUS            reduce using rule 66 (expression_binop -> expression_module .)
    ASTERISK        reduce using rule 66 (expression_binop -> expression_module .)
    DIVIDE          reduce using rule 66 (expression_binop -> expression_module .)
    MODULE          reduce using rule 66 (expression_binop -> expression_module .)
    EQUALS          reduce using rule 66 (expression_binop -> expression_module .)
    DIFFERENT       reduce using rule 66 (expression_binop -> expression_module .)
    if              reduce using rule 66 (expression_binop -> expression_module .)
    break           reduce using rule 66 (expression_binop -> expression_module .)
    continue        reduce using rule 66 (expression_binop -> expression_module .)
    ID              reduce using rule 66 (expression_binop -> expression_module .)
    LBRACKET        reduce using rule 66 (expression_binop -> expression_module .)
    INDENT          reduce using rule 66 (expression_binop -> expression_module .)
    for             reduce using rule 66 (expression_binop -> expression_module .)
    while           reduce using rule 66 (expression_binop -> expression_module .)
    do              reduce using rule 66 (expression_binop -> expression_module .)
    repeat          reduce using rule 66 (expression_binop -> expression_module .)
    unless          reduce using rule 66 (expression_binop -> expression_module .)
    CONST_REAL      reduce using rule 66 (expression_binop -> expression_module .)
    CONST_INTERGER  reduce using rule 66 (expression_binop -> expression_module .)
    CONST_STRING    reduce using rule 66 (expression_binop -> expression_module .)
    True            reduce using rule 66 (expression_binop -> expression_module .)
    False           reduce using rule 66 (expression_binop -> expression_module .)
    DSING           reduce using rule 66 (expression_binop -> expression_module .)
    LAND            reduce using rule 66 (expression_binop -> expression_module .)
    puts            reduce using rule 66 (expression_binop -> expression_module .)
    NOT             reduce using rule 66 (expression_binop -> expression_module .)
    int             reduce using rule 66 (expression_binop -> expression_module .)
    float           reduce using rule 66 (expression_binop -> expression_module .)
    boolean         reduce using rule 66 (expression_binop -> expression_module .)
    $end            reduce using rule 66 (expression_binop -> expression_module .)
    begin           reduce using rule 66 (expression_binop -> expression_module .)
    DEDENT          reduce using rule 66 (expression_binop -> expression_module .)
    in              reduce using rule 66 (expression_binop -> expression_module .)
    then            reduce using rule 66 (expression_binop -> expression_module .)
    RBRACKET        reduce using rule 66 (expression_binop -> expression_module .)
    COMMA           reduce using rule 66 (expression_binop -> expression_module .)
    POINT           reduce using rule 66 (expression_binop -> expression_module .)
    end             reduce using rule 66 (expression_binop -> expression_module .)


state 59

    (67) expression_binop -> expression_equals .

    AND             reduce using rule 67 (expression_binop -> expression_equals .)
    OR              reduce using rule 67 (expression_binop -> expression_equals .)
    GT              reduce using rule 67 (expression_binop -> expression_equals .)
    GE              reduce using rule 67 (expression_binop -> expression_equals .)
    LT              reduce using rule 67 (expression_binop -> expression_equals .)
    LE              reduce using rule 67 (expression_binop -> expression_equals .)
    MINUS           reduce using rule 67 (expression_binop -> expression_equals .)
    PLUS            reduce using rule 67 (expression_binop -> expression_equals .)
    ASTERISK        reduce using rule 67 (expression_binop -> expression_equals .)
    DIVIDE          reduce using rule 67 (expression_binop -> expression_equals .)
    MODULE          reduce using rule 67 (expression_binop -> expression_equals .)
    EQUALS          reduce using rule 67 (expression_binop -> expression_equals .)
    DIFFERENT       reduce using rule 67 (expression_binop -> expression_equals .)
    if              reduce using rule 67 (expression_binop -> expression_equals .)
    break           reduce using rule 67 (expression_binop -> expression_equals .)
    continue        reduce using rule 67 (expression_binop -> expression_equals .)
    ID              reduce using rule 67 (expression_binop -> expression_equals .)
    LBRACKET        reduce using rule 67 (expression_binop -> expression_equals .)
    INDENT          reduce using rule 67 (expression_binop -> expression_equals .)
    for             reduce using rule 67 (expression_binop -> expression_equals .)
    while           reduce using rule 67 (expression_binop -> expression_equals .)
    do              reduce using rule 67 (expression_binop -> expression_equals .)
    repeat          reduce using rule 67 (expression_binop -> expression_equals .)
    unless          reduce using rule 67 (expression_binop -> expression_equals .)
    CONST_REAL      reduce using rule 67 (expression_binop -> expression_equals .)
    CONST_INTERGER  reduce using rule 67 (expression_binop -> expression_equals .)
    CONST_STRING    reduce using rule 67 (expression_binop -> expression_equals .)
    True            reduce using rule 67 (expression_binop -> expression_equals .)
    False           reduce using rule 67 (expression_binop -> expression_equals .)
    DSING           reduce using rule 67 (expression_binop -> expression_equals .)
    LAND            reduce using rule 67 (expression_binop -> expression_equals .)
    puts            reduce using rule 67 (expression_binop -> expression_equals .)
    NOT             reduce using rule 67 (expression_binop -> expression_equals .)
    int             reduce using rule 67 (expression_binop -> expression_equals .)
    float           reduce using rule 67 (expression_binop -> expression_equals .)
    boolean         reduce using rule 67 (expression_binop -> expression_equals .)
    $end            reduce using rule 67 (expression_binop -> expression_equals .)
    begin           reduce using rule 67 (expression_binop -> expression_equals .)
    DEDENT          reduce using rule 67 (expression_binop -> expression_equals .)
    in              reduce using rule 67 (expression_binop -> expression_equals .)
    then            reduce using rule 67 (expression_binop -> expression_equals .)
    RBRACKET        reduce using rule 67 (expression_binop -> expression_equals .)
    COMMA           reduce using rule 67 (expression_binop -> expression_equals .)
    POINT           reduce using rule 67 (expression_binop -> expression_equals .)
    end             reduce using rule 67 (expression_binop -> expression_equals .)


state 60

    (68) expression_binop -> expression_different .

    AND             reduce using rule 68 (expression_binop -> expression_different .)
    OR              reduce using rule 68 (expression_binop -> expression_different .)
    GT              reduce using rule 68 (expression_binop -> expression_different .)
    GE              reduce using rule 68 (expression_binop -> expression_different .)
    LT              reduce using rule 68 (expression_binop -> expression_different .)
    LE              reduce using rule 68 (expression_binop -> expression_different .)
    MINUS           reduce using rule 68 (expression_binop -> expression_different .)
    PLUS            reduce using rule 68 (expression_binop -> expression_different .)
    ASTERISK        reduce using rule 68 (expression_binop -> expression_different .)
    DIVIDE          reduce using rule 68 (expression_binop -> expression_different .)
    MODULE          reduce using rule 68 (expression_binop -> expression_different .)
    EQUALS          reduce using rule 68 (expression_binop -> expression_different .)
    DIFFERENT       reduce using rule 68 (expression_binop -> expression_different .)
    if              reduce using rule 68 (expression_binop -> expression_different .)
    break           reduce using rule 68 (expression_binop -> expression_different .)
    continue        reduce using rule 68 (expression_binop -> expression_different .)
    ID              reduce using rule 68 (expression_binop -> expression_different .)
    LBRACKET        reduce using rule 68 (expression_binop -> expression_different .)
    INDENT          reduce using rule 68 (expression_binop -> expression_different .)
    for             reduce using rule 68 (expression_binop -> expression_different .)
    while           reduce using rule 68 (expression_binop -> expression_different .)
    do              reduce using rule 68 (expression_binop -> expression_different .)
    repeat          reduce using rule 68 (expression_binop -> expression_different .)
    unless          reduce using rule 68 (expression_binop -> expression_different .)
    CONST_REAL      reduce using rule 68 (expression_binop -> expression_different .)
    CONST_INTERGER  reduce using rule 68 (expression_binop -> expression_different .)
    CONST_STRING    reduce using rule 68 (expression_binop -> expression_different .)
    True            reduce using rule 68 (expression_binop -> expression_different .)
    False           reduce using rule 68 (expression_binop -> expression_different .)
    DSING           reduce using rule 68 (expression_binop -> expression_different .)
    LAND            reduce using rule 68 (expression_binop -> expression_different .)
    puts            reduce using rule 68 (expression_binop -> expression_different .)
    NOT             reduce using rule 68 (expression_binop -> expression_different .)
    int             reduce using rule 68 (expression_binop -> expression_different .)
    float           reduce using rule 68 (expression_binop -> expression_different .)
    boolean         reduce using rule 68 (expression_binop -> expression_different .)
    $end            reduce using rule 68 (expression_binop -> expression_different .)
    begin           reduce using rule 68 (expression_binop -> expression_different .)
    DEDENT          reduce using rule 68 (expression_binop -> expression_different .)
    in              reduce using rule 68 (expression_binop -> expression_different .)
    then            reduce using rule 68 (expression_binop -> expression_different .)
    RBRACKET        reduce using rule 68 (expression_binop -> expression_different .)
    COMMA           reduce using rule 68 (expression_binop -> expression_different .)
    POINT           reduce using rule 68 (expression_binop -> expression_different .)
    end             reduce using rule 68 (expression_binop -> expression_different .)


state 61

    (52) expression_unitary -> unitary_not .

    AND             reduce using rule 52 (expression_unitary -> unitary_not .)
    OR              reduce using rule 52 (expression_unitary -> unitary_not .)
    GT              reduce using rule 52 (expression_unitary -> unitary_not .)
    GE              reduce using rule 52 (expression_unitary -> unitary_not .)
    LT              reduce using rule 52 (expression_unitary -> unitary_not .)
    LE              reduce using rule 52 (expression_unitary -> unitary_not .)
    MINUS           reduce using rule 52 (expression_unitary -> unitary_not .)
    PLUS            reduce using rule 52 (expression_unitary -> unitary_not .)
    ASTERISK        reduce using rule 52 (expression_unitary -> unitary_not .)
    DIVIDE          reduce using rule 52 (expression_unitary -> unitary_not .)
    MODULE          reduce using rule 52 (expression_unitary -> unitary_not .)
    EQUALS          reduce using rule 52 (expression_unitary -> unitary_not .)
    DIFFERENT       reduce using rule 52 (expression_unitary -> unitary_not .)
    if              reduce using rule 52 (expression_unitary -> unitary_not .)
    break           reduce using rule 52 (expression_unitary -> unitary_not .)
    continue        reduce using rule 52 (expression_unitary -> unitary_not .)
    ID              reduce using rule 52 (expression_unitary -> unitary_not .)
    LBRACKET        reduce using rule 52 (expression_unitary -> unitary_not .)
    INDENT          reduce using rule 52 (expression_unitary -> unitary_not .)
    for             reduce using rule 52 (expression_unitary -> unitary_not .)
    while           reduce using rule 52 (expression_unitary -> unitary_not .)
    do              reduce using rule 52 (expression_unitary -> unitary_not .)
    repeat          reduce using rule 52 (expression_unitary -> unitary_not .)
    unless          reduce using rule 52 (expression_unitary -> unitary_not .)
    CONST_REAL      reduce using rule 52 (expression_unitary -> unitary_not .)
    CONST_INTERGER  reduce using rule 52 (expression_unitary -> unitary_not .)
    CONST_STRING    reduce using rule 52 (expression_unitary -> unitary_not .)
    True            reduce using rule 52 (expression_unitary -> unitary_not .)
    False           reduce using rule 52 (expression_unitary -> unitary_not .)
    DSING           reduce using rule 52 (expression_unitary -> unitary_not .)
    LAND            reduce using rule 52 (expression_unitary -> unitary_not .)
    puts            reduce using rule 52 (expression_unitary -> unitary_not .)
    NOT             reduce using rule 52 (expression_unitary -> unitary_not .)
    int             reduce using rule 52 (expression_unitary -> unitary_not .)
    float           reduce using rule 52 (expression_unitary -> unitary_not .)
    boolean         reduce using rule 52 (expression_unitary -> unitary_not .)
    $end            reduce using rule 52 (expression_unitary -> unitary_not .)
    begin           reduce using rule 52 (expression_unitary -> unitary_not .)
    DEDENT          reduce using rule 52 (expression_unitary -> unitary_not .)
    in              reduce using rule 52 (expression_unitary -> unitary_not .)
    then            reduce using rule 52 (expression_unitary -> unitary_not .)
    RBRACKET        reduce using rule 52 (expression_unitary -> unitary_not .)
    COMMA           reduce using rule 52 (expression_unitary -> unitary_not .)
    POINT           reduce using rule 52 (expression_unitary -> unitary_not .)
    end             reduce using rule 52 (expression_unitary -> unitary_not .)


state 62

    (53) expression_unitary -> unitary_asterisk .

    AND             reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    OR              reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    GT              reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    GE              reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    LT              reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    LE              reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    MINUS           reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    PLUS            reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    ASTERISK        reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    DIVIDE          reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    MODULE          reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    EQUALS          reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    DIFFERENT       reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    if              reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    break           reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    continue        reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    ID              reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    LBRACKET        reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    INDENT          reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    for             reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    while           reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    do              reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    repeat          reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    unless          reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    CONST_REAL      reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    CONST_INTERGER  reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    CONST_STRING    reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    True            reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    False           reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    DSING           reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    LAND            reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    puts            reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    NOT             reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    int             reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    float           reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    boolean         reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    $end            reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    begin           reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    DEDENT          reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    in              reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    then            reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    RBRACKET        reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    COMMA           reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    POINT           reduce using rule 53 (expression_unitary -> unitary_asterisk .)
    end             reduce using rule 53 (expression_unitary -> unitary_asterisk .)


state 63

    (54) expression_unitary -> unitary_plus .

    AND             reduce using rule 54 (expression_unitary -> unitary_plus .)
    OR              reduce using rule 54 (expression_unitary -> unitary_plus .)
    GT              reduce using rule 54 (expression_unitary -> unitary_plus .)
    GE              reduce using rule 54 (expression_unitary -> unitary_plus .)
    LT              reduce using rule 54 (expression_unitary -> unitary_plus .)
    LE              reduce using rule 54 (expression_unitary -> unitary_plus .)
    MINUS           reduce using rule 54 (expression_unitary -> unitary_plus .)
    PLUS            reduce using rule 54 (expression_unitary -> unitary_plus .)
    ASTERISK        reduce using rule 54 (expression_unitary -> unitary_plus .)
    DIVIDE          reduce using rule 54 (expression_unitary -> unitary_plus .)
    MODULE          reduce using rule 54 (expression_unitary -> unitary_plus .)
    EQUALS          reduce using rule 54 (expression_unitary -> unitary_plus .)
    DIFFERENT       reduce using rule 54 (expression_unitary -> unitary_plus .)
    if              reduce using rule 54 (expression_unitary -> unitary_plus .)
    break           reduce using rule 54 (expression_unitary -> unitary_plus .)
    continue        reduce using rule 54 (expression_unitary -> unitary_plus .)
    ID              reduce using rule 54 (expression_unitary -> unitary_plus .)
    LBRACKET        reduce using rule 54 (expression_unitary -> unitary_plus .)
    INDENT          reduce using rule 54 (expression_unitary -> unitary_plus .)
    for             reduce using rule 54 (expression_unitary -> unitary_plus .)
    while           reduce using rule 54 (expression_unitary -> unitary_plus .)
    do              reduce using rule 54 (expression_unitary -> unitary_plus .)
    repeat          reduce using rule 54 (expression_unitary -> unitary_plus .)
    unless          reduce using rule 54 (expression_unitary -> unitary_plus .)
    CONST_REAL      reduce using rule 54 (expression_unitary -> unitary_plus .)
    CONST_INTERGER  reduce using rule 54 (expression_unitary -> unitary_plus .)
    CONST_STRING    reduce using rule 54 (expression_unitary -> unitary_plus .)
    True            reduce using rule 54 (expression_unitary -> unitary_plus .)
    False           reduce using rule 54 (expression_unitary -> unitary_plus .)
    DSING           reduce using rule 54 (expression_unitary -> unitary_plus .)
    LAND            reduce using rule 54 (expression_unitary -> unitary_plus .)
    puts            reduce using rule 54 (expression_unitary -> unitary_plus .)
    NOT             reduce using rule 54 (expression_unitary -> unitary_plus .)
    int             reduce using rule 54 (expression_unitary -> unitary_plus .)
    float           reduce using rule 54 (expression_unitary -> unitary_plus .)
    boolean         reduce using rule 54 (expression_unitary -> unitary_plus .)
    $end            reduce using rule 54 (expression_unitary -> unitary_plus .)
    begin           reduce using rule 54 (expression_unitary -> unitary_plus .)
    DEDENT          reduce using rule 54 (expression_unitary -> unitary_plus .)
    in              reduce using rule 54 (expression_unitary -> unitary_plus .)
    then            reduce using rule 54 (expression_unitary -> unitary_plus .)
    RBRACKET        reduce using rule 54 (expression_unitary -> unitary_plus .)
    COMMA           reduce using rule 54 (expression_unitary -> unitary_plus .)
    POINT           reduce using rule 54 (expression_unitary -> unitary_plus .)
    end             reduce using rule 54 (expression_unitary -> unitary_plus .)


state 64

    (55) expression_unitary -> unitary_minus .

    AND             reduce using rule 55 (expression_unitary -> unitary_minus .)
    OR              reduce using rule 55 (expression_unitary -> unitary_minus .)
    GT              reduce using rule 55 (expression_unitary -> unitary_minus .)
    GE              reduce using rule 55 (expression_unitary -> unitary_minus .)
    LT              reduce using rule 55 (expression_unitary -> unitary_minus .)
    LE              reduce using rule 55 (expression_unitary -> unitary_minus .)
    MINUS           reduce using rule 55 (expression_unitary -> unitary_minus .)
    PLUS            reduce using rule 55 (expression_unitary -> unitary_minus .)
    ASTERISK        reduce using rule 55 (expression_unitary -> unitary_minus .)
    DIVIDE          reduce using rule 55 (expression_unitary -> unitary_minus .)
    MODULE          reduce using rule 55 (expression_unitary -> unitary_minus .)
    EQUALS          reduce using rule 55 (expression_unitary -> unitary_minus .)
    DIFFERENT       reduce using rule 55 (expression_unitary -> unitary_minus .)
    if              reduce using rule 55 (expression_unitary -> unitary_minus .)
    break           reduce using rule 55 (expression_unitary -> unitary_minus .)
    continue        reduce using rule 55 (expression_unitary -> unitary_minus .)
    ID              reduce using rule 55 (expression_unitary -> unitary_minus .)
    LBRACKET        reduce using rule 55 (expression_unitary -> unitary_minus .)
    INDENT          reduce using rule 55 (expression_unitary -> unitary_minus .)
    for             reduce using rule 55 (expression_unitary -> unitary_minus .)
    while           reduce using rule 55 (expression_unitary -> unitary_minus .)
    do              reduce using rule 55 (expression_unitary -> unitary_minus .)
    repeat          reduce using rule 55 (expression_unitary -> unitary_minus .)
    unless          reduce using rule 55 (expression_unitary -> unitary_minus .)
    CONST_REAL      reduce using rule 55 (expression_unitary -> unitary_minus .)
    CONST_INTERGER  reduce using rule 55 (expression_unitary -> unitary_minus .)
    CONST_STRING    reduce using rule 55 (expression_unitary -> unitary_minus .)
    True            reduce using rule 55 (expression_unitary -> unitary_minus .)
    False           reduce using rule 55 (expression_unitary -> unitary_minus .)
    DSING           reduce using rule 55 (expression_unitary -> unitary_minus .)
    LAND            reduce using rule 55 (expression_unitary -> unitary_minus .)
    puts            reduce using rule 55 (expression_unitary -> unitary_minus .)
    NOT             reduce using rule 55 (expression_unitary -> unitary_minus .)
    int             reduce using rule 55 (expression_unitary -> unitary_minus .)
    float           reduce using rule 55 (expression_unitary -> unitary_minus .)
    boolean         reduce using rule 55 (expression_unitary -> unitary_minus .)
    $end            reduce using rule 55 (expression_unitary -> unitary_minus .)
    begin           reduce using rule 55 (expression_unitary -> unitary_minus .)
    DEDENT          reduce using rule 55 (expression_unitary -> unitary_minus .)
    in              reduce using rule 55 (expression_unitary -> unitary_minus .)
    then            reduce using rule 55 (expression_unitary -> unitary_minus .)
    RBRACKET        reduce using rule 55 (expression_unitary -> unitary_minus .)
    COMMA           reduce using rule 55 (expression_unitary -> unitary_minus .)
    POINT           reduce using rule 55 (expression_unitary -> unitary_minus .)
    end             reduce using rule 55 (expression_unitary -> unitary_minus .)


state 65

    (80) expression_const_real -> CONST_REAL .

    AND             reduce using rule 80 (expression_const_real -> CONST_REAL .)
    OR              reduce using rule 80 (expression_const_real -> CONST_REAL .)
    GT              reduce using rule 80 (expression_const_real -> CONST_REAL .)
    GE              reduce using rule 80 (expression_const_real -> CONST_REAL .)
    LT              reduce using rule 80 (expression_const_real -> CONST_REAL .)
    LE              reduce using rule 80 (expression_const_real -> CONST_REAL .)
    MINUS           reduce using rule 80 (expression_const_real -> CONST_REAL .)
    PLUS            reduce using rule 80 (expression_const_real -> CONST_REAL .)
    ASTERISK        reduce using rule 80 (expression_const_real -> CONST_REAL .)
    DIVIDE          reduce using rule 80 (expression_const_real -> CONST_REAL .)
    MODULE          reduce using rule 80 (expression_const_real -> CONST_REAL .)
    EQUALS          reduce using rule 80 (expression_const_real -> CONST_REAL .)
    DIFFERENT       reduce using rule 80 (expression_const_real -> CONST_REAL .)
    if              reduce using rule 80 (expression_const_real -> CONST_REAL .)
    break           reduce using rule 80 (expression_const_real -> CONST_REAL .)
    continue        reduce using rule 80 (expression_const_real -> CONST_REAL .)
    ID              reduce using rule 80 (expression_const_real -> CONST_REAL .)
    LBRACKET        reduce using rule 80 (expression_const_real -> CONST_REAL .)
    INDENT          reduce using rule 80 (expression_const_real -> CONST_REAL .)
    for             reduce using rule 80 (expression_const_real -> CONST_REAL .)
    while           reduce using rule 80 (expression_const_real -> CONST_REAL .)
    do              reduce using rule 80 (expression_const_real -> CONST_REAL .)
    repeat          reduce using rule 80 (expression_const_real -> CONST_REAL .)
    unless          reduce using rule 80 (expression_const_real -> CONST_REAL .)
    CONST_REAL      reduce using rule 80 (expression_const_real -> CONST_REAL .)
    CONST_INTERGER  reduce using rule 80 (expression_const_real -> CONST_REAL .)
    CONST_STRING    reduce using rule 80 (expression_const_real -> CONST_REAL .)
    True            reduce using rule 80 (expression_const_real -> CONST_REAL .)
    False           reduce using rule 80 (expression_const_real -> CONST_REAL .)
    DSING           reduce using rule 80 (expression_const_real -> CONST_REAL .)
    LAND            reduce using rule 80 (expression_const_real -> CONST_REAL .)
    puts            reduce using rule 80 (expression_const_real -> CONST_REAL .)
    NOT             reduce using rule 80 (expression_const_real -> CONST_REAL .)
    int             reduce using rule 80 (expression_const_real -> CONST_REAL .)
    float           reduce using rule 80 (expression_const_real -> CONST_REAL .)
    boolean         reduce using rule 80 (expression_const_real -> CONST_REAL .)
    $end            reduce using rule 80 (expression_const_real -> CONST_REAL .)
    begin           reduce using rule 80 (expression_const_real -> CONST_REAL .)
    DEDENT          reduce using rule 80 (expression_const_real -> CONST_REAL .)
    in              reduce using rule 80 (expression_const_real -> CONST_REAL .)
    then            reduce using rule 80 (expression_const_real -> CONST_REAL .)
    RBRACKET        reduce using rule 80 (expression_const_real -> CONST_REAL .)
    COMMA           reduce using rule 80 (expression_const_real -> CONST_REAL .)
    POINT           reduce using rule 80 (expression_const_real -> CONST_REAL .)
    end             reduce using rule 80 (expression_const_real -> CONST_REAL .)


state 66

    (82) expression_const_string -> CONST_STRING .

    AND             reduce using rule 82 (expression_const_string -> CONST_STRING .)
    OR              reduce using rule 82 (expression_const_string -> CONST_STRING .)
    GT              reduce using rule 82 (expression_const_string -> CONST_STRING .)
    GE              reduce using rule 82 (expression_const_string -> CONST_STRING .)
    LT              reduce using rule 82 (expression_const_string -> CONST_STRING .)
    LE              reduce using rule 82 (expression_const_string -> CONST_STRING .)
    MINUS           reduce using rule 82 (expression_const_string -> CONST_STRING .)
    PLUS            reduce using rule 82 (expression_const_string -> CONST_STRING .)
    ASTERISK        reduce using rule 82 (expression_const_string -> CONST_STRING .)
    DIVIDE          reduce using rule 82 (expression_const_string -> CONST_STRING .)
    MODULE          reduce using rule 82 (expression_const_string -> CONST_STRING .)
    EQUALS          reduce using rule 82 (expression_const_string -> CONST_STRING .)
    DIFFERENT       reduce using rule 82 (expression_const_string -> CONST_STRING .)
    if              reduce using rule 82 (expression_const_string -> CONST_STRING .)
    break           reduce using rule 82 (expression_const_string -> CONST_STRING .)
    continue        reduce using rule 82 (expression_const_string -> CONST_STRING .)
    ID              reduce using rule 82 (expression_const_string -> CONST_STRING .)
    LBRACKET        reduce using rule 82 (expression_const_string -> CONST_STRING .)
    INDENT          reduce using rule 82 (expression_const_string -> CONST_STRING .)
    for             reduce using rule 82 (expression_const_string -> CONST_STRING .)
    while           reduce using rule 82 (expression_const_string -> CONST_STRING .)
    do              reduce using rule 82 (expression_const_string -> CONST_STRING .)
    repeat          reduce using rule 82 (expression_const_string -> CONST_STRING .)
    unless          reduce using rule 82 (expression_const_string -> CONST_STRING .)
    CONST_REAL      reduce using rule 82 (expression_const_string -> CONST_STRING .)
    CONST_INTERGER  reduce using rule 82 (expression_const_string -> CONST_STRING .)
    CONST_STRING    reduce using rule 82 (expression_const_string -> CONST_STRING .)
    True            reduce using rule 82 (expression_const_string -> CONST_STRING .)
    False           reduce using rule 82 (expression_const_string -> CONST_STRING .)
    DSING           reduce using rule 82 (expression_const_string -> CONST_STRING .)
    LAND            reduce using rule 82 (expression_const_string -> CONST_STRING .)
    puts            reduce using rule 82 (expression_const_string -> CONST_STRING .)
    NOT             reduce using rule 82 (expression_const_string -> CONST_STRING .)
    int             reduce using rule 82 (expression_const_string -> CONST_STRING .)
    float           reduce using rule 82 (expression_const_string -> CONST_STRING .)
    boolean         reduce using rule 82 (expression_const_string -> CONST_STRING .)
    $end            reduce using rule 82 (expression_const_string -> CONST_STRING .)
    begin           reduce using rule 82 (expression_const_string -> CONST_STRING .)
    DEDENT          reduce using rule 82 (expression_const_string -> CONST_STRING .)
    in              reduce using rule 82 (expression_const_string -> CONST_STRING .)
    then            reduce using rule 82 (expression_const_string -> CONST_STRING .)
    RBRACKET        reduce using rule 82 (expression_const_string -> CONST_STRING .)
    COMMA           reduce using rule 82 (expression_const_string -> CONST_STRING .)
    POINT           reduce using rule 82 (expression_const_string -> CONST_STRING .)
    end             reduce using rule 82 (expression_const_string -> CONST_STRING .)


state 67

    (83) expression_true -> True .

    AND             reduce using rule 83 (expression_true -> True .)
    OR              reduce using rule 83 (expression_true -> True .)
    GT              reduce using rule 83 (expression_true -> True .)
    GE              reduce using rule 83 (expression_true -> True .)
    LT              reduce using rule 83 (expression_true -> True .)
    LE              reduce using rule 83 (expression_true -> True .)
    MINUS           reduce using rule 83 (expression_true -> True .)
    PLUS            reduce using rule 83 (expression_true -> True .)
    ASTERISK        reduce using rule 83 (expression_true -> True .)
    DIVIDE          reduce using rule 83 (expression_true -> True .)
    MODULE          reduce using rule 83 (expression_true -> True .)
    EQUALS          reduce using rule 83 (expression_true -> True .)
    DIFFERENT       reduce using rule 83 (expression_true -> True .)
    if              reduce using rule 83 (expression_true -> True .)
    break           reduce using rule 83 (expression_true -> True .)
    continue        reduce using rule 83 (expression_true -> True .)
    ID              reduce using rule 83 (expression_true -> True .)
    LBRACKET        reduce using rule 83 (expression_true -> True .)
    INDENT          reduce using rule 83 (expression_true -> True .)
    for             reduce using rule 83 (expression_true -> True .)
    while           reduce using rule 83 (expression_true -> True .)
    do              reduce using rule 83 (expression_true -> True .)
    repeat          reduce using rule 83 (expression_true -> True .)
    unless          reduce using rule 83 (expression_true -> True .)
    CONST_REAL      reduce using rule 83 (expression_true -> True .)
    CONST_INTERGER  reduce using rule 83 (expression_true -> True .)
    CONST_STRING    reduce using rule 83 (expression_true -> True .)
    True            reduce using rule 83 (expression_true -> True .)
    False           reduce using rule 83 (expression_true -> True .)
    DSING           reduce using rule 83 (expression_true -> True .)
    LAND            reduce using rule 83 (expression_true -> True .)
    puts            reduce using rule 83 (expression_true -> True .)
    NOT             reduce using rule 83 (expression_true -> True .)
    int             reduce using rule 83 (expression_true -> True .)
    float           reduce using rule 83 (expression_true -> True .)
    boolean         reduce using rule 83 (expression_true -> True .)
    $end            reduce using rule 83 (expression_true -> True .)
    begin           reduce using rule 83 (expression_true -> True .)
    DEDENT          reduce using rule 83 (expression_true -> True .)
    in              reduce using rule 83 (expression_true -> True .)
    then            reduce using rule 83 (expression_true -> True .)
    RBRACKET        reduce using rule 83 (expression_true -> True .)
    COMMA           reduce using rule 83 (expression_true -> True .)
    POINT           reduce using rule 83 (expression_true -> True .)
    end             reduce using rule 83 (expression_true -> True .)


state 68

    (84) expression_false -> False .

    AND             reduce using rule 84 (expression_false -> False .)
    OR              reduce using rule 84 (expression_false -> False .)
    GT              reduce using rule 84 (expression_false -> False .)
    GE              reduce using rule 84 (expression_false -> False .)
    LT              reduce using rule 84 (expression_false -> False .)
    LE              reduce using rule 84 (expression_false -> False .)
    MINUS           reduce using rule 84 (expression_false -> False .)
    PLUS            reduce using rule 84 (expression_false -> False .)
    ASTERISK        reduce using rule 84 (expression_false -> False .)
    DIVIDE          reduce using rule 84 (expression_false -> False .)
    MODULE          reduce using rule 84 (expression_false -> False .)
    EQUALS          reduce using rule 84 (expression_false -> False .)
    DIFFERENT       reduce using rule 84 (expression_false -> False .)
    if              reduce using rule 84 (expression_false -> False .)
    break           reduce using rule 84 (expression_false -> False .)
    continue        reduce using rule 84 (expression_false -> False .)
    ID              reduce using rule 84 (expression_false -> False .)
    LBRACKET        reduce using rule 84 (expression_false -> False .)
    INDENT          reduce using rule 84 (expression_false -> False .)
    for             reduce using rule 84 (expression_false -> False .)
    while           reduce using rule 84 (expression_false -> False .)
    do              reduce using rule 84 (expression_false -> False .)
    repeat          reduce using rule 84 (expression_false -> False .)
    unless          reduce using rule 84 (expression_false -> False .)
    CONST_REAL      reduce using rule 84 (expression_false -> False .)
    CONST_INTERGER  reduce using rule 84 (expression_false -> False .)
    CONST_STRING    reduce using rule 84 (expression_false -> False .)
    True            reduce using rule 84 (expression_false -> False .)
    False           reduce using rule 84 (expression_false -> False .)
    DSING           reduce using rule 84 (expression_false -> False .)
    LAND            reduce using rule 84 (expression_false -> False .)
    puts            reduce using rule 84 (expression_false -> False .)
    NOT             reduce using rule 84 (expression_false -> False .)
    int             reduce using rule 84 (expression_false -> False .)
    float           reduce using rule 84 (expression_false -> False .)
    boolean         reduce using rule 84 (expression_false -> False .)
    $end            reduce using rule 84 (expression_false -> False .)
    begin           reduce using rule 84 (expression_false -> False .)
    DEDENT          reduce using rule 84 (expression_false -> False .)
    in              reduce using rule 84 (expression_false -> False .)
    then            reduce using rule 84 (expression_false -> False .)
    RBRACKET        reduce using rule 84 (expression_false -> False .)
    COMMA           reduce using rule 84 (expression_false -> False .)
    POINT           reduce using rule 84 (expression_false -> False .)
    end             reduce using rule 84 (expression_false -> False .)


state 69

    (96) expression_variable -> DSING . ID

    ID              shift and go to state 124


state 70

    (20) simple_declaration -> matrix_declaration .

    if              reduce using rule 20 (simple_declaration -> matrix_declaration .)
    break           reduce using rule 20 (simple_declaration -> matrix_declaration .)
    continue        reduce using rule 20 (simple_declaration -> matrix_declaration .)
    ID              reduce using rule 20 (simple_declaration -> matrix_declaration .)
    ASTERISK        reduce using rule 20 (simple_declaration -> matrix_declaration .)
    LBRACKET        reduce using rule 20 (simple_declaration -> matrix_declaration .)
    INDENT          reduce using rule 20 (simple_declaration -> matrix_declaration .)
    for             reduce using rule 20 (simple_declaration -> matrix_declaration .)
    while           reduce using rule 20 (simple_declaration -> matrix_declaration .)
    do              reduce using rule 20 (simple_declaration -> matrix_declaration .)
    repeat          reduce using rule 20 (simple_declaration -> matrix_declaration .)
    unless          reduce using rule 20 (simple_declaration -> matrix_declaration .)
    CONST_REAL      reduce using rule 20 (simple_declaration -> matrix_declaration .)
    CONST_INTERGER  reduce using rule 20 (simple_declaration -> matrix_declaration .)
    CONST_STRING    reduce using rule 20 (simple_declaration -> matrix_declaration .)
    True            reduce using rule 20 (simple_declaration -> matrix_declaration .)
    False           reduce using rule 20 (simple_declaration -> matrix_declaration .)
    DSING           reduce using rule 20 (simple_declaration -> matrix_declaration .)
    LAND            reduce using rule 20 (simple_declaration -> matrix_declaration .)
    puts            reduce using rule 20 (simple_declaration -> matrix_declaration .)
    NOT             reduce using rule 20 (simple_declaration -> matrix_declaration .)
    PLUS            reduce using rule 20 (simple_declaration -> matrix_declaration .)
    MINUS           reduce using rule 20 (simple_declaration -> matrix_declaration .)
    int             reduce using rule 20 (simple_declaration -> matrix_declaration .)
    float           reduce using rule 20 (simple_declaration -> matrix_declaration .)
    boolean         reduce using rule 20 (simple_declaration -> matrix_declaration .)
    AND             reduce using rule 20 (simple_declaration -> matrix_declaration .)
    $end            reduce using rule 20 (simple_declaration -> matrix_declaration .)
    DEDENT          reduce using rule 20 (simple_declaration -> matrix_declaration .)


state 71

    (21) simple_declaration -> expression_declaration .

    if              reduce using rule 21 (simple_declaration -> expression_declaration .)
    break           reduce using rule 21 (simple_declaration -> expression_declaration .)
    continue        reduce using rule 21 (simple_declaration -> expression_declaration .)
    ID              reduce using rule 21 (simple_declaration -> expression_declaration .)
    ASTERISK        reduce using rule 21 (simple_declaration -> expression_declaration .)
    LBRACKET        reduce using rule 21 (simple_declaration -> expression_declaration .)
    INDENT          reduce using rule 21 (simple_declaration -> expression_declaration .)
    for             reduce using rule 21 (simple_declaration -> expression_declaration .)
    while           reduce using rule 21 (simple_declaration -> expression_declaration .)
    do              reduce using rule 21 (simple_declaration -> expression_declaration .)
    repeat          reduce using rule 21 (simple_declaration -> expression_declaration .)
    unless          reduce using rule 21 (simple_declaration -> expression_declaration .)
    CONST_REAL      reduce using rule 21 (simple_declaration -> expression_declaration .)
    CONST_INTERGER  reduce using rule 21 (simple_declaration -> expression_declaration .)
    CONST_STRING    reduce using rule 21 (simple_declaration -> expression_declaration .)
    True            reduce using rule 21 (simple_declaration -> expression_declaration .)
    False           reduce using rule 21 (simple_declaration -> expression_declaration .)
    DSING           reduce using rule 21 (simple_declaration -> expression_declaration .)
    LAND            reduce using rule 21 (simple_declaration -> expression_declaration .)
    puts            reduce using rule 21 (simple_declaration -> expression_declaration .)
    NOT             reduce using rule 21 (simple_declaration -> expression_declaration .)
    PLUS            reduce using rule 21 (simple_declaration -> expression_declaration .)
    MINUS           reduce using rule 21 (simple_declaration -> expression_declaration .)
    int             reduce using rule 21 (simple_declaration -> expression_declaration .)
    float           reduce using rule 21 (simple_declaration -> expression_declaration .)
    boolean         reduce using rule 21 (simple_declaration -> expression_declaration .)
    AND             reduce using rule 21 (simple_declaration -> expression_declaration .)
    $end            reduce using rule 21 (simple_declaration -> expression_declaration .)
    DEDENT          reduce using rule 21 (simple_declaration -> expression_declaration .)


state 72

    (24) complex_declaration -> int_declaration .

    if              reduce using rule 24 (complex_declaration -> int_declaration .)
    break           reduce using rule 24 (complex_declaration -> int_declaration .)
    continue        reduce using rule 24 (complex_declaration -> int_declaration .)
    ID              reduce using rule 24 (complex_declaration -> int_declaration .)
    ASTERISK        reduce using rule 24 (complex_declaration -> int_declaration .)
    LBRACKET        reduce using rule 24 (complex_declaration -> int_declaration .)
    INDENT          reduce using rule 24 (complex_declaration -> int_declaration .)
    for             reduce using rule 24 (complex_declaration -> int_declaration .)
    while           reduce using rule 24 (complex_declaration -> int_declaration .)
    do              reduce using rule 24 (complex_declaration -> int_declaration .)
    repeat          reduce using rule 24 (complex_declaration -> int_declaration .)
    unless          reduce using rule 24 (complex_declaration -> int_declaration .)
    CONST_REAL      reduce using rule 24 (complex_declaration -> int_declaration .)
    CONST_INTERGER  reduce using rule 24 (complex_declaration -> int_declaration .)
    CONST_STRING    reduce using rule 24 (complex_declaration -> int_declaration .)
    True            reduce using rule 24 (complex_declaration -> int_declaration .)
    False           reduce using rule 24 (complex_declaration -> int_declaration .)
    DSING           reduce using rule 24 (complex_declaration -> int_declaration .)
    LAND            reduce using rule 24 (complex_declaration -> int_declaration .)
    puts            reduce using rule 24 (complex_declaration -> int_declaration .)
    NOT             reduce using rule 24 (complex_declaration -> int_declaration .)
    PLUS            reduce using rule 24 (complex_declaration -> int_declaration .)
    MINUS           reduce using rule 24 (complex_declaration -> int_declaration .)
    int             reduce using rule 24 (complex_declaration -> int_declaration .)
    float           reduce using rule 24 (complex_declaration -> int_declaration .)
    boolean         reduce using rule 24 (complex_declaration -> int_declaration .)
    AND             reduce using rule 24 (complex_declaration -> int_declaration .)
    $end            reduce using rule 24 (complex_declaration -> int_declaration .)
    DEDENT          reduce using rule 24 (complex_declaration -> int_declaration .)


state 73

    (25) complex_declaration -> float_declaration .

    if              reduce using rule 25 (complex_declaration -> float_declaration .)
    break           reduce using rule 25 (complex_declaration -> float_declaration .)
    continue        reduce using rule 25 (complex_declaration -> float_declaration .)
    ID              reduce using rule 25 (complex_declaration -> float_declaration .)
    ASTERISK        reduce using rule 25 (complex_declaration -> float_declaration .)
    LBRACKET        reduce using rule 25 (complex_declaration -> float_declaration .)
    INDENT          reduce using rule 25 (complex_declaration -> float_declaration .)
    for             reduce using rule 25 (complex_declaration -> float_declaration .)
    while           reduce using rule 25 (complex_declaration -> float_declaration .)
    do              reduce using rule 25 (complex_declaration -> float_declaration .)
    repeat          reduce using rule 25 (complex_declaration -> float_declaration .)
    unless          reduce using rule 25 (complex_declaration -> float_declaration .)
    CONST_REAL      reduce using rule 25 (complex_declaration -> float_declaration .)
    CONST_INTERGER  reduce using rule 25 (complex_declaration -> float_declaration .)
    CONST_STRING    reduce using rule 25 (complex_declaration -> float_declaration .)
    True            reduce using rule 25 (complex_declaration -> float_declaration .)
    False           reduce using rule 25 (complex_declaration -> float_declaration .)
    DSING           reduce using rule 25 (complex_declaration -> float_declaration .)
    LAND            reduce using rule 25 (complex_declaration -> float_declaration .)
    puts            reduce using rule 25 (complex_declaration -> float_declaration .)
    NOT             reduce using rule 25 (complex_declaration -> float_declaration .)
    PLUS            reduce using rule 25 (complex_declaration -> float_declaration .)
    MINUS           reduce using rule 25 (complex_declaration -> float_declaration .)
    int             reduce using rule 25 (complex_declaration -> float_declaration .)
    float           reduce using rule 25 (complex_declaration -> float_declaration .)
    boolean         reduce using rule 25 (complex_declaration -> float_declaration .)
    AND             reduce using rule 25 (complex_declaration -> float_declaration .)
    $end            reduce using rule 25 (complex_declaration -> float_declaration .)
    DEDENT          reduce using rule 25 (complex_declaration -> float_declaration .)


state 74

    (26) complex_declaration -> boolean_declaration .

    if              reduce using rule 26 (complex_declaration -> boolean_declaration .)
    break           reduce using rule 26 (complex_declaration -> boolean_declaration .)
    continue        reduce using rule 26 (complex_declaration -> boolean_declaration .)
    ID              reduce using rule 26 (complex_declaration -> boolean_declaration .)
    ASTERISK        reduce using rule 26 (complex_declaration -> boolean_declaration .)
    LBRACKET        reduce using rule 26 (complex_declaration -> boolean_declaration .)
    INDENT          reduce using rule 26 (complex_declaration -> boolean_declaration .)
    for             reduce using rule 26 (complex_declaration -> boolean_declaration .)
    while           reduce using rule 26 (complex_declaration -> boolean_declaration .)
    do              reduce using rule 26 (complex_declaration -> boolean_declaration .)
    repeat          reduce using rule 26 (complex_declaration -> boolean_declaration .)
    unless          reduce using rule 26 (complex_declaration -> boolean_declaration .)
    CONST_REAL      reduce using rule 26 (complex_declaration -> boolean_declaration .)
    CONST_INTERGER  reduce using rule 26 (complex_declaration -> boolean_declaration .)
    CONST_STRING    reduce using rule 26 (complex_declaration -> boolean_declaration .)
    True            reduce using rule 26 (complex_declaration -> boolean_declaration .)
    False           reduce using rule 26 (complex_declaration -> boolean_declaration .)
    DSING           reduce using rule 26 (complex_declaration -> boolean_declaration .)
    LAND            reduce using rule 26 (complex_declaration -> boolean_declaration .)
    puts            reduce using rule 26 (complex_declaration -> boolean_declaration .)
    NOT             reduce using rule 26 (complex_declaration -> boolean_declaration .)
    PLUS            reduce using rule 26 (complex_declaration -> boolean_declaration .)
    MINUS           reduce using rule 26 (complex_declaration -> boolean_declaration .)
    int             reduce using rule 26 (complex_declaration -> boolean_declaration .)
    float           reduce using rule 26 (complex_declaration -> boolean_declaration .)
    boolean         reduce using rule 26 (complex_declaration -> boolean_declaration .)
    AND             reduce using rule 26 (complex_declaration -> boolean_declaration .)
    $end            reduce using rule 26 (complex_declaration -> boolean_declaration .)
    DEDENT          reduce using rule 26 (complex_declaration -> boolean_declaration .)


state 75

    (120) declaration_pointer -> pointer . ID

    ID              shift and go to state 125


state 76

    (121) acess_pointer -> pointer_acess . ID

    ID              shift and go to state 126


state 77

    (102) puts_const_string -> puts . CONST_STRING
    (103) puts_expression -> puts . expression_variable
    (106) puts_string -> puts . QUOTATION CONST_STRING QUOTATION
    (107) puts_expressionq -> puts . QUOTATION expression_variable QUOTATION
    (110) puts_string_dq -> puts . DQUOTATION CONST_STRING DQUOTATION
    (111) puts_expression_dq -> puts . DQUOTATION expression_variable DQUOTATION
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID

    CONST_STRING    shift and go to state 127
    QUOTATION       shift and go to state 129
    DQUOTATION      shift and go to state 130
    ID              shift and go to state 106
    DSING           shift and go to state 69

    expression_variable            shift and go to state 128

state 78

    (104) puts_quotation -> puts_string .

    if              reduce using rule 104 (puts_quotation -> puts_string .)
    break           reduce using rule 104 (puts_quotation -> puts_string .)
    continue        reduce using rule 104 (puts_quotation -> puts_string .)
    ID              reduce using rule 104 (puts_quotation -> puts_string .)
    ASTERISK        reduce using rule 104 (puts_quotation -> puts_string .)
    LBRACKET        reduce using rule 104 (puts_quotation -> puts_string .)
    INDENT          reduce using rule 104 (puts_quotation -> puts_string .)
    for             reduce using rule 104 (puts_quotation -> puts_string .)
    while           reduce using rule 104 (puts_quotation -> puts_string .)
    do              reduce using rule 104 (puts_quotation -> puts_string .)
    repeat          reduce using rule 104 (puts_quotation -> puts_string .)
    unless          reduce using rule 104 (puts_quotation -> puts_string .)
    CONST_REAL      reduce using rule 104 (puts_quotation -> puts_string .)
    CONST_INTERGER  reduce using rule 104 (puts_quotation -> puts_string .)
    CONST_STRING    reduce using rule 104 (puts_quotation -> puts_string .)
    True            reduce using rule 104 (puts_quotation -> puts_string .)
    False           reduce using rule 104 (puts_quotation -> puts_string .)
    DSING           reduce using rule 104 (puts_quotation -> puts_string .)
    LAND            reduce using rule 104 (puts_quotation -> puts_string .)
    puts            reduce using rule 104 (puts_quotation -> puts_string .)
    NOT             reduce using rule 104 (puts_quotation -> puts_string .)
    PLUS            reduce using rule 104 (puts_quotation -> puts_string .)
    MINUS           reduce using rule 104 (puts_quotation -> puts_string .)
    int             reduce using rule 104 (puts_quotation -> puts_string .)
    float           reduce using rule 104 (puts_quotation -> puts_string .)
    boolean         reduce using rule 104 (puts_quotation -> puts_string .)
    AND             reduce using rule 104 (puts_quotation -> puts_string .)
    $end            reduce using rule 104 (puts_quotation -> puts_string .)
    DEDENT          reduce using rule 104 (puts_quotation -> puts_string .)


state 79

    (105) puts_quotation -> puts_expressionq .

    if              reduce using rule 105 (puts_quotation -> puts_expressionq .)
    break           reduce using rule 105 (puts_quotation -> puts_expressionq .)
    continue        reduce using rule 105 (puts_quotation -> puts_expressionq .)
    ID              reduce using rule 105 (puts_quotation -> puts_expressionq .)
    ASTERISK        reduce using rule 105 (puts_quotation -> puts_expressionq .)
    LBRACKET        reduce using rule 105 (puts_quotation -> puts_expressionq .)
    INDENT          reduce using rule 105 (puts_quotation -> puts_expressionq .)
    for             reduce using rule 105 (puts_quotation -> puts_expressionq .)
    while           reduce using rule 105 (puts_quotation -> puts_expressionq .)
    do              reduce using rule 105 (puts_quotation -> puts_expressionq .)
    repeat          reduce using rule 105 (puts_quotation -> puts_expressionq .)
    unless          reduce using rule 105 (puts_quotation -> puts_expressionq .)
    CONST_REAL      reduce using rule 105 (puts_quotation -> puts_expressionq .)
    CONST_INTERGER  reduce using rule 105 (puts_quotation -> puts_expressionq .)
    CONST_STRING    reduce using rule 105 (puts_quotation -> puts_expressionq .)
    True            reduce using rule 105 (puts_quotation -> puts_expressionq .)
    False           reduce using rule 105 (puts_quotation -> puts_expressionq .)
    DSING           reduce using rule 105 (puts_quotation -> puts_expressionq .)
    LAND            reduce using rule 105 (puts_quotation -> puts_expressionq .)
    puts            reduce using rule 105 (puts_quotation -> puts_expressionq .)
    NOT             reduce using rule 105 (puts_quotation -> puts_expressionq .)
    PLUS            reduce using rule 105 (puts_quotation -> puts_expressionq .)
    MINUS           reduce using rule 105 (puts_quotation -> puts_expressionq .)
    int             reduce using rule 105 (puts_quotation -> puts_expressionq .)
    float           reduce using rule 105 (puts_quotation -> puts_expressionq .)
    boolean         reduce using rule 105 (puts_quotation -> puts_expressionq .)
    AND             reduce using rule 105 (puts_quotation -> puts_expressionq .)
    $end            reduce using rule 105 (puts_quotation -> puts_expressionq .)
    DEDENT          reduce using rule 105 (puts_quotation -> puts_expressionq .)


state 80

    (108) puts_dquotation -> puts_string_dq .

    if              reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    break           reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    continue        reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    ID              reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    ASTERISK        reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    LBRACKET        reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    INDENT          reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    for             reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    while           reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    do              reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    repeat          reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    unless          reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    CONST_REAL      reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    CONST_INTERGER  reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    CONST_STRING    reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    True            reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    False           reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    DSING           reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    LAND            reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    puts            reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    NOT             reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    PLUS            reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    MINUS           reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    int             reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    float           reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    boolean         reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    AND             reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    $end            reduce using rule 108 (puts_dquotation -> puts_string_dq .)
    DEDENT          reduce using rule 108 (puts_dquotation -> puts_string_dq .)


state 81

    (109) puts_dquotation -> puts_expression_dq .

    if              reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    break           reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    continue        reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    ID              reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    ASTERISK        reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    LBRACKET        reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    INDENT          reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    for             reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    while           reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    do              reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    repeat          reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    unless          reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    CONST_REAL      reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    CONST_INTERGER  reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    CONST_STRING    reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    True            reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    False           reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    DSING           reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    LAND            reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    puts            reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    NOT             reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    PLUS            reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    MINUS           reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    int             reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    float           reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    boolean         reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    AND             reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    $end            reduce using rule 109 (puts_dquotation -> puts_expression_dq .)
    DEDENT          reduce using rule 109 (puts_dquotation -> puts_expression_dq .)


state 82

    (118) token_and -> AND .

    AND             reduce using rule 118 (token_and -> AND .)
    LAND            reduce using rule 118 (token_and -> AND .)
    ID              reduce using rule 118 (token_and -> AND .)


state 83

    (69) unitary_minus -> MINUS . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 131
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 84

    (70) unitary_plus -> PLUS . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 132
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 85

    (72) unitary_not -> NOT . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 133
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 86

    (27) int_declaration -> int . ID ASSIGNMENT expression

    ID              shift and go to state 134


state 87

    (28) float_declaration -> float . ID ASSIGNMENT expression

    ID              shift and go to state 135


state 88

    (29) boolean_declaration -> boolean . ID ASSIGNMENT expression_declaration

    ID              shift and go to state 136


state 89

    (114) pointer_acess -> and . pointer_acess
    (115) pointer_acess -> and .
    (114) pointer_acess -> . and pointer_acess
    (115) pointer_acess -> . and
    (116) and -> . token_and
    (117) and -> . token_land
    (118) token_and -> . AND
    (119) token_land -> . LAND

    ID              reduce using rule 115 (pointer_acess -> and .)
    AND             shift and go to state 82
    LAND            shift and go to state 138

    and                            shift and go to state 89
    pointer_acess                  shift and go to state 137
    token_and                      shift and go to state 90
    token_land                     shift and go to state 91

state 90

    (116) and -> token_and .

    AND             reduce using rule 116 (and -> token_and .)
    LAND            reduce using rule 116 (and -> token_and .)
    ID              reduce using rule 116 (and -> token_and .)


state 91

    (117) and -> token_land .

    AND             reduce using rule 117 (and -> token_land .)
    LAND            reduce using rule 117 (and -> token_land .)
    ID              reduce using rule 117 (and -> token_land .)


state 92

    (73) expression_and -> expression AND . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 139
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 93

    (74) expression_or -> expression OR . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 140
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 94

    (75) expression_gt -> expression GT . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 141
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 95

    (76) expression_ge -> expression GE . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 142
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 96

    (77) expression_lt -> expression LT . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 143
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 97

    (78) expression_le -> expression LE . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 144
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 98

    (88) expression_minus -> expression MINUS . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 145
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 99

    (85) expression_plus -> expression PLUS . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 146
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 100

    (89) expression_mult -> expression ASTERISK . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 147
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 101

    (90) expression_divide -> expression DIVIDE . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 148
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 102

    (91) expression_module -> expression MODULE . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 149
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 103

    (86) expression_equals -> expression EQUALS . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 150
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 104

    (87) expression_different -> expression DIFFERENT . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 151
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 105

    (30) conditional -> if expression . begin bloco end SEMICOLON
    (31) conditional -> if expression . begin bloco else bloco end SEMICOLON
    (32) conditional -> if expression . begin bloco elsif expression bloco else bloco end SEMICOLON
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    begin           shift and go to state 152
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104


state 106

    (95) expression_variable -> ID .

    begin           reduce using rule 95 (expression_variable -> ID .)
    AND             reduce using rule 95 (expression_variable -> ID .)
    OR              reduce using rule 95 (expression_variable -> ID .)
    GT              reduce using rule 95 (expression_variable -> ID .)
    GE              reduce using rule 95 (expression_variable -> ID .)
    LT              reduce using rule 95 (expression_variable -> ID .)
    LE              reduce using rule 95 (expression_variable -> ID .)
    MINUS           reduce using rule 95 (expression_variable -> ID .)
    PLUS            reduce using rule 95 (expression_variable -> ID .)
    ASTERISK        reduce using rule 95 (expression_variable -> ID .)
    DIVIDE          reduce using rule 95 (expression_variable -> ID .)
    MODULE          reduce using rule 95 (expression_variable -> ID .)
    EQUALS          reduce using rule 95 (expression_variable -> ID .)
    DIFFERENT       reduce using rule 95 (expression_variable -> ID .)
    if              reduce using rule 95 (expression_variable -> ID .)
    break           reduce using rule 95 (expression_variable -> ID .)
    continue        reduce using rule 95 (expression_variable -> ID .)
    ID              reduce using rule 95 (expression_variable -> ID .)
    LBRACKET        reduce using rule 95 (expression_variable -> ID .)
    INDENT          reduce using rule 95 (expression_variable -> ID .)
    for             reduce using rule 95 (expression_variable -> ID .)
    while           reduce using rule 95 (expression_variable -> ID .)
    do              reduce using rule 95 (expression_variable -> ID .)
    repeat          reduce using rule 95 (expression_variable -> ID .)
    unless          reduce using rule 95 (expression_variable -> ID .)
    CONST_REAL      reduce using rule 95 (expression_variable -> ID .)
    CONST_INTERGER  reduce using rule 95 (expression_variable -> ID .)
    CONST_STRING    reduce using rule 95 (expression_variable -> ID .)
    True            reduce using rule 95 (expression_variable -> ID .)
    False           reduce using rule 95 (expression_variable -> ID .)
    DSING           reduce using rule 95 (expression_variable -> ID .)
    LAND            reduce using rule 95 (expression_variable -> ID .)
    puts            reduce using rule 95 (expression_variable -> ID .)
    NOT             reduce using rule 95 (expression_variable -> ID .)
    int             reduce using rule 95 (expression_variable -> ID .)
    float           reduce using rule 95 (expression_variable -> ID .)
    boolean         reduce using rule 95 (expression_variable -> ID .)
    $end            reduce using rule 95 (expression_variable -> ID .)
    DEDENT          reduce using rule 95 (expression_variable -> ID .)
    in              reduce using rule 95 (expression_variable -> ID .)
    then            reduce using rule 95 (expression_variable -> ID .)
    RBRACKET        reduce using rule 95 (expression_variable -> ID .)
    COMMA           reduce using rule 95 (expression_variable -> ID .)
    POINT           reduce using rule 95 (expression_variable -> ID .)
    end             reduce using rule 95 (expression_variable -> ID .)
    QUOTATION       reduce using rule 95 (expression_variable -> ID .)
    DQUOTATION      reduce using rule 95 (expression_variable -> ID .)


state 107

    (79) expression_land -> LAND . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 116
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 108

    (71) unitary_asterisk -> ASTERISK . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 113
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 109

    (92) argumentlist -> ID LPAREN . COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    COMMA           shift and go to state 153


state 110

    (97) read_gets -> ID ASSIGNMENT . gets
    (22) matrix_declaration -> ID ASSIGNMENT . matrix
    (23) expression_declaration -> ID ASSIGNMENT . expression
    (122) matrix -> . matrix_arg
    (123) matrix -> . matrix_rec
    (124) matrix -> . LBRACKET argument RBRACKET matrix
    (125) matrix -> . LBRACKET argument RBRACKET COMMA matrix
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (126) matrix_arg -> . LBRACKET argument RBRACKET
    (127) matrix_rec -> . LBRACKET matrix RBRACKET
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    gets            shift and go to state 154
    LBRACKET        shift and go to state 159
    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    matrix                         shift and go to state 155
    expression                     shift and go to state 156
    matrix_arg                     shift and go to state 157
    matrix_rec                     shift and go to state 158
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 111

    (112) pointer -> ASTERISK . pointer
    (113) pointer -> ASTERISK .
    (71) unitary_asterisk -> ASTERISK . expression
    (112) pointer -> . ASTERISK pointer
    (113) pointer -> . ASTERISK
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    ID              reduce using rule 113 (pointer -> ASTERISK .)
    ASTERISK        shift and go to state 111
    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

  ! ID              [ shift and go to state 106 ]

    pointer                        shift and go to state 114
    expression                     shift and go to state 113
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 112

    (93) argumentlist -> ASTERISK ID . LBRACKET COMMA LAND ID RBRACKET
    (95) expression_variable -> ID .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 160
    AND             reduce using rule 95 (expression_variable -> ID .)
    OR              reduce using rule 95 (expression_variable -> ID .)
    GT              reduce using rule 95 (expression_variable -> ID .)
    GE              reduce using rule 95 (expression_variable -> ID .)
    LT              reduce using rule 95 (expression_variable -> ID .)
    LE              reduce using rule 95 (expression_variable -> ID .)
    MINUS           reduce using rule 95 (expression_variable -> ID .)
    PLUS            reduce using rule 95 (expression_variable -> ID .)
    ASTERISK        reduce using rule 95 (expression_variable -> ID .)
    DIVIDE          reduce using rule 95 (expression_variable -> ID .)
    MODULE          reduce using rule 95 (expression_variable -> ID .)
    EQUALS          reduce using rule 95 (expression_variable -> ID .)
    DIFFERENT       reduce using rule 95 (expression_variable -> ID .)
    if              reduce using rule 95 (expression_variable -> ID .)
    break           reduce using rule 95 (expression_variable -> ID .)
    continue        reduce using rule 95 (expression_variable -> ID .)
    ID              reduce using rule 95 (expression_variable -> ID .)
    INDENT          reduce using rule 95 (expression_variable -> ID .)
    for             reduce using rule 95 (expression_variable -> ID .)
    while           reduce using rule 95 (expression_variable -> ID .)
    do              reduce using rule 95 (expression_variable -> ID .)
    repeat          reduce using rule 95 (expression_variable -> ID .)
    unless          reduce using rule 95 (expression_variable -> ID .)
    CONST_REAL      reduce using rule 95 (expression_variable -> ID .)
    CONST_INTERGER  reduce using rule 95 (expression_variable -> ID .)
    CONST_STRING    reduce using rule 95 (expression_variable -> ID .)
    True            reduce using rule 95 (expression_variable -> ID .)
    False           reduce using rule 95 (expression_variable -> ID .)
    DSING           reduce using rule 95 (expression_variable -> ID .)
    LAND            reduce using rule 95 (expression_variable -> ID .)
    puts            reduce using rule 95 (expression_variable -> ID .)
    NOT             reduce using rule 95 (expression_variable -> ID .)
    int             reduce using rule 95 (expression_variable -> ID .)
    float           reduce using rule 95 (expression_variable -> ID .)
    boolean         reduce using rule 95 (expression_variable -> ID .)
    $end            reduce using rule 95 (expression_variable -> ID .)
    DEDENT          reduce using rule 95 (expression_variable -> ID .)

  ! LBRACKET        [ reduce using rule 95 (expression_variable -> ID .) ]


state 113

    (71) unitary_asterisk -> ASTERISK expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    OR              reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    GT              reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    GE              reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    LT              reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    LE              reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    MINUS           reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    PLUS            reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    ASTERISK        reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    DIVIDE          reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    MODULE          reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    EQUALS          reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    DIFFERENT       reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    if              reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    break           reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    continue        reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    ID              reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    LBRACKET        reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    INDENT          reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    for             reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    while           reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    do              reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    repeat          reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    unless          reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    CONST_REAL      reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    CONST_INTERGER  reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    CONST_STRING    reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    True            reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    False           reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    DSING           reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    LAND            reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    puts            reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    NOT             reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    int             reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    float           reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    boolean         reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    $end            reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    begin           reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    DEDENT          reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    in              reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    then            reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    RBRACKET        reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    COMMA           reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    POINT           reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)
    end             reduce using rule 71 (unitary_asterisk -> ASTERISK expression .)

  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! ASTERISK        [ shift and go to state 100 ]
  ! DIVIDE          [ shift and go to state 101 ]
  ! MODULE          [ shift and go to state 102 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 114

    (112) pointer -> ASTERISK pointer .

    ID              reduce using rule 112 (pointer -> ASTERISK pointer .)


state 115

    (94) argumentlist -> LBRACKET LAND . ID RBRACKET

    ID              shift and go to state 161


state 116

    (79) expression_land -> LAND expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 79 (expression_land -> LAND expression .)
    OR              reduce using rule 79 (expression_land -> LAND expression .)
    GT              reduce using rule 79 (expression_land -> LAND expression .)
    GE              reduce using rule 79 (expression_land -> LAND expression .)
    LT              reduce using rule 79 (expression_land -> LAND expression .)
    LE              reduce using rule 79 (expression_land -> LAND expression .)
    MINUS           reduce using rule 79 (expression_land -> LAND expression .)
    PLUS            reduce using rule 79 (expression_land -> LAND expression .)
    ASTERISK        reduce using rule 79 (expression_land -> LAND expression .)
    DIVIDE          reduce using rule 79 (expression_land -> LAND expression .)
    MODULE          reduce using rule 79 (expression_land -> LAND expression .)
    EQUALS          reduce using rule 79 (expression_land -> LAND expression .)
    DIFFERENT       reduce using rule 79 (expression_land -> LAND expression .)
    if              reduce using rule 79 (expression_land -> LAND expression .)
    break           reduce using rule 79 (expression_land -> LAND expression .)
    continue        reduce using rule 79 (expression_land -> LAND expression .)
    ID              reduce using rule 79 (expression_land -> LAND expression .)
    LBRACKET        reduce using rule 79 (expression_land -> LAND expression .)
    INDENT          reduce using rule 79 (expression_land -> LAND expression .)
    for             reduce using rule 79 (expression_land -> LAND expression .)
    while           reduce using rule 79 (expression_land -> LAND expression .)
    do              reduce using rule 79 (expression_land -> LAND expression .)
    repeat          reduce using rule 79 (expression_land -> LAND expression .)
    unless          reduce using rule 79 (expression_land -> LAND expression .)
    CONST_REAL      reduce using rule 79 (expression_land -> LAND expression .)
    CONST_INTERGER  reduce using rule 79 (expression_land -> LAND expression .)
    CONST_STRING    reduce using rule 79 (expression_land -> LAND expression .)
    True            reduce using rule 79 (expression_land -> LAND expression .)
    False           reduce using rule 79 (expression_land -> LAND expression .)
    DSING           reduce using rule 79 (expression_land -> LAND expression .)
    LAND            reduce using rule 79 (expression_land -> LAND expression .)
    puts            reduce using rule 79 (expression_land -> LAND expression .)
    NOT             reduce using rule 79 (expression_land -> LAND expression .)
    int             reduce using rule 79 (expression_land -> LAND expression .)
    float           reduce using rule 79 (expression_land -> LAND expression .)
    boolean         reduce using rule 79 (expression_land -> LAND expression .)
    $end            reduce using rule 79 (expression_land -> LAND expression .)
    begin           reduce using rule 79 (expression_land -> LAND expression .)
    DEDENT          reduce using rule 79 (expression_land -> LAND expression .)
    in              reduce using rule 79 (expression_land -> LAND expression .)
    then            reduce using rule 79 (expression_land -> LAND expression .)
    RBRACKET        reduce using rule 79 (expression_land -> LAND expression .)
    COMMA           reduce using rule 79 (expression_land -> LAND expression .)
    POINT           reduce using rule 79 (expression_land -> LAND expression .)
    end             reduce using rule 79 (expression_land -> LAND expression .)

  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! ASTERISK        [ shift and go to state 100 ]
  ! DIVIDE          [ shift and go to state 101 ]
  ! MODULE          [ shift and go to state 102 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 117

    (3) bloco -> INDENT program . DEDENT
    (1) program -> program . statment
    (4) statment -> . conditional
    (5) statment -> . loops
    (6) statment -> . stop
    (7) statment -> . conti
    (8) statment -> . argumentlist
    (9) statment -> . bloco
    (10) statment -> . expression
    (11) statment -> . declaration
    (12) statment -> . read_gets
    (13) statment -> . create_puts
    (30) conditional -> . if expression begin bloco end SEMICOLON
    (31) conditional -> . if expression begin bloco else bloco end SEMICOLON
    (32) conditional -> . if expression begin bloco elsif expression bloco else bloco end SEMICOLON
    (33) loops -> . fors
    (34) loops -> . whiles
    (35) loops -> . repeats
    (36) loops -> . unlesss
    (14) stop -> . break
    (15) conti -> . continue
    (92) argumentlist -> . ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET
    (93) argumentlist -> . ASTERISK ID LBRACKET COMMA LAND ID RBRACKET
    (94) argumentlist -> . LBRACKET LAND ID RBRACKET
    (3) bloco -> . INDENT program DEDENT
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (16) declaration -> . simple_declaration
    (17) declaration -> . complex_declaration
    (18) declaration -> . declaration_pointer
    (19) declaration -> . acess_pointer
    (97) read_gets -> . ID ASSIGNMENT gets
    (98) create_puts -> . puts_const_string
    (99) create_puts -> . puts_expression
    (100) create_puts -> . puts_quotation
    (101) create_puts -> . puts_dquotation
    (37) fors -> . for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end
    (38) fors -> . for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end
    (39) whiles -> . while expression do bloco end
    (40) whiles -> . do bloco break if expression end
    (41) repeats -> . repeat CONST_INTERGER DPOINT bloco end SEMICOLON
    (42) unlesss -> . unless expression then bloco RBRACKET else bloco LBRACKET end
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (20) simple_declaration -> . matrix_declaration
    (21) simple_declaration -> . expression_declaration
    (24) complex_declaration -> . int_declaration
    (25) complex_declaration -> . float_declaration
    (26) complex_declaration -> . boolean_declaration
    (120) declaration_pointer -> . pointer ID
    (121) acess_pointer -> . pointer_acess ID
    (102) puts_const_string -> . puts CONST_STRING
    (103) puts_expression -> . puts expression_variable
    (104) puts_quotation -> . puts_string
    (105) puts_quotation -> . puts_expressionq
    (108) puts_dquotation -> . puts_string_dq
    (109) puts_dquotation -> . puts_expression_dq
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression
    (22) matrix_declaration -> . ID ASSIGNMENT matrix
    (23) expression_declaration -> . ID ASSIGNMENT expression
    (27) int_declaration -> . int ID ASSIGNMENT expression
    (28) float_declaration -> . float ID ASSIGNMENT expression
    (29) boolean_declaration -> . boolean ID ASSIGNMENT expression_declaration
    (112) pointer -> . ASTERISK pointer
    (113) pointer -> . ASTERISK
    (114) pointer_acess -> . and pointer_acess
    (115) pointer_acess -> . and
    (106) puts_string -> . puts QUOTATION CONST_STRING QUOTATION
    (107) puts_expressionq -> . puts QUOTATION expression_variable QUOTATION
    (110) puts_string_dq -> . puts DQUOTATION CONST_STRING DQUOTATION
    (111) puts_expression_dq -> . puts DQUOTATION expression_variable DQUOTATION
    (116) and -> . token_and
    (117) and -> . token_land
    (118) token_and -> . AND
    (119) token_land -> . LAND

    DEDENT          shift and go to state 162
    if              shift and go to state 13
    break           shift and go to state 18
    continue        shift and go to state 19
    ID              shift and go to state 20
    ASTERISK        shift and go to state 21
    LBRACKET        shift and go to state 22
    INDENT          shift and go to state 24
    for             shift and go to state 42
    while           shift and go to state 45
    do              shift and go to state 43
    repeat          shift and go to state 46
    unless          shift and go to state 47
    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    DSING           shift and go to state 69
    LAND            shift and go to state 23
    puts            shift and go to state 77
    NOT             shift and go to state 85
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83
    int             shift and go to state 86
    float           shift and go to state 87
    boolean         shift and go to state 88
    AND             shift and go to state 82

    statment                       shift and go to state 2
    conditional                    shift and go to state 3
    loops                          shift and go to state 4
    stop                           shift and go to state 5
    conti                          shift and go to state 6
    argumentlist                   shift and go to state 7
    bloco                          shift and go to state 8
    expression                     shift and go to state 9
    declaration                    shift and go to state 10
    read_gets                      shift and go to state 11
    create_puts                    shift and go to state 12
    fors                           shift and go to state 14
    whiles                         shift and go to state 15
    repeats                        shift and go to state 16
    unlesss                        shift and go to state 17
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    simple_declaration             shift and go to state 34
    complex_declaration            shift and go to state 35
    declaration_pointer            shift and go to state 36
    acess_pointer                  shift and go to state 37
    puts_const_string              shift and go to state 38
    puts_expression                shift and go to state 39
    puts_quotation                 shift and go to state 40
    puts_dquotation                shift and go to state 41
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64
    matrix_declaration             shift and go to state 70
    expression_declaration         shift and go to state 71
    int_declaration                shift and go to state 72
    float_declaration              shift and go to state 73
    boolean_declaration            shift and go to state 74
    pointer                        shift and go to state 75
    pointer_acess                  shift and go to state 76
    puts_string                    shift and go to state 78
    puts_expressionq               shift and go to state 79
    puts_string_dq                 shift and go to state 80
    puts_expression_dq             shift and go to state 81
    and                            shift and go to state 89
    token_and                      shift and go to state 90
    token_land                     shift and go to state 91

state 118

    (37) fors -> for expression_variable . LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end
    (50) expression -> expression_variable .

    LBRACKET        shift and go to state 163
    in              reduce using rule 50 (expression -> expression_variable .)
    AND             reduce using rule 50 (expression -> expression_variable .)
    OR              reduce using rule 50 (expression -> expression_variable .)
    GT              reduce using rule 50 (expression -> expression_variable .)
    GE              reduce using rule 50 (expression -> expression_variable .)
    LT              reduce using rule 50 (expression -> expression_variable .)
    LE              reduce using rule 50 (expression -> expression_variable .)
    MINUS           reduce using rule 50 (expression -> expression_variable .)
    PLUS            reduce using rule 50 (expression -> expression_variable .)
    ASTERISK        reduce using rule 50 (expression -> expression_variable .)
    DIVIDE          reduce using rule 50 (expression -> expression_variable .)
    MODULE          reduce using rule 50 (expression -> expression_variable .)
    EQUALS          reduce using rule 50 (expression -> expression_variable .)
    DIFFERENT       reduce using rule 50 (expression -> expression_variable .)


state 119

    (38) fors -> for expression . in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    in              shift and go to state 164
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104


state 120

    (40) whiles -> do bloco . break if expression end

    break           shift and go to state 165


state 121

    (39) whiles -> while expression . do bloco end
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    do              shift and go to state 166
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104


state 122

    (41) repeats -> repeat CONST_INTERGER . DPOINT bloco end SEMICOLON

    DPOINT          shift and go to state 167


state 123

    (42) unlesss -> unless expression . then bloco RBRACKET else bloco LBRACKET end
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    then            shift and go to state 168
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104


state 124

    (96) expression_variable -> DSING ID .

    AND             reduce using rule 96 (expression_variable -> DSING ID .)
    OR              reduce using rule 96 (expression_variable -> DSING ID .)
    GT              reduce using rule 96 (expression_variable -> DSING ID .)
    GE              reduce using rule 96 (expression_variable -> DSING ID .)
    LT              reduce using rule 96 (expression_variable -> DSING ID .)
    LE              reduce using rule 96 (expression_variable -> DSING ID .)
    MINUS           reduce using rule 96 (expression_variable -> DSING ID .)
    PLUS            reduce using rule 96 (expression_variable -> DSING ID .)
    ASTERISK        reduce using rule 96 (expression_variable -> DSING ID .)
    DIVIDE          reduce using rule 96 (expression_variable -> DSING ID .)
    MODULE          reduce using rule 96 (expression_variable -> DSING ID .)
    EQUALS          reduce using rule 96 (expression_variable -> DSING ID .)
    DIFFERENT       reduce using rule 96 (expression_variable -> DSING ID .)
    if              reduce using rule 96 (expression_variable -> DSING ID .)
    break           reduce using rule 96 (expression_variable -> DSING ID .)
    continue        reduce using rule 96 (expression_variable -> DSING ID .)
    ID              reduce using rule 96 (expression_variable -> DSING ID .)
    LBRACKET        reduce using rule 96 (expression_variable -> DSING ID .)
    INDENT          reduce using rule 96 (expression_variable -> DSING ID .)
    for             reduce using rule 96 (expression_variable -> DSING ID .)
    while           reduce using rule 96 (expression_variable -> DSING ID .)
    do              reduce using rule 96 (expression_variable -> DSING ID .)
    repeat          reduce using rule 96 (expression_variable -> DSING ID .)
    unless          reduce using rule 96 (expression_variable -> DSING ID .)
    CONST_REAL      reduce using rule 96 (expression_variable -> DSING ID .)
    CONST_INTERGER  reduce using rule 96 (expression_variable -> DSING ID .)
    CONST_STRING    reduce using rule 96 (expression_variable -> DSING ID .)
    True            reduce using rule 96 (expression_variable -> DSING ID .)
    False           reduce using rule 96 (expression_variable -> DSING ID .)
    DSING           reduce using rule 96 (expression_variable -> DSING ID .)
    LAND            reduce using rule 96 (expression_variable -> DSING ID .)
    puts            reduce using rule 96 (expression_variable -> DSING ID .)
    NOT             reduce using rule 96 (expression_variable -> DSING ID .)
    int             reduce using rule 96 (expression_variable -> DSING ID .)
    float           reduce using rule 96 (expression_variable -> DSING ID .)
    boolean         reduce using rule 96 (expression_variable -> DSING ID .)
    $end            reduce using rule 96 (expression_variable -> DSING ID .)
    begin           reduce using rule 96 (expression_variable -> DSING ID .)
    DEDENT          reduce using rule 96 (expression_variable -> DSING ID .)
    in              reduce using rule 96 (expression_variable -> DSING ID .)
    then            reduce using rule 96 (expression_variable -> DSING ID .)
    RBRACKET        reduce using rule 96 (expression_variable -> DSING ID .)
    COMMA           reduce using rule 96 (expression_variable -> DSING ID .)
    POINT           reduce using rule 96 (expression_variable -> DSING ID .)
    end             reduce using rule 96 (expression_variable -> DSING ID .)
    QUOTATION       reduce using rule 96 (expression_variable -> DSING ID .)
    DQUOTATION      reduce using rule 96 (expression_variable -> DSING ID .)


state 125

    (120) declaration_pointer -> pointer ID .

    if              reduce using rule 120 (declaration_pointer -> pointer ID .)
    break           reduce using rule 120 (declaration_pointer -> pointer ID .)
    continue        reduce using rule 120 (declaration_pointer -> pointer ID .)
    ID              reduce using rule 120 (declaration_pointer -> pointer ID .)
    ASTERISK        reduce using rule 120 (declaration_pointer -> pointer ID .)
    LBRACKET        reduce using rule 120 (declaration_pointer -> pointer ID .)
    INDENT          reduce using rule 120 (declaration_pointer -> pointer ID .)
    for             reduce using rule 120 (declaration_pointer -> pointer ID .)
    while           reduce using rule 120 (declaration_pointer -> pointer ID .)
    do              reduce using rule 120 (declaration_pointer -> pointer ID .)
    repeat          reduce using rule 120 (declaration_pointer -> pointer ID .)
    unless          reduce using rule 120 (declaration_pointer -> pointer ID .)
    CONST_REAL      reduce using rule 120 (declaration_pointer -> pointer ID .)
    CONST_INTERGER  reduce using rule 120 (declaration_pointer -> pointer ID .)
    CONST_STRING    reduce using rule 120 (declaration_pointer -> pointer ID .)
    True            reduce using rule 120 (declaration_pointer -> pointer ID .)
    False           reduce using rule 120 (declaration_pointer -> pointer ID .)
    DSING           reduce using rule 120 (declaration_pointer -> pointer ID .)
    LAND            reduce using rule 120 (declaration_pointer -> pointer ID .)
    puts            reduce using rule 120 (declaration_pointer -> pointer ID .)
    NOT             reduce using rule 120 (declaration_pointer -> pointer ID .)
    PLUS            reduce using rule 120 (declaration_pointer -> pointer ID .)
    MINUS           reduce using rule 120 (declaration_pointer -> pointer ID .)
    int             reduce using rule 120 (declaration_pointer -> pointer ID .)
    float           reduce using rule 120 (declaration_pointer -> pointer ID .)
    boolean         reduce using rule 120 (declaration_pointer -> pointer ID .)
    AND             reduce using rule 120 (declaration_pointer -> pointer ID .)
    $end            reduce using rule 120 (declaration_pointer -> pointer ID .)
    DEDENT          reduce using rule 120 (declaration_pointer -> pointer ID .)


state 126

    (121) acess_pointer -> pointer_acess ID .

    if              reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    break           reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    continue        reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    ID              reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    ASTERISK        reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    LBRACKET        reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    INDENT          reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    for             reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    while           reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    do              reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    repeat          reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    unless          reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    CONST_REAL      reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    CONST_INTERGER  reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    CONST_STRING    reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    True            reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    False           reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    DSING           reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    LAND            reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    puts            reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    NOT             reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    PLUS            reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    MINUS           reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    int             reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    float           reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    boolean         reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    AND             reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    $end            reduce using rule 121 (acess_pointer -> pointer_acess ID .)
    DEDENT          reduce using rule 121 (acess_pointer -> pointer_acess ID .)


state 127

    (102) puts_const_string -> puts CONST_STRING .

    if              reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    break           reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    continue        reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    ID              reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    ASTERISK        reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    LBRACKET        reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    INDENT          reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    for             reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    while           reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    do              reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    repeat          reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    unless          reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    CONST_REAL      reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    CONST_INTERGER  reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    CONST_STRING    reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    True            reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    False           reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    DSING           reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    LAND            reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    puts            reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    NOT             reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    PLUS            reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    MINUS           reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    int             reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    float           reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    boolean         reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    AND             reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    $end            reduce using rule 102 (puts_const_string -> puts CONST_STRING .)
    DEDENT          reduce using rule 102 (puts_const_string -> puts CONST_STRING .)


state 128

    (103) puts_expression -> puts expression_variable .

    if              reduce using rule 103 (puts_expression -> puts expression_variable .)
    break           reduce using rule 103 (puts_expression -> puts expression_variable .)
    continue        reduce using rule 103 (puts_expression -> puts expression_variable .)
    ID              reduce using rule 103 (puts_expression -> puts expression_variable .)
    ASTERISK        reduce using rule 103 (puts_expression -> puts expression_variable .)
    LBRACKET        reduce using rule 103 (puts_expression -> puts expression_variable .)
    INDENT          reduce using rule 103 (puts_expression -> puts expression_variable .)
    for             reduce using rule 103 (puts_expression -> puts expression_variable .)
    while           reduce using rule 103 (puts_expression -> puts expression_variable .)
    do              reduce using rule 103 (puts_expression -> puts expression_variable .)
    repeat          reduce using rule 103 (puts_expression -> puts expression_variable .)
    unless          reduce using rule 103 (puts_expression -> puts expression_variable .)
    CONST_REAL      reduce using rule 103 (puts_expression -> puts expression_variable .)
    CONST_INTERGER  reduce using rule 103 (puts_expression -> puts expression_variable .)
    CONST_STRING    reduce using rule 103 (puts_expression -> puts expression_variable .)
    True            reduce using rule 103 (puts_expression -> puts expression_variable .)
    False           reduce using rule 103 (puts_expression -> puts expression_variable .)
    DSING           reduce using rule 103 (puts_expression -> puts expression_variable .)
    LAND            reduce using rule 103 (puts_expression -> puts expression_variable .)
    puts            reduce using rule 103 (puts_expression -> puts expression_variable .)
    NOT             reduce using rule 103 (puts_expression -> puts expression_variable .)
    PLUS            reduce using rule 103 (puts_expression -> puts expression_variable .)
    MINUS           reduce using rule 103 (puts_expression -> puts expression_variable .)
    int             reduce using rule 103 (puts_expression -> puts expression_variable .)
    float           reduce using rule 103 (puts_expression -> puts expression_variable .)
    boolean         reduce using rule 103 (puts_expression -> puts expression_variable .)
    AND             reduce using rule 103 (puts_expression -> puts expression_variable .)
    $end            reduce using rule 103 (puts_expression -> puts expression_variable .)
    DEDENT          reduce using rule 103 (puts_expression -> puts expression_variable .)


state 129

    (106) puts_string -> puts QUOTATION . CONST_STRING QUOTATION
    (107) puts_expressionq -> puts QUOTATION . expression_variable QUOTATION
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID

    CONST_STRING    shift and go to state 169
    ID              shift and go to state 106
    DSING           shift and go to state 69

    expression_variable            shift and go to state 170

state 130

    (110) puts_string_dq -> puts DQUOTATION . CONST_STRING DQUOTATION
    (111) puts_expression_dq -> puts DQUOTATION . expression_variable DQUOTATION
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID

    CONST_STRING    shift and go to state 171
    ID              shift and go to state 106
    DSING           shift and go to state 69

    expression_variable            shift and go to state 172

state 131

    (69) unitary_minus -> MINUS expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 69 (unitary_minus -> MINUS expression .)
    OR              reduce using rule 69 (unitary_minus -> MINUS expression .)
    GT              reduce using rule 69 (unitary_minus -> MINUS expression .)
    GE              reduce using rule 69 (unitary_minus -> MINUS expression .)
    LT              reduce using rule 69 (unitary_minus -> MINUS expression .)
    LE              reduce using rule 69 (unitary_minus -> MINUS expression .)
    MINUS           reduce using rule 69 (unitary_minus -> MINUS expression .)
    PLUS            reduce using rule 69 (unitary_minus -> MINUS expression .)
    EQUALS          reduce using rule 69 (unitary_minus -> MINUS expression .)
    DIFFERENT       reduce using rule 69 (unitary_minus -> MINUS expression .)
    if              reduce using rule 69 (unitary_minus -> MINUS expression .)
    break           reduce using rule 69 (unitary_minus -> MINUS expression .)
    continue        reduce using rule 69 (unitary_minus -> MINUS expression .)
    ID              reduce using rule 69 (unitary_minus -> MINUS expression .)
    LBRACKET        reduce using rule 69 (unitary_minus -> MINUS expression .)
    INDENT          reduce using rule 69 (unitary_minus -> MINUS expression .)
    for             reduce using rule 69 (unitary_minus -> MINUS expression .)
    while           reduce using rule 69 (unitary_minus -> MINUS expression .)
    do              reduce using rule 69 (unitary_minus -> MINUS expression .)
    repeat          reduce using rule 69 (unitary_minus -> MINUS expression .)
    unless          reduce using rule 69 (unitary_minus -> MINUS expression .)
    CONST_REAL      reduce using rule 69 (unitary_minus -> MINUS expression .)
    CONST_INTERGER  reduce using rule 69 (unitary_minus -> MINUS expression .)
    CONST_STRING    reduce using rule 69 (unitary_minus -> MINUS expression .)
    True            reduce using rule 69 (unitary_minus -> MINUS expression .)
    False           reduce using rule 69 (unitary_minus -> MINUS expression .)
    DSING           reduce using rule 69 (unitary_minus -> MINUS expression .)
    LAND            reduce using rule 69 (unitary_minus -> MINUS expression .)
    puts            reduce using rule 69 (unitary_minus -> MINUS expression .)
    NOT             reduce using rule 69 (unitary_minus -> MINUS expression .)
    int             reduce using rule 69 (unitary_minus -> MINUS expression .)
    float           reduce using rule 69 (unitary_minus -> MINUS expression .)
    boolean         reduce using rule 69 (unitary_minus -> MINUS expression .)
    $end            reduce using rule 69 (unitary_minus -> MINUS expression .)
    begin           reduce using rule 69 (unitary_minus -> MINUS expression .)
    DEDENT          reduce using rule 69 (unitary_minus -> MINUS expression .)
    in              reduce using rule 69 (unitary_minus -> MINUS expression .)
    then            reduce using rule 69 (unitary_minus -> MINUS expression .)
    RBRACKET        reduce using rule 69 (unitary_minus -> MINUS expression .)
    COMMA           reduce using rule 69 (unitary_minus -> MINUS expression .)
    POINT           reduce using rule 69 (unitary_minus -> MINUS expression .)
    end             reduce using rule 69 (unitary_minus -> MINUS expression .)
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! ASTERISK        [ reduce using rule 69 (unitary_minus -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 69 (unitary_minus -> MINUS expression .) ]
  ! MODULE          [ reduce using rule 69 (unitary_minus -> MINUS expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 132

    (70) unitary_plus -> PLUS expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 70 (unitary_plus -> PLUS expression .)
    OR              reduce using rule 70 (unitary_plus -> PLUS expression .)
    GT              reduce using rule 70 (unitary_plus -> PLUS expression .)
    GE              reduce using rule 70 (unitary_plus -> PLUS expression .)
    LT              reduce using rule 70 (unitary_plus -> PLUS expression .)
    LE              reduce using rule 70 (unitary_plus -> PLUS expression .)
    MINUS           reduce using rule 70 (unitary_plus -> PLUS expression .)
    PLUS            reduce using rule 70 (unitary_plus -> PLUS expression .)
    EQUALS          reduce using rule 70 (unitary_plus -> PLUS expression .)
    DIFFERENT       reduce using rule 70 (unitary_plus -> PLUS expression .)
    if              reduce using rule 70 (unitary_plus -> PLUS expression .)
    break           reduce using rule 70 (unitary_plus -> PLUS expression .)
    continue        reduce using rule 70 (unitary_plus -> PLUS expression .)
    ID              reduce using rule 70 (unitary_plus -> PLUS expression .)
    LBRACKET        reduce using rule 70 (unitary_plus -> PLUS expression .)
    INDENT          reduce using rule 70 (unitary_plus -> PLUS expression .)
    for             reduce using rule 70 (unitary_plus -> PLUS expression .)
    while           reduce using rule 70 (unitary_plus -> PLUS expression .)
    do              reduce using rule 70 (unitary_plus -> PLUS expression .)
    repeat          reduce using rule 70 (unitary_plus -> PLUS expression .)
    unless          reduce using rule 70 (unitary_plus -> PLUS expression .)
    CONST_REAL      reduce using rule 70 (unitary_plus -> PLUS expression .)
    CONST_INTERGER  reduce using rule 70 (unitary_plus -> PLUS expression .)
    CONST_STRING    reduce using rule 70 (unitary_plus -> PLUS expression .)
    True            reduce using rule 70 (unitary_plus -> PLUS expression .)
    False           reduce using rule 70 (unitary_plus -> PLUS expression .)
    DSING           reduce using rule 70 (unitary_plus -> PLUS expression .)
    LAND            reduce using rule 70 (unitary_plus -> PLUS expression .)
    puts            reduce using rule 70 (unitary_plus -> PLUS expression .)
    NOT             reduce using rule 70 (unitary_plus -> PLUS expression .)
    int             reduce using rule 70 (unitary_plus -> PLUS expression .)
    float           reduce using rule 70 (unitary_plus -> PLUS expression .)
    boolean         reduce using rule 70 (unitary_plus -> PLUS expression .)
    $end            reduce using rule 70 (unitary_plus -> PLUS expression .)
    begin           reduce using rule 70 (unitary_plus -> PLUS expression .)
    DEDENT          reduce using rule 70 (unitary_plus -> PLUS expression .)
    in              reduce using rule 70 (unitary_plus -> PLUS expression .)
    then            reduce using rule 70 (unitary_plus -> PLUS expression .)
    RBRACKET        reduce using rule 70 (unitary_plus -> PLUS expression .)
    COMMA           reduce using rule 70 (unitary_plus -> PLUS expression .)
    POINT           reduce using rule 70 (unitary_plus -> PLUS expression .)
    end             reduce using rule 70 (unitary_plus -> PLUS expression .)
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! ASTERISK        [ reduce using rule 70 (unitary_plus -> PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 70 (unitary_plus -> PLUS expression .) ]
  ! MODULE          [ reduce using rule 70 (unitary_plus -> PLUS expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 133

    (72) unitary_not -> NOT expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 72 (unitary_not -> NOT expression .)
    OR              reduce using rule 72 (unitary_not -> NOT expression .)
    GT              reduce using rule 72 (unitary_not -> NOT expression .)
    GE              reduce using rule 72 (unitary_not -> NOT expression .)
    LT              reduce using rule 72 (unitary_not -> NOT expression .)
    LE              reduce using rule 72 (unitary_not -> NOT expression .)
    MINUS           reduce using rule 72 (unitary_not -> NOT expression .)
    PLUS            reduce using rule 72 (unitary_not -> NOT expression .)
    ASTERISK        reduce using rule 72 (unitary_not -> NOT expression .)
    DIVIDE          reduce using rule 72 (unitary_not -> NOT expression .)
    MODULE          reduce using rule 72 (unitary_not -> NOT expression .)
    EQUALS          reduce using rule 72 (unitary_not -> NOT expression .)
    DIFFERENT       reduce using rule 72 (unitary_not -> NOT expression .)
    if              reduce using rule 72 (unitary_not -> NOT expression .)
    break           reduce using rule 72 (unitary_not -> NOT expression .)
    continue        reduce using rule 72 (unitary_not -> NOT expression .)
    ID              reduce using rule 72 (unitary_not -> NOT expression .)
    LBRACKET        reduce using rule 72 (unitary_not -> NOT expression .)
    INDENT          reduce using rule 72 (unitary_not -> NOT expression .)
    for             reduce using rule 72 (unitary_not -> NOT expression .)
    while           reduce using rule 72 (unitary_not -> NOT expression .)
    do              reduce using rule 72 (unitary_not -> NOT expression .)
    repeat          reduce using rule 72 (unitary_not -> NOT expression .)
    unless          reduce using rule 72 (unitary_not -> NOT expression .)
    CONST_REAL      reduce using rule 72 (unitary_not -> NOT expression .)
    CONST_INTERGER  reduce using rule 72 (unitary_not -> NOT expression .)
    CONST_STRING    reduce using rule 72 (unitary_not -> NOT expression .)
    True            reduce using rule 72 (unitary_not -> NOT expression .)
    False           reduce using rule 72 (unitary_not -> NOT expression .)
    DSING           reduce using rule 72 (unitary_not -> NOT expression .)
    LAND            reduce using rule 72 (unitary_not -> NOT expression .)
    puts            reduce using rule 72 (unitary_not -> NOT expression .)
    NOT             reduce using rule 72 (unitary_not -> NOT expression .)
    int             reduce using rule 72 (unitary_not -> NOT expression .)
    float           reduce using rule 72 (unitary_not -> NOT expression .)
    boolean         reduce using rule 72 (unitary_not -> NOT expression .)
    $end            reduce using rule 72 (unitary_not -> NOT expression .)
    begin           reduce using rule 72 (unitary_not -> NOT expression .)
    DEDENT          reduce using rule 72 (unitary_not -> NOT expression .)
    in              reduce using rule 72 (unitary_not -> NOT expression .)
    then            reduce using rule 72 (unitary_not -> NOT expression .)
    RBRACKET        reduce using rule 72 (unitary_not -> NOT expression .)
    COMMA           reduce using rule 72 (unitary_not -> NOT expression .)
    POINT           reduce using rule 72 (unitary_not -> NOT expression .)
    end             reduce using rule 72 (unitary_not -> NOT expression .)

  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! ASTERISK        [ shift and go to state 100 ]
  ! DIVIDE          [ shift and go to state 101 ]
  ! MODULE          [ shift and go to state 102 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 134

    (27) int_declaration -> int ID . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 173


state 135

    (28) float_declaration -> float ID . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 174


state 136

    (29) boolean_declaration -> boolean ID . ASSIGNMENT expression_declaration

    ASSIGNMENT      shift and go to state 175


state 137

    (114) pointer_acess -> and pointer_acess .

    ID              reduce using rule 114 (pointer_acess -> and pointer_acess .)


state 138

    (119) token_land -> LAND .

    AND             reduce using rule 119 (token_land -> LAND .)
    LAND            reduce using rule 119 (token_land -> LAND .)
    ID              reduce using rule 119 (token_land -> LAND .)


state 139

    (73) expression_and -> expression AND expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 73 (expression_and -> expression AND expression .)
    OR              reduce using rule 73 (expression_and -> expression AND expression .)
    if              reduce using rule 73 (expression_and -> expression AND expression .)
    break           reduce using rule 73 (expression_and -> expression AND expression .)
    continue        reduce using rule 73 (expression_and -> expression AND expression .)
    ID              reduce using rule 73 (expression_and -> expression AND expression .)
    LBRACKET        reduce using rule 73 (expression_and -> expression AND expression .)
    INDENT          reduce using rule 73 (expression_and -> expression AND expression .)
    for             reduce using rule 73 (expression_and -> expression AND expression .)
    while           reduce using rule 73 (expression_and -> expression AND expression .)
    do              reduce using rule 73 (expression_and -> expression AND expression .)
    repeat          reduce using rule 73 (expression_and -> expression AND expression .)
    unless          reduce using rule 73 (expression_and -> expression AND expression .)
    CONST_REAL      reduce using rule 73 (expression_and -> expression AND expression .)
    CONST_INTERGER  reduce using rule 73 (expression_and -> expression AND expression .)
    CONST_STRING    reduce using rule 73 (expression_and -> expression AND expression .)
    True            reduce using rule 73 (expression_and -> expression AND expression .)
    False           reduce using rule 73 (expression_and -> expression AND expression .)
    DSING           reduce using rule 73 (expression_and -> expression AND expression .)
    LAND            reduce using rule 73 (expression_and -> expression AND expression .)
    puts            reduce using rule 73 (expression_and -> expression AND expression .)
    NOT             reduce using rule 73 (expression_and -> expression AND expression .)
    int             reduce using rule 73 (expression_and -> expression AND expression .)
    float           reduce using rule 73 (expression_and -> expression AND expression .)
    boolean         reduce using rule 73 (expression_and -> expression AND expression .)
    $end            reduce using rule 73 (expression_and -> expression AND expression .)
    begin           reduce using rule 73 (expression_and -> expression AND expression .)
    DEDENT          reduce using rule 73 (expression_and -> expression AND expression .)
    in              reduce using rule 73 (expression_and -> expression AND expression .)
    then            reduce using rule 73 (expression_and -> expression AND expression .)
    RBRACKET        reduce using rule 73 (expression_and -> expression AND expression .)
    COMMA           reduce using rule 73 (expression_and -> expression AND expression .)
    POINT           reduce using rule 73 (expression_and -> expression AND expression .)
    end             reduce using rule 73 (expression_and -> expression AND expression .)
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104

  ! GT              [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! GE              [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! LT              [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! LE              [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! PLUS            [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! ASTERISK        [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! MODULE          [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! EQUALS          [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! DIFFERENT       [ reduce using rule 73 (expression_and -> expression AND expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]


state 140

    (74) expression_or -> expression OR expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    OR              reduce using rule 74 (expression_or -> expression OR expression .)
    if              reduce using rule 74 (expression_or -> expression OR expression .)
    break           reduce using rule 74 (expression_or -> expression OR expression .)
    continue        reduce using rule 74 (expression_or -> expression OR expression .)
    ID              reduce using rule 74 (expression_or -> expression OR expression .)
    LBRACKET        reduce using rule 74 (expression_or -> expression OR expression .)
    INDENT          reduce using rule 74 (expression_or -> expression OR expression .)
    for             reduce using rule 74 (expression_or -> expression OR expression .)
    while           reduce using rule 74 (expression_or -> expression OR expression .)
    do              reduce using rule 74 (expression_or -> expression OR expression .)
    repeat          reduce using rule 74 (expression_or -> expression OR expression .)
    unless          reduce using rule 74 (expression_or -> expression OR expression .)
    CONST_REAL      reduce using rule 74 (expression_or -> expression OR expression .)
    CONST_INTERGER  reduce using rule 74 (expression_or -> expression OR expression .)
    CONST_STRING    reduce using rule 74 (expression_or -> expression OR expression .)
    True            reduce using rule 74 (expression_or -> expression OR expression .)
    False           reduce using rule 74 (expression_or -> expression OR expression .)
    DSING           reduce using rule 74 (expression_or -> expression OR expression .)
    LAND            reduce using rule 74 (expression_or -> expression OR expression .)
    puts            reduce using rule 74 (expression_or -> expression OR expression .)
    NOT             reduce using rule 74 (expression_or -> expression OR expression .)
    int             reduce using rule 74 (expression_or -> expression OR expression .)
    float           reduce using rule 74 (expression_or -> expression OR expression .)
    boolean         reduce using rule 74 (expression_or -> expression OR expression .)
    $end            reduce using rule 74 (expression_or -> expression OR expression .)
    begin           reduce using rule 74 (expression_or -> expression OR expression .)
    DEDENT          reduce using rule 74 (expression_or -> expression OR expression .)
    in              reduce using rule 74 (expression_or -> expression OR expression .)
    then            reduce using rule 74 (expression_or -> expression OR expression .)
    RBRACKET        reduce using rule 74 (expression_or -> expression OR expression .)
    COMMA           reduce using rule 74 (expression_or -> expression OR expression .)
    POINT           reduce using rule 74 (expression_or -> expression OR expression .)
    end             reduce using rule 74 (expression_or -> expression OR expression .)
    AND             shift and go to state 92
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104

  ! AND             [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! GT              [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! GE              [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! LT              [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! LE              [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! PLUS            [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! ASTERISK        [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! MODULE          [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! EQUALS          [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! DIFFERENT       [ reduce using rule 74 (expression_or -> expression OR expression .) ]
  ! OR              [ shift and go to state 93 ]


state 141

    (75) expression_gt -> expression GT expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 75 (expression_gt -> expression GT expression .)
    OR              reduce using rule 75 (expression_gt -> expression GT expression .)
    GT              reduce using rule 75 (expression_gt -> expression GT expression .)
    GE              reduce using rule 75 (expression_gt -> expression GT expression .)
    LT              reduce using rule 75 (expression_gt -> expression GT expression .)
    LE              reduce using rule 75 (expression_gt -> expression GT expression .)
    EQUALS          reduce using rule 75 (expression_gt -> expression GT expression .)
    DIFFERENT       reduce using rule 75 (expression_gt -> expression GT expression .)
    if              reduce using rule 75 (expression_gt -> expression GT expression .)
    break           reduce using rule 75 (expression_gt -> expression GT expression .)
    continue        reduce using rule 75 (expression_gt -> expression GT expression .)
    ID              reduce using rule 75 (expression_gt -> expression GT expression .)
    LBRACKET        reduce using rule 75 (expression_gt -> expression GT expression .)
    INDENT          reduce using rule 75 (expression_gt -> expression GT expression .)
    for             reduce using rule 75 (expression_gt -> expression GT expression .)
    while           reduce using rule 75 (expression_gt -> expression GT expression .)
    do              reduce using rule 75 (expression_gt -> expression GT expression .)
    repeat          reduce using rule 75 (expression_gt -> expression GT expression .)
    unless          reduce using rule 75 (expression_gt -> expression GT expression .)
    CONST_REAL      reduce using rule 75 (expression_gt -> expression GT expression .)
    CONST_INTERGER  reduce using rule 75 (expression_gt -> expression GT expression .)
    CONST_STRING    reduce using rule 75 (expression_gt -> expression GT expression .)
    True            reduce using rule 75 (expression_gt -> expression GT expression .)
    False           reduce using rule 75 (expression_gt -> expression GT expression .)
    DSING           reduce using rule 75 (expression_gt -> expression GT expression .)
    LAND            reduce using rule 75 (expression_gt -> expression GT expression .)
    puts            reduce using rule 75 (expression_gt -> expression GT expression .)
    NOT             reduce using rule 75 (expression_gt -> expression GT expression .)
    int             reduce using rule 75 (expression_gt -> expression GT expression .)
    float           reduce using rule 75 (expression_gt -> expression GT expression .)
    boolean         reduce using rule 75 (expression_gt -> expression GT expression .)
    $end            reduce using rule 75 (expression_gt -> expression GT expression .)
    begin           reduce using rule 75 (expression_gt -> expression GT expression .)
    DEDENT          reduce using rule 75 (expression_gt -> expression GT expression .)
    in              reduce using rule 75 (expression_gt -> expression GT expression .)
    then            reduce using rule 75 (expression_gt -> expression GT expression .)
    RBRACKET        reduce using rule 75 (expression_gt -> expression GT expression .)
    COMMA           reduce using rule 75 (expression_gt -> expression GT expression .)
    POINT           reduce using rule 75 (expression_gt -> expression GT expression .)
    end             reduce using rule 75 (expression_gt -> expression GT expression .)
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! MINUS           [ reduce using rule 75 (expression_gt -> expression GT expression .) ]
  ! PLUS            [ reduce using rule 75 (expression_gt -> expression GT expression .) ]
  ! ASTERISK        [ reduce using rule 75 (expression_gt -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 75 (expression_gt -> expression GT expression .) ]
  ! MODULE          [ reduce using rule 75 (expression_gt -> expression GT expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 142

    (76) expression_ge -> expression GE expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 76 (expression_ge -> expression GE expression .)
    OR              reduce using rule 76 (expression_ge -> expression GE expression .)
    GT              reduce using rule 76 (expression_ge -> expression GE expression .)
    GE              reduce using rule 76 (expression_ge -> expression GE expression .)
    LT              reduce using rule 76 (expression_ge -> expression GE expression .)
    LE              reduce using rule 76 (expression_ge -> expression GE expression .)
    EQUALS          reduce using rule 76 (expression_ge -> expression GE expression .)
    DIFFERENT       reduce using rule 76 (expression_ge -> expression GE expression .)
    if              reduce using rule 76 (expression_ge -> expression GE expression .)
    break           reduce using rule 76 (expression_ge -> expression GE expression .)
    continue        reduce using rule 76 (expression_ge -> expression GE expression .)
    ID              reduce using rule 76 (expression_ge -> expression GE expression .)
    LBRACKET        reduce using rule 76 (expression_ge -> expression GE expression .)
    INDENT          reduce using rule 76 (expression_ge -> expression GE expression .)
    for             reduce using rule 76 (expression_ge -> expression GE expression .)
    while           reduce using rule 76 (expression_ge -> expression GE expression .)
    do              reduce using rule 76 (expression_ge -> expression GE expression .)
    repeat          reduce using rule 76 (expression_ge -> expression GE expression .)
    unless          reduce using rule 76 (expression_ge -> expression GE expression .)
    CONST_REAL      reduce using rule 76 (expression_ge -> expression GE expression .)
    CONST_INTERGER  reduce using rule 76 (expression_ge -> expression GE expression .)
    CONST_STRING    reduce using rule 76 (expression_ge -> expression GE expression .)
    True            reduce using rule 76 (expression_ge -> expression GE expression .)
    False           reduce using rule 76 (expression_ge -> expression GE expression .)
    DSING           reduce using rule 76 (expression_ge -> expression GE expression .)
    LAND            reduce using rule 76 (expression_ge -> expression GE expression .)
    puts            reduce using rule 76 (expression_ge -> expression GE expression .)
    NOT             reduce using rule 76 (expression_ge -> expression GE expression .)
    int             reduce using rule 76 (expression_ge -> expression GE expression .)
    float           reduce using rule 76 (expression_ge -> expression GE expression .)
    boolean         reduce using rule 76 (expression_ge -> expression GE expression .)
    $end            reduce using rule 76 (expression_ge -> expression GE expression .)
    begin           reduce using rule 76 (expression_ge -> expression GE expression .)
    DEDENT          reduce using rule 76 (expression_ge -> expression GE expression .)
    in              reduce using rule 76 (expression_ge -> expression GE expression .)
    then            reduce using rule 76 (expression_ge -> expression GE expression .)
    RBRACKET        reduce using rule 76 (expression_ge -> expression GE expression .)
    COMMA           reduce using rule 76 (expression_ge -> expression GE expression .)
    POINT           reduce using rule 76 (expression_ge -> expression GE expression .)
    end             reduce using rule 76 (expression_ge -> expression GE expression .)
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! MINUS           [ reduce using rule 76 (expression_ge -> expression GE expression .) ]
  ! PLUS            [ reduce using rule 76 (expression_ge -> expression GE expression .) ]
  ! ASTERISK        [ reduce using rule 76 (expression_ge -> expression GE expression .) ]
  ! DIVIDE          [ reduce using rule 76 (expression_ge -> expression GE expression .) ]
  ! MODULE          [ reduce using rule 76 (expression_ge -> expression GE expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 143

    (77) expression_lt -> expression LT expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 77 (expression_lt -> expression LT expression .)
    OR              reduce using rule 77 (expression_lt -> expression LT expression .)
    GT              reduce using rule 77 (expression_lt -> expression LT expression .)
    GE              reduce using rule 77 (expression_lt -> expression LT expression .)
    LT              reduce using rule 77 (expression_lt -> expression LT expression .)
    LE              reduce using rule 77 (expression_lt -> expression LT expression .)
    EQUALS          reduce using rule 77 (expression_lt -> expression LT expression .)
    DIFFERENT       reduce using rule 77 (expression_lt -> expression LT expression .)
    if              reduce using rule 77 (expression_lt -> expression LT expression .)
    break           reduce using rule 77 (expression_lt -> expression LT expression .)
    continue        reduce using rule 77 (expression_lt -> expression LT expression .)
    ID              reduce using rule 77 (expression_lt -> expression LT expression .)
    LBRACKET        reduce using rule 77 (expression_lt -> expression LT expression .)
    INDENT          reduce using rule 77 (expression_lt -> expression LT expression .)
    for             reduce using rule 77 (expression_lt -> expression LT expression .)
    while           reduce using rule 77 (expression_lt -> expression LT expression .)
    do              reduce using rule 77 (expression_lt -> expression LT expression .)
    repeat          reduce using rule 77 (expression_lt -> expression LT expression .)
    unless          reduce using rule 77 (expression_lt -> expression LT expression .)
    CONST_REAL      reduce using rule 77 (expression_lt -> expression LT expression .)
    CONST_INTERGER  reduce using rule 77 (expression_lt -> expression LT expression .)
    CONST_STRING    reduce using rule 77 (expression_lt -> expression LT expression .)
    True            reduce using rule 77 (expression_lt -> expression LT expression .)
    False           reduce using rule 77 (expression_lt -> expression LT expression .)
    DSING           reduce using rule 77 (expression_lt -> expression LT expression .)
    LAND            reduce using rule 77 (expression_lt -> expression LT expression .)
    puts            reduce using rule 77 (expression_lt -> expression LT expression .)
    NOT             reduce using rule 77 (expression_lt -> expression LT expression .)
    int             reduce using rule 77 (expression_lt -> expression LT expression .)
    float           reduce using rule 77 (expression_lt -> expression LT expression .)
    boolean         reduce using rule 77 (expression_lt -> expression LT expression .)
    $end            reduce using rule 77 (expression_lt -> expression LT expression .)
    begin           reduce using rule 77 (expression_lt -> expression LT expression .)
    DEDENT          reduce using rule 77 (expression_lt -> expression LT expression .)
    in              reduce using rule 77 (expression_lt -> expression LT expression .)
    then            reduce using rule 77 (expression_lt -> expression LT expression .)
    RBRACKET        reduce using rule 77 (expression_lt -> expression LT expression .)
    COMMA           reduce using rule 77 (expression_lt -> expression LT expression .)
    POINT           reduce using rule 77 (expression_lt -> expression LT expression .)
    end             reduce using rule 77 (expression_lt -> expression LT expression .)
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! MINUS           [ reduce using rule 77 (expression_lt -> expression LT expression .) ]
  ! PLUS            [ reduce using rule 77 (expression_lt -> expression LT expression .) ]
  ! ASTERISK        [ reduce using rule 77 (expression_lt -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 77 (expression_lt -> expression LT expression .) ]
  ! MODULE          [ reduce using rule 77 (expression_lt -> expression LT expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 144

    (78) expression_le -> expression LE expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 78 (expression_le -> expression LE expression .)
    OR              reduce using rule 78 (expression_le -> expression LE expression .)
    GT              reduce using rule 78 (expression_le -> expression LE expression .)
    GE              reduce using rule 78 (expression_le -> expression LE expression .)
    LT              reduce using rule 78 (expression_le -> expression LE expression .)
    LE              reduce using rule 78 (expression_le -> expression LE expression .)
    EQUALS          reduce using rule 78 (expression_le -> expression LE expression .)
    DIFFERENT       reduce using rule 78 (expression_le -> expression LE expression .)
    if              reduce using rule 78 (expression_le -> expression LE expression .)
    break           reduce using rule 78 (expression_le -> expression LE expression .)
    continue        reduce using rule 78 (expression_le -> expression LE expression .)
    ID              reduce using rule 78 (expression_le -> expression LE expression .)
    LBRACKET        reduce using rule 78 (expression_le -> expression LE expression .)
    INDENT          reduce using rule 78 (expression_le -> expression LE expression .)
    for             reduce using rule 78 (expression_le -> expression LE expression .)
    while           reduce using rule 78 (expression_le -> expression LE expression .)
    do              reduce using rule 78 (expression_le -> expression LE expression .)
    repeat          reduce using rule 78 (expression_le -> expression LE expression .)
    unless          reduce using rule 78 (expression_le -> expression LE expression .)
    CONST_REAL      reduce using rule 78 (expression_le -> expression LE expression .)
    CONST_INTERGER  reduce using rule 78 (expression_le -> expression LE expression .)
    CONST_STRING    reduce using rule 78 (expression_le -> expression LE expression .)
    True            reduce using rule 78 (expression_le -> expression LE expression .)
    False           reduce using rule 78 (expression_le -> expression LE expression .)
    DSING           reduce using rule 78 (expression_le -> expression LE expression .)
    LAND            reduce using rule 78 (expression_le -> expression LE expression .)
    puts            reduce using rule 78 (expression_le -> expression LE expression .)
    NOT             reduce using rule 78 (expression_le -> expression LE expression .)
    int             reduce using rule 78 (expression_le -> expression LE expression .)
    float           reduce using rule 78 (expression_le -> expression LE expression .)
    boolean         reduce using rule 78 (expression_le -> expression LE expression .)
    $end            reduce using rule 78 (expression_le -> expression LE expression .)
    begin           reduce using rule 78 (expression_le -> expression LE expression .)
    DEDENT          reduce using rule 78 (expression_le -> expression LE expression .)
    in              reduce using rule 78 (expression_le -> expression LE expression .)
    then            reduce using rule 78 (expression_le -> expression LE expression .)
    RBRACKET        reduce using rule 78 (expression_le -> expression LE expression .)
    COMMA           reduce using rule 78 (expression_le -> expression LE expression .)
    POINT           reduce using rule 78 (expression_le -> expression LE expression .)
    end             reduce using rule 78 (expression_le -> expression LE expression .)
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! MINUS           [ reduce using rule 78 (expression_le -> expression LE expression .) ]
  ! PLUS            [ reduce using rule 78 (expression_le -> expression LE expression .) ]
  ! ASTERISK        [ reduce using rule 78 (expression_le -> expression LE expression .) ]
  ! DIVIDE          [ reduce using rule 78 (expression_le -> expression LE expression .) ]
  ! MODULE          [ reduce using rule 78 (expression_le -> expression LE expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 145

    (88) expression_minus -> expression MINUS expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 88 (expression_minus -> expression MINUS expression .)
    OR              reduce using rule 88 (expression_minus -> expression MINUS expression .)
    GT              reduce using rule 88 (expression_minus -> expression MINUS expression .)
    GE              reduce using rule 88 (expression_minus -> expression MINUS expression .)
    LT              reduce using rule 88 (expression_minus -> expression MINUS expression .)
    LE              reduce using rule 88 (expression_minus -> expression MINUS expression .)
    MINUS           reduce using rule 88 (expression_minus -> expression MINUS expression .)
    PLUS            reduce using rule 88 (expression_minus -> expression MINUS expression .)
    EQUALS          reduce using rule 88 (expression_minus -> expression MINUS expression .)
    DIFFERENT       reduce using rule 88 (expression_minus -> expression MINUS expression .)
    if              reduce using rule 88 (expression_minus -> expression MINUS expression .)
    break           reduce using rule 88 (expression_minus -> expression MINUS expression .)
    continue        reduce using rule 88 (expression_minus -> expression MINUS expression .)
    ID              reduce using rule 88 (expression_minus -> expression MINUS expression .)
    LBRACKET        reduce using rule 88 (expression_minus -> expression MINUS expression .)
    INDENT          reduce using rule 88 (expression_minus -> expression MINUS expression .)
    for             reduce using rule 88 (expression_minus -> expression MINUS expression .)
    while           reduce using rule 88 (expression_minus -> expression MINUS expression .)
    do              reduce using rule 88 (expression_minus -> expression MINUS expression .)
    repeat          reduce using rule 88 (expression_minus -> expression MINUS expression .)
    unless          reduce using rule 88 (expression_minus -> expression MINUS expression .)
    CONST_REAL      reduce using rule 88 (expression_minus -> expression MINUS expression .)
    CONST_INTERGER  reduce using rule 88 (expression_minus -> expression MINUS expression .)
    CONST_STRING    reduce using rule 88 (expression_minus -> expression MINUS expression .)
    True            reduce using rule 88 (expression_minus -> expression MINUS expression .)
    False           reduce using rule 88 (expression_minus -> expression MINUS expression .)
    DSING           reduce using rule 88 (expression_minus -> expression MINUS expression .)
    LAND            reduce using rule 88 (expression_minus -> expression MINUS expression .)
    puts            reduce using rule 88 (expression_minus -> expression MINUS expression .)
    NOT             reduce using rule 88 (expression_minus -> expression MINUS expression .)
    int             reduce using rule 88 (expression_minus -> expression MINUS expression .)
    float           reduce using rule 88 (expression_minus -> expression MINUS expression .)
    boolean         reduce using rule 88 (expression_minus -> expression MINUS expression .)
    $end            reduce using rule 88 (expression_minus -> expression MINUS expression .)
    begin           reduce using rule 88 (expression_minus -> expression MINUS expression .)
    DEDENT          reduce using rule 88 (expression_minus -> expression MINUS expression .)
    in              reduce using rule 88 (expression_minus -> expression MINUS expression .)
    then            reduce using rule 88 (expression_minus -> expression MINUS expression .)
    RBRACKET        reduce using rule 88 (expression_minus -> expression MINUS expression .)
    COMMA           reduce using rule 88 (expression_minus -> expression MINUS expression .)
    POINT           reduce using rule 88 (expression_minus -> expression MINUS expression .)
    end             reduce using rule 88 (expression_minus -> expression MINUS expression .)
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! ASTERISK        [ reduce using rule 88 (expression_minus -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 88 (expression_minus -> expression MINUS expression .) ]
  ! MODULE          [ reduce using rule 88 (expression_minus -> expression MINUS expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 146

    (85) expression_plus -> expression PLUS expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 85 (expression_plus -> expression PLUS expression .)
    OR              reduce using rule 85 (expression_plus -> expression PLUS expression .)
    GT              reduce using rule 85 (expression_plus -> expression PLUS expression .)
    GE              reduce using rule 85 (expression_plus -> expression PLUS expression .)
    LT              reduce using rule 85 (expression_plus -> expression PLUS expression .)
    LE              reduce using rule 85 (expression_plus -> expression PLUS expression .)
    MINUS           reduce using rule 85 (expression_plus -> expression PLUS expression .)
    PLUS            reduce using rule 85 (expression_plus -> expression PLUS expression .)
    EQUALS          reduce using rule 85 (expression_plus -> expression PLUS expression .)
    DIFFERENT       reduce using rule 85 (expression_plus -> expression PLUS expression .)
    if              reduce using rule 85 (expression_plus -> expression PLUS expression .)
    break           reduce using rule 85 (expression_plus -> expression PLUS expression .)
    continue        reduce using rule 85 (expression_plus -> expression PLUS expression .)
    ID              reduce using rule 85 (expression_plus -> expression PLUS expression .)
    LBRACKET        reduce using rule 85 (expression_plus -> expression PLUS expression .)
    INDENT          reduce using rule 85 (expression_plus -> expression PLUS expression .)
    for             reduce using rule 85 (expression_plus -> expression PLUS expression .)
    while           reduce using rule 85 (expression_plus -> expression PLUS expression .)
    do              reduce using rule 85 (expression_plus -> expression PLUS expression .)
    repeat          reduce using rule 85 (expression_plus -> expression PLUS expression .)
    unless          reduce using rule 85 (expression_plus -> expression PLUS expression .)
    CONST_REAL      reduce using rule 85 (expression_plus -> expression PLUS expression .)
    CONST_INTERGER  reduce using rule 85 (expression_plus -> expression PLUS expression .)
    CONST_STRING    reduce using rule 85 (expression_plus -> expression PLUS expression .)
    True            reduce using rule 85 (expression_plus -> expression PLUS expression .)
    False           reduce using rule 85 (expression_plus -> expression PLUS expression .)
    DSING           reduce using rule 85 (expression_plus -> expression PLUS expression .)
    LAND            reduce using rule 85 (expression_plus -> expression PLUS expression .)
    puts            reduce using rule 85 (expression_plus -> expression PLUS expression .)
    NOT             reduce using rule 85 (expression_plus -> expression PLUS expression .)
    int             reduce using rule 85 (expression_plus -> expression PLUS expression .)
    float           reduce using rule 85 (expression_plus -> expression PLUS expression .)
    boolean         reduce using rule 85 (expression_plus -> expression PLUS expression .)
    $end            reduce using rule 85 (expression_plus -> expression PLUS expression .)
    begin           reduce using rule 85 (expression_plus -> expression PLUS expression .)
    DEDENT          reduce using rule 85 (expression_plus -> expression PLUS expression .)
    in              reduce using rule 85 (expression_plus -> expression PLUS expression .)
    then            reduce using rule 85 (expression_plus -> expression PLUS expression .)
    RBRACKET        reduce using rule 85 (expression_plus -> expression PLUS expression .)
    COMMA           reduce using rule 85 (expression_plus -> expression PLUS expression .)
    POINT           reduce using rule 85 (expression_plus -> expression PLUS expression .)
    end             reduce using rule 85 (expression_plus -> expression PLUS expression .)
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! ASTERISK        [ reduce using rule 85 (expression_plus -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 85 (expression_plus -> expression PLUS expression .) ]
  ! MODULE          [ reduce using rule 85 (expression_plus -> expression PLUS expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 147

    (89) expression_mult -> expression ASTERISK expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    OR              reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    GT              reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    GE              reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    LT              reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    LE              reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    MINUS           reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    PLUS            reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    ASTERISK        reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    DIVIDE          reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    MODULE          reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    EQUALS          reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    DIFFERENT       reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    if              reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    break           reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    continue        reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    ID              reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    LBRACKET        reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    INDENT          reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    for             reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    while           reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    do              reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    repeat          reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    unless          reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    CONST_REAL      reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    CONST_INTERGER  reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    CONST_STRING    reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    True            reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    False           reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    DSING           reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    LAND            reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    puts            reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    NOT             reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    int             reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    float           reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    boolean         reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    $end            reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    begin           reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    DEDENT          reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    in              reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    then            reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    RBRACKET        reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    COMMA           reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    POINT           reduce using rule 89 (expression_mult -> expression ASTERISK expression .)
    end             reduce using rule 89 (expression_mult -> expression ASTERISK expression .)

  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! ASTERISK        [ shift and go to state 100 ]
  ! DIVIDE          [ shift and go to state 101 ]
  ! MODULE          [ shift and go to state 102 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 148

    (90) expression_divide -> expression DIVIDE expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    OR              reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    GT              reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    GE              reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    LT              reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    LE              reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    MINUS           reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    PLUS            reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    ASTERISK        reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    MODULE          reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    EQUALS          reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    DIFFERENT       reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    if              reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    break           reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    continue        reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    ID              reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    INDENT          reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    for             reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    while           reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    do              reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    repeat          reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    unless          reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    CONST_REAL      reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    CONST_INTERGER  reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    CONST_STRING    reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    True            reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    False           reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    DSING           reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    LAND            reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    puts            reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    NOT             reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    int             reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    float           reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    boolean         reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    $end            reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    begin           reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    DEDENT          reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    in              reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    then            reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    COMMA           reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    POINT           reduce using rule 90 (expression_divide -> expression DIVIDE expression .)
    end             reduce using rule 90 (expression_divide -> expression DIVIDE expression .)

  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! ASTERISK        [ shift and go to state 100 ]
  ! DIVIDE          [ shift and go to state 101 ]
  ! MODULE          [ shift and go to state 102 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 149

    (91) expression_module -> expression MODULE expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 91 (expression_module -> expression MODULE expression .)
    OR              reduce using rule 91 (expression_module -> expression MODULE expression .)
    GT              reduce using rule 91 (expression_module -> expression MODULE expression .)
    GE              reduce using rule 91 (expression_module -> expression MODULE expression .)
    LT              reduce using rule 91 (expression_module -> expression MODULE expression .)
    LE              reduce using rule 91 (expression_module -> expression MODULE expression .)
    MINUS           reduce using rule 91 (expression_module -> expression MODULE expression .)
    PLUS            reduce using rule 91 (expression_module -> expression MODULE expression .)
    ASTERISK        reduce using rule 91 (expression_module -> expression MODULE expression .)
    DIVIDE          reduce using rule 91 (expression_module -> expression MODULE expression .)
    MODULE          reduce using rule 91 (expression_module -> expression MODULE expression .)
    EQUALS          reduce using rule 91 (expression_module -> expression MODULE expression .)
    DIFFERENT       reduce using rule 91 (expression_module -> expression MODULE expression .)
    if              reduce using rule 91 (expression_module -> expression MODULE expression .)
    break           reduce using rule 91 (expression_module -> expression MODULE expression .)
    continue        reduce using rule 91 (expression_module -> expression MODULE expression .)
    ID              reduce using rule 91 (expression_module -> expression MODULE expression .)
    LBRACKET        reduce using rule 91 (expression_module -> expression MODULE expression .)
    INDENT          reduce using rule 91 (expression_module -> expression MODULE expression .)
    for             reduce using rule 91 (expression_module -> expression MODULE expression .)
    while           reduce using rule 91 (expression_module -> expression MODULE expression .)
    do              reduce using rule 91 (expression_module -> expression MODULE expression .)
    repeat          reduce using rule 91 (expression_module -> expression MODULE expression .)
    unless          reduce using rule 91 (expression_module -> expression MODULE expression .)
    CONST_REAL      reduce using rule 91 (expression_module -> expression MODULE expression .)
    CONST_INTERGER  reduce using rule 91 (expression_module -> expression MODULE expression .)
    CONST_STRING    reduce using rule 91 (expression_module -> expression MODULE expression .)
    True            reduce using rule 91 (expression_module -> expression MODULE expression .)
    False           reduce using rule 91 (expression_module -> expression MODULE expression .)
    DSING           reduce using rule 91 (expression_module -> expression MODULE expression .)
    LAND            reduce using rule 91 (expression_module -> expression MODULE expression .)
    puts            reduce using rule 91 (expression_module -> expression MODULE expression .)
    NOT             reduce using rule 91 (expression_module -> expression MODULE expression .)
    int             reduce using rule 91 (expression_module -> expression MODULE expression .)
    float           reduce using rule 91 (expression_module -> expression MODULE expression .)
    boolean         reduce using rule 91 (expression_module -> expression MODULE expression .)
    $end            reduce using rule 91 (expression_module -> expression MODULE expression .)
    begin           reduce using rule 91 (expression_module -> expression MODULE expression .)
    DEDENT          reduce using rule 91 (expression_module -> expression MODULE expression .)
    in              reduce using rule 91 (expression_module -> expression MODULE expression .)
    then            reduce using rule 91 (expression_module -> expression MODULE expression .)
    RBRACKET        reduce using rule 91 (expression_module -> expression MODULE expression .)
    COMMA           reduce using rule 91 (expression_module -> expression MODULE expression .)
    POINT           reduce using rule 91 (expression_module -> expression MODULE expression .)
    end             reduce using rule 91 (expression_module -> expression MODULE expression .)

  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 95 ]
  ! LT              [ shift and go to state 96 ]
  ! LE              [ shift and go to state 97 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! ASTERISK        [ shift and go to state 100 ]
  ! DIVIDE          [ shift and go to state 101 ]
  ! MODULE          [ shift and go to state 102 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 150

    (86) expression_equals -> expression EQUALS expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    OR              reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    EQUALS          reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    DIFFERENT       reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    if              reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    break           reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    continue        reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    ID              reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    LBRACKET        reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    INDENT          reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    for             reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    while           reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    do              reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    repeat          reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    unless          reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    CONST_REAL      reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    CONST_INTERGER  reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    CONST_STRING    reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    True            reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    False           reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    DSING           reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    LAND            reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    puts            reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    NOT             reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    int             reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    float           reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    boolean         reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    $end            reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    begin           reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    DEDENT          reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    in              reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    then            reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    RBRACKET        reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    COMMA           reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    POINT           reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    end             reduce using rule 86 (expression_equals -> expression EQUALS expression .)
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! GT              [ reduce using rule 86 (expression_equals -> expression EQUALS expression .) ]
  ! GE              [ reduce using rule 86 (expression_equals -> expression EQUALS expression .) ]
  ! LT              [ reduce using rule 86 (expression_equals -> expression EQUALS expression .) ]
  ! LE              [ reduce using rule 86 (expression_equals -> expression EQUALS expression .) ]
  ! MINUS           [ reduce using rule 86 (expression_equals -> expression EQUALS expression .) ]
  ! PLUS            [ reduce using rule 86 (expression_equals -> expression EQUALS expression .) ]
  ! ASTERISK        [ reduce using rule 86 (expression_equals -> expression EQUALS expression .) ]
  ! DIVIDE          [ reduce using rule 86 (expression_equals -> expression EQUALS expression .) ]
  ! MODULE          [ reduce using rule 86 (expression_equals -> expression EQUALS expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 151

    (87) expression_different -> expression DIFFERENT expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    AND             reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    OR              reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    EQUALS          reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    DIFFERENT       reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    if              reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    break           reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    continue        reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    ID              reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    LBRACKET        reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    INDENT          reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    for             reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    while           reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    do              reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    repeat          reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    unless          reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    CONST_REAL      reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    CONST_INTERGER  reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    CONST_STRING    reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    True            reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    False           reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    DSING           reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    LAND            reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    puts            reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    NOT             reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    int             reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    float           reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    boolean         reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    $end            reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    begin           reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    DEDENT          reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    in              reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    then            reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    RBRACKET        reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    COMMA           reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    POINT           reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    end             reduce using rule 87 (expression_different -> expression DIFFERENT expression .)
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102

  ! GT              [ reduce using rule 87 (expression_different -> expression DIFFERENT expression .) ]
  ! GE              [ reduce using rule 87 (expression_different -> expression DIFFERENT expression .) ]
  ! LT              [ reduce using rule 87 (expression_different -> expression DIFFERENT expression .) ]
  ! LE              [ reduce using rule 87 (expression_different -> expression DIFFERENT expression .) ]
  ! MINUS           [ reduce using rule 87 (expression_different -> expression DIFFERENT expression .) ]
  ! PLUS            [ reduce using rule 87 (expression_different -> expression DIFFERENT expression .) ]
  ! ASTERISK        [ reduce using rule 87 (expression_different -> expression DIFFERENT expression .) ]
  ! DIVIDE          [ reduce using rule 87 (expression_different -> expression DIFFERENT expression .) ]
  ! MODULE          [ reduce using rule 87 (expression_different -> expression DIFFERENT expression .) ]
  ! AND             [ shift and go to state 92 ]
  ! OR              [ shift and go to state 93 ]
  ! EQUALS          [ shift and go to state 103 ]
  ! DIFFERENT       [ shift and go to state 104 ]


state 152

    (30) conditional -> if expression begin . bloco end SEMICOLON
    (31) conditional -> if expression begin . bloco else bloco end SEMICOLON
    (32) conditional -> if expression begin . bloco elsif expression bloco else bloco end SEMICOLON
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 176

state 153

    (92) argumentlist -> ID LPAREN COMMA . ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    ID              shift and go to state 177


state 154

    (97) read_gets -> ID ASSIGNMENT gets .

    if              reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    break           reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    continue        reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    ID              reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    ASTERISK        reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    LBRACKET        reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    INDENT          reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    for             reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    while           reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    do              reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    repeat          reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    unless          reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    CONST_REAL      reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    CONST_INTERGER  reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    CONST_STRING    reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    True            reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    False           reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    DSING           reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    LAND            reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    puts            reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    NOT             reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    PLUS            reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    MINUS           reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    int             reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    float           reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    boolean         reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    AND             reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    $end            reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)
    DEDENT          reduce using rule 97 (read_gets -> ID ASSIGNMENT gets .)


state 155

    (22) matrix_declaration -> ID ASSIGNMENT matrix .

    if              reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    break           reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    continue        reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    ID              reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    ASTERISK        reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    LBRACKET        reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    INDENT          reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    for             reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    while           reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    do              reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    repeat          reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    unless          reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    CONST_REAL      reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    CONST_INTERGER  reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    CONST_STRING    reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    True            reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    False           reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    DSING           reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    LAND            reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    puts            reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    NOT             reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    PLUS            reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    MINUS           reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    int             reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    float           reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    boolean         reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    AND             reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    $end            reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)
    DEDENT          reduce using rule 22 (matrix_declaration -> ID ASSIGNMENT matrix .)


state 156

    (23) expression_declaration -> ID ASSIGNMENT expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    if              reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    break           reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    continue        reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    ID              reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    ASTERISK        reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    LBRACKET        reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    INDENT          reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    for             reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    while           reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    do              reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    repeat          reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    unless          reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    CONST_REAL      reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    CONST_INTERGER  reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    CONST_STRING    reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    True            reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    False           reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    DSING           reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    LAND            reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    puts            reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    NOT             reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    PLUS            reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    MINUS           reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    int             reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    float           reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    boolean         reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    AND             reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    $end            reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    DEDENT          reduce using rule 23 (expression_declaration -> ID ASSIGNMENT expression .)
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104

  ! AND             [ shift and go to state 92 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! ASTERISK        [ shift and go to state 100 ]


state 157

    (122) matrix -> matrix_arg .

    if              reduce using rule 122 (matrix -> matrix_arg .)
    break           reduce using rule 122 (matrix -> matrix_arg .)
    continue        reduce using rule 122 (matrix -> matrix_arg .)
    ID              reduce using rule 122 (matrix -> matrix_arg .)
    ASTERISK        reduce using rule 122 (matrix -> matrix_arg .)
    LBRACKET        reduce using rule 122 (matrix -> matrix_arg .)
    INDENT          reduce using rule 122 (matrix -> matrix_arg .)
    for             reduce using rule 122 (matrix -> matrix_arg .)
    while           reduce using rule 122 (matrix -> matrix_arg .)
    do              reduce using rule 122 (matrix -> matrix_arg .)
    repeat          reduce using rule 122 (matrix -> matrix_arg .)
    unless          reduce using rule 122 (matrix -> matrix_arg .)
    CONST_REAL      reduce using rule 122 (matrix -> matrix_arg .)
    CONST_INTERGER  reduce using rule 122 (matrix -> matrix_arg .)
    CONST_STRING    reduce using rule 122 (matrix -> matrix_arg .)
    True            reduce using rule 122 (matrix -> matrix_arg .)
    False           reduce using rule 122 (matrix -> matrix_arg .)
    DSING           reduce using rule 122 (matrix -> matrix_arg .)
    LAND            reduce using rule 122 (matrix -> matrix_arg .)
    puts            reduce using rule 122 (matrix -> matrix_arg .)
    NOT             reduce using rule 122 (matrix -> matrix_arg .)
    PLUS            reduce using rule 122 (matrix -> matrix_arg .)
    MINUS           reduce using rule 122 (matrix -> matrix_arg .)
    int             reduce using rule 122 (matrix -> matrix_arg .)
    float           reduce using rule 122 (matrix -> matrix_arg .)
    boolean         reduce using rule 122 (matrix -> matrix_arg .)
    AND             reduce using rule 122 (matrix -> matrix_arg .)
    $end            reduce using rule 122 (matrix -> matrix_arg .)
    DEDENT          reduce using rule 122 (matrix -> matrix_arg .)
    RBRACKET        reduce using rule 122 (matrix -> matrix_arg .)


state 158

    (123) matrix -> matrix_rec .

    if              reduce using rule 123 (matrix -> matrix_rec .)
    break           reduce using rule 123 (matrix -> matrix_rec .)
    continue        reduce using rule 123 (matrix -> matrix_rec .)
    ID              reduce using rule 123 (matrix -> matrix_rec .)
    ASTERISK        reduce using rule 123 (matrix -> matrix_rec .)
    LBRACKET        reduce using rule 123 (matrix -> matrix_rec .)
    INDENT          reduce using rule 123 (matrix -> matrix_rec .)
    for             reduce using rule 123 (matrix -> matrix_rec .)
    while           reduce using rule 123 (matrix -> matrix_rec .)
    do              reduce using rule 123 (matrix -> matrix_rec .)
    repeat          reduce using rule 123 (matrix -> matrix_rec .)
    unless          reduce using rule 123 (matrix -> matrix_rec .)
    CONST_REAL      reduce using rule 123 (matrix -> matrix_rec .)
    CONST_INTERGER  reduce using rule 123 (matrix -> matrix_rec .)
    CONST_STRING    reduce using rule 123 (matrix -> matrix_rec .)
    True            reduce using rule 123 (matrix -> matrix_rec .)
    False           reduce using rule 123 (matrix -> matrix_rec .)
    DSING           reduce using rule 123 (matrix -> matrix_rec .)
    LAND            reduce using rule 123 (matrix -> matrix_rec .)
    puts            reduce using rule 123 (matrix -> matrix_rec .)
    NOT             reduce using rule 123 (matrix -> matrix_rec .)
    PLUS            reduce using rule 123 (matrix -> matrix_rec .)
    MINUS           reduce using rule 123 (matrix -> matrix_rec .)
    int             reduce using rule 123 (matrix -> matrix_rec .)
    float           reduce using rule 123 (matrix -> matrix_rec .)
    boolean         reduce using rule 123 (matrix -> matrix_rec .)
    AND             reduce using rule 123 (matrix -> matrix_rec .)
    $end            reduce using rule 123 (matrix -> matrix_rec .)
    DEDENT          reduce using rule 123 (matrix -> matrix_rec .)
    RBRACKET        reduce using rule 123 (matrix -> matrix_rec .)


state 159

    (124) matrix -> LBRACKET . argument RBRACKET matrix
    (125) matrix -> LBRACKET . argument RBRACKET COMMA matrix
    (126) matrix_arg -> LBRACKET . argument RBRACKET
    (127) matrix_rec -> LBRACKET . matrix RBRACKET
    (128) argument -> . expression
    (129) argument -> . argument COMMA expression
    (130) argument -> . argument POINT expression
    (131) argument -> .
    (122) matrix -> . matrix_arg
    (123) matrix -> . matrix_rec
    (124) matrix -> . LBRACKET argument RBRACKET matrix
    (125) matrix -> . LBRACKET argument RBRACKET COMMA matrix
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (126) matrix_arg -> . LBRACKET argument RBRACKET
    (127) matrix_rec -> . LBRACKET matrix RBRACKET
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    RBRACKET        reduce using rule 131 (argument -> .)
    COMMA           reduce using rule 131 (argument -> .)
    POINT           reduce using rule 131 (argument -> .)
    LBRACKET        shift and go to state 159
    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    argument                       shift and go to state 178
    matrix                         shift and go to state 179
    expression                     shift and go to state 180
    matrix_arg                     shift and go to state 157
    matrix_rec                     shift and go to state 158
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 160

    (93) argumentlist -> ASTERISK ID LBRACKET . COMMA LAND ID RBRACKET

    COMMA           shift and go to state 181


state 161

    (94) argumentlist -> LBRACKET LAND ID . RBRACKET

    RBRACKET        shift and go to state 182


state 162

    (3) bloco -> INDENT program DEDENT .

    if              reduce using rule 3 (bloco -> INDENT program DEDENT .)
    break           reduce using rule 3 (bloco -> INDENT program DEDENT .)
    continue        reduce using rule 3 (bloco -> INDENT program DEDENT .)
    ID              reduce using rule 3 (bloco -> INDENT program DEDENT .)
    ASTERISK        reduce using rule 3 (bloco -> INDENT program DEDENT .)
    LBRACKET        reduce using rule 3 (bloco -> INDENT program DEDENT .)
    INDENT          reduce using rule 3 (bloco -> INDENT program DEDENT .)
    for             reduce using rule 3 (bloco -> INDENT program DEDENT .)
    while           reduce using rule 3 (bloco -> INDENT program DEDENT .)
    do              reduce using rule 3 (bloco -> INDENT program DEDENT .)
    repeat          reduce using rule 3 (bloco -> INDENT program DEDENT .)
    unless          reduce using rule 3 (bloco -> INDENT program DEDENT .)
    CONST_REAL      reduce using rule 3 (bloco -> INDENT program DEDENT .)
    CONST_INTERGER  reduce using rule 3 (bloco -> INDENT program DEDENT .)
    CONST_STRING    reduce using rule 3 (bloco -> INDENT program DEDENT .)
    True            reduce using rule 3 (bloco -> INDENT program DEDENT .)
    False           reduce using rule 3 (bloco -> INDENT program DEDENT .)
    DSING           reduce using rule 3 (bloco -> INDENT program DEDENT .)
    LAND            reduce using rule 3 (bloco -> INDENT program DEDENT .)
    puts            reduce using rule 3 (bloco -> INDENT program DEDENT .)
    NOT             reduce using rule 3 (bloco -> INDENT program DEDENT .)
    PLUS            reduce using rule 3 (bloco -> INDENT program DEDENT .)
    MINUS           reduce using rule 3 (bloco -> INDENT program DEDENT .)
    int             reduce using rule 3 (bloco -> INDENT program DEDENT .)
    float           reduce using rule 3 (bloco -> INDENT program DEDENT .)
    boolean         reduce using rule 3 (bloco -> INDENT program DEDENT .)
    AND             reduce using rule 3 (bloco -> INDENT program DEDENT .)
    $end            reduce using rule 3 (bloco -> INDENT program DEDENT .)
    DEDENT          reduce using rule 3 (bloco -> INDENT program DEDENT .)
    end             reduce using rule 3 (bloco -> INDENT program DEDENT .)
    else            reduce using rule 3 (bloco -> INDENT program DEDENT .)
    elsif           reduce using rule 3 (bloco -> INDENT program DEDENT .)
    RBRACKET        reduce using rule 3 (bloco -> INDENT program DEDENT .)


state 163

    (37) fors -> for expression_variable LBRACKET . expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID

    ID              shift and go to state 106
    DSING           shift and go to state 69

    expression_variable            shift and go to state 183

state 164

    (38) fors -> for expression in . CONST_INTERGER POINTPOINT CONST_INTERGER bloco end

    CONST_INTERGER  shift and go to state 184


state 165

    (40) whiles -> do bloco break . if expression end

    if              shift and go to state 185


state 166

    (39) whiles -> while expression do . bloco end
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 186

state 167

    (41) repeats -> repeat CONST_INTERGER DPOINT . bloco end SEMICOLON
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 187

state 168

    (42) unlesss -> unless expression then . bloco RBRACKET else bloco LBRACKET end
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 188

state 169

    (106) puts_string -> puts QUOTATION CONST_STRING . QUOTATION

    QUOTATION       shift and go to state 189


state 170

    (107) puts_expressionq -> puts QUOTATION expression_variable . QUOTATION

    QUOTATION       shift and go to state 190


state 171

    (110) puts_string_dq -> puts DQUOTATION CONST_STRING . DQUOTATION

    DQUOTATION      shift and go to state 191


state 172

    (111) puts_expression_dq -> puts DQUOTATION expression_variable . DQUOTATION

    DQUOTATION      shift and go to state 192


state 173

    (27) int_declaration -> int ID ASSIGNMENT . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 193
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 174

    (28) float_declaration -> float ID ASSIGNMENT . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 194
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 175

    (29) boolean_declaration -> boolean ID ASSIGNMENT . expression_declaration
    (23) expression_declaration -> . ID ASSIGNMENT expression

    ID              shift and go to state 195

    expression_declaration         shift and go to state 196

state 176

    (30) conditional -> if expression begin bloco . end SEMICOLON
    (31) conditional -> if expression begin bloco . else bloco end SEMICOLON
    (32) conditional -> if expression begin bloco . elsif expression bloco else bloco end SEMICOLON

    end             shift and go to state 197
    else            shift and go to state 198
    elsif           shift and go to state 199


state 177

    (92) argumentlist -> ID LPAREN COMMA ID . RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    RPAREN          shift and go to state 200


state 178

    (124) matrix -> LBRACKET argument . RBRACKET matrix
    (125) matrix -> LBRACKET argument . RBRACKET COMMA matrix
    (126) matrix_arg -> LBRACKET argument . RBRACKET
    (129) argument -> argument . COMMA expression
    (130) argument -> argument . POINT expression

    RBRACKET        shift and go to state 201
    COMMA           shift and go to state 202
    POINT           shift and go to state 203


state 179

    (127) matrix_rec -> LBRACKET matrix . RBRACKET

    RBRACKET        shift and go to state 204


state 180

    (128) argument -> expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    RBRACKET        reduce using rule 128 (argument -> expression .)
    COMMA           reduce using rule 128 (argument -> expression .)
    POINT           reduce using rule 128 (argument -> expression .)
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104


state 181

    (93) argumentlist -> ASTERISK ID LBRACKET COMMA . LAND ID RBRACKET

    LAND            shift and go to state 205


state 182

    (94) argumentlist -> LBRACKET LAND ID RBRACKET .

    if              reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    break           reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    continue        reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    ID              reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    ASTERISK        reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    LBRACKET        reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    INDENT          reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    for             reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    while           reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    do              reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    repeat          reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    unless          reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    CONST_REAL      reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    CONST_INTERGER  reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    CONST_STRING    reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    True            reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    False           reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    DSING           reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    LAND            reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    puts            reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    NOT             reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    PLUS            reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    MINUS           reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    int             reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    float           reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    boolean         reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    AND             reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    $end            reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)
    DEDENT          reduce using rule 94 (argumentlist -> LBRACKET LAND ID RBRACKET .)


state 183

    (37) fors -> for expression_variable LBRACKET expression_variable . RBRACKET in expression LBRACKET do RBRACKET begin bloco end

    RBRACKET        shift and go to state 206


state 184

    (38) fors -> for expression in CONST_INTERGER . POINTPOINT CONST_INTERGER bloco end

    POINTPOINT      shift and go to state 207


state 185

    (40) whiles -> do bloco break if . expression end
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 208
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 186

    (39) whiles -> while expression do bloco . end

    end             shift and go to state 209


state 187

    (41) repeats -> repeat CONST_INTERGER DPOINT bloco . end SEMICOLON

    end             shift and go to state 210


state 188

    (42) unlesss -> unless expression then bloco . RBRACKET else bloco LBRACKET end

    RBRACKET        shift and go to state 211


state 189

    (106) puts_string -> puts QUOTATION CONST_STRING QUOTATION .

    if              reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    break           reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    continue        reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    ID              reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    ASTERISK        reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    LBRACKET        reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    INDENT          reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    for             reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    while           reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    do              reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    repeat          reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    unless          reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    CONST_REAL      reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    CONST_INTERGER  reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    CONST_STRING    reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    True            reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    False           reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    DSING           reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    LAND            reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    puts            reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    NOT             reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    PLUS            reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    MINUS           reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    int             reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    float           reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    boolean         reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    AND             reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    $end            reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)
    DEDENT          reduce using rule 106 (puts_string -> puts QUOTATION CONST_STRING QUOTATION .)


state 190

    (107) puts_expressionq -> puts QUOTATION expression_variable QUOTATION .

    if              reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    break           reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    continue        reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    ID              reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    ASTERISK        reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    LBRACKET        reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    INDENT          reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    for             reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    while           reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    do              reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    repeat          reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    unless          reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    CONST_REAL      reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    CONST_INTERGER  reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    CONST_STRING    reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    True            reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    False           reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    DSING           reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    LAND            reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    puts            reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    NOT             reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    PLUS            reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    MINUS           reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    int             reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    float           reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    boolean         reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    AND             reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    $end            reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)
    DEDENT          reduce using rule 107 (puts_expressionq -> puts QUOTATION expression_variable QUOTATION .)


state 191

    (110) puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .

    if              reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    break           reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    continue        reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    ID              reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    ASTERISK        reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    LBRACKET        reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    INDENT          reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    for             reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    while           reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    do              reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    repeat          reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    unless          reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    CONST_REAL      reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    CONST_INTERGER  reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    CONST_STRING    reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    True            reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    False           reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    DSING           reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    LAND            reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    puts            reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    NOT             reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    PLUS            reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    MINUS           reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    int             reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    float           reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    boolean         reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    AND             reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    $end            reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)
    DEDENT          reduce using rule 110 (puts_string_dq -> puts DQUOTATION CONST_STRING DQUOTATION .)


state 192

    (111) puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .

    if              reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    break           reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    continue        reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    ID              reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    ASTERISK        reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    LBRACKET        reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    INDENT          reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    for             reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    while           reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    do              reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    repeat          reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    unless          reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    CONST_REAL      reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    CONST_INTERGER  reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    CONST_STRING    reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    True            reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    False           reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    DSING           reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    LAND            reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    puts            reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    NOT             reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    PLUS            reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    MINUS           reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    int             reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    float           reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    boolean         reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    AND             reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    $end            reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)
    DEDENT          reduce using rule 111 (puts_expression_dq -> puts DQUOTATION expression_variable DQUOTATION .)


state 193

    (27) int_declaration -> int ID ASSIGNMENT expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    if              reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    break           reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    continue        reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    ID              reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    ASTERISK        reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    LBRACKET        reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    INDENT          reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    for             reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    while           reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    do              reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    repeat          reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    unless          reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    CONST_REAL      reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    CONST_INTERGER  reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    CONST_STRING    reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    True            reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    False           reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    DSING           reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    LAND            reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    puts            reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    NOT             reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    PLUS            reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    MINUS           reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    int             reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    float           reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    boolean         reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    AND             reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    $end            reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    DEDENT          reduce using rule 27 (int_declaration -> int ID ASSIGNMENT expression .)
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104

  ! AND             [ shift and go to state 92 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! ASTERISK        [ shift and go to state 100 ]


state 194

    (28) float_declaration -> float ID ASSIGNMENT expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    if              reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    break           reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    continue        reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    ID              reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    ASTERISK        reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    LBRACKET        reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    INDENT          reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    for             reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    while           reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    do              reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    repeat          reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    unless          reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    CONST_REAL      reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    CONST_INTERGER  reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    CONST_STRING    reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    True            reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    False           reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    DSING           reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    LAND            reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    puts            reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    NOT             reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    PLUS            reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    MINUS           reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    int             reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    float           reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    boolean         reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    AND             reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    $end            reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    DEDENT          reduce using rule 28 (float_declaration -> float ID ASSIGNMENT expression .)
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104

  ! AND             [ shift and go to state 92 ]
  ! MINUS           [ shift and go to state 98 ]
  ! PLUS            [ shift and go to state 99 ]
  ! ASTERISK        [ shift and go to state 100 ]


state 195

    (23) expression_declaration -> ID . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 212


state 196

    (29) boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .

    if              reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    break           reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    continue        reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    ID              reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    ASTERISK        reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    LBRACKET        reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    INDENT          reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    for             reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    while           reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    do              reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    repeat          reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    unless          reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    CONST_REAL      reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    CONST_INTERGER  reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    CONST_STRING    reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    True            reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    False           reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    DSING           reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    LAND            reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    puts            reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    NOT             reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    PLUS            reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    MINUS           reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    int             reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    float           reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    boolean         reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    AND             reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    $end            reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)
    DEDENT          reduce using rule 29 (boolean_declaration -> boolean ID ASSIGNMENT expression_declaration .)


state 197

    (30) conditional -> if expression begin bloco end . SEMICOLON

    SEMICOLON       shift and go to state 213


state 198

    (31) conditional -> if expression begin bloco else . bloco end SEMICOLON
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 214

state 199

    (32) conditional -> if expression begin bloco elsif . expression bloco else bloco end SEMICOLON
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 215
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 200

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN . ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    ASTERISK        shift and go to state 216


state 201

    (124) matrix -> LBRACKET argument RBRACKET . matrix
    (125) matrix -> LBRACKET argument RBRACKET . COMMA matrix
    (126) matrix_arg -> LBRACKET argument RBRACKET .
    (122) matrix -> . matrix_arg
    (123) matrix -> . matrix_rec
    (124) matrix -> . LBRACKET argument RBRACKET matrix
    (125) matrix -> . LBRACKET argument RBRACKET COMMA matrix
    (126) matrix_arg -> . LBRACKET argument RBRACKET
    (127) matrix_rec -> . LBRACKET matrix RBRACKET

    COMMA           shift and go to state 218
    if              reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    break           reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    continue        reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    ID              reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    ASTERISK        reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    LBRACKET        reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    INDENT          reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    for             reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    while           reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    do              reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    repeat          reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    unless          reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    CONST_REAL      reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    CONST_INTERGER  reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    CONST_STRING    reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    True            reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    False           reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    DSING           reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    LAND            reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    puts            reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    NOT             reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    PLUS            reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    MINUS           reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    int             reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    float           reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    boolean         reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    AND             reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    $end            reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    DEDENT          reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)
    RBRACKET        reduce using rule 126 (matrix_arg -> LBRACKET argument RBRACKET .)

  ! LBRACKET        [ shift and go to state 159 ]

    matrix                         shift and go to state 217
    matrix_arg                     shift and go to state 157
    matrix_rec                     shift and go to state 158

state 202

    (129) argument -> argument COMMA . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 219
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 203

    (130) argument -> argument POINT . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 220
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 204

    (127) matrix_rec -> LBRACKET matrix RBRACKET .

    if              reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    break           reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    continue        reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    ID              reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    ASTERISK        reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    LBRACKET        reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    INDENT          reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    for             reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    while           reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    do              reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    repeat          reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    unless          reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    CONST_REAL      reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    CONST_INTERGER  reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    CONST_STRING    reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    True            reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    False           reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    DSING           reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    LAND            reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    puts            reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    NOT             reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    PLUS            reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    MINUS           reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    int             reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    float           reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    boolean         reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    AND             reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    $end            reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    DEDENT          reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)
    RBRACKET        reduce using rule 127 (matrix_rec -> LBRACKET matrix RBRACKET .)


state 205

    (93) argumentlist -> ASTERISK ID LBRACKET COMMA LAND . ID RBRACKET

    ID              shift and go to state 221


state 206

    (37) fors -> for expression_variable LBRACKET expression_variable RBRACKET . in expression LBRACKET do RBRACKET begin bloco end

    in              shift and go to state 222


state 207

    (38) fors -> for expression in CONST_INTERGER POINTPOINT . CONST_INTERGER bloco end

    CONST_INTERGER  shift and go to state 223


state 208

    (40) whiles -> do bloco break if expression . end
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    end             shift and go to state 224
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104


state 209

    (39) whiles -> while expression do bloco end .

    if              reduce using rule 39 (whiles -> while expression do bloco end .)
    break           reduce using rule 39 (whiles -> while expression do bloco end .)
    continue        reduce using rule 39 (whiles -> while expression do bloco end .)
    ID              reduce using rule 39 (whiles -> while expression do bloco end .)
    ASTERISK        reduce using rule 39 (whiles -> while expression do bloco end .)
    LBRACKET        reduce using rule 39 (whiles -> while expression do bloco end .)
    INDENT          reduce using rule 39 (whiles -> while expression do bloco end .)
    for             reduce using rule 39 (whiles -> while expression do bloco end .)
    while           reduce using rule 39 (whiles -> while expression do bloco end .)
    do              reduce using rule 39 (whiles -> while expression do bloco end .)
    repeat          reduce using rule 39 (whiles -> while expression do bloco end .)
    unless          reduce using rule 39 (whiles -> while expression do bloco end .)
    CONST_REAL      reduce using rule 39 (whiles -> while expression do bloco end .)
    CONST_INTERGER  reduce using rule 39 (whiles -> while expression do bloco end .)
    CONST_STRING    reduce using rule 39 (whiles -> while expression do bloco end .)
    True            reduce using rule 39 (whiles -> while expression do bloco end .)
    False           reduce using rule 39 (whiles -> while expression do bloco end .)
    DSING           reduce using rule 39 (whiles -> while expression do bloco end .)
    LAND            reduce using rule 39 (whiles -> while expression do bloco end .)
    puts            reduce using rule 39 (whiles -> while expression do bloco end .)
    NOT             reduce using rule 39 (whiles -> while expression do bloco end .)
    PLUS            reduce using rule 39 (whiles -> while expression do bloco end .)
    MINUS           reduce using rule 39 (whiles -> while expression do bloco end .)
    int             reduce using rule 39 (whiles -> while expression do bloco end .)
    float           reduce using rule 39 (whiles -> while expression do bloco end .)
    boolean         reduce using rule 39 (whiles -> while expression do bloco end .)
    AND             reduce using rule 39 (whiles -> while expression do bloco end .)
    $end            reduce using rule 39 (whiles -> while expression do bloco end .)
    DEDENT          reduce using rule 39 (whiles -> while expression do bloco end .)


state 210

    (41) repeats -> repeat CONST_INTERGER DPOINT bloco end . SEMICOLON

    SEMICOLON       shift and go to state 225


state 211

    (42) unlesss -> unless expression then bloco RBRACKET . else bloco LBRACKET end

    else            shift and go to state 226


state 212

    (23) expression_declaration -> ID ASSIGNMENT . expression
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression                     shift and go to state 156
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_variable            shift and go to state 32
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 213

    (30) conditional -> if expression begin bloco end SEMICOLON .

    if              reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    break           reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    continue        reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    ID              reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    ASTERISK        reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    LBRACKET        reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    INDENT          reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    for             reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    while           reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    do              reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    repeat          reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    unless          reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    CONST_REAL      reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    CONST_INTERGER  reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    CONST_STRING    reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    True            reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    False           reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    DSING           reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    LAND            reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    puts            reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    NOT             reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    PLUS            reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    MINUS           reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    int             reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    float           reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    boolean         reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    AND             reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    $end            reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)
    DEDENT          reduce using rule 30 (conditional -> if expression begin bloco end SEMICOLON .)


state 214

    (31) conditional -> if expression begin bloco else bloco . end SEMICOLON

    end             shift and go to state 227


state 215

    (32) conditional -> if expression begin bloco elsif expression . bloco else bloco end SEMICOLON
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression
    (3) bloco -> . INDENT program DEDENT

    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104
    INDENT          shift and go to state 24

    bloco                          shift and go to state 228

state 216

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK . LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    LBRACKET        shift and go to state 229


state 217

    (124) matrix -> LBRACKET argument RBRACKET matrix .

    if              reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    break           reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    continue        reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    ID              reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    ASTERISK        reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    LBRACKET        reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    INDENT          reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    for             reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    while           reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    do              reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    repeat          reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    unless          reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    CONST_REAL      reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    CONST_INTERGER  reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    CONST_STRING    reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    True            reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    False           reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    DSING           reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    LAND            reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    puts            reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    NOT             reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    PLUS            reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    MINUS           reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    int             reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    float           reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    boolean         reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    AND             reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    $end            reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    DEDENT          reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)
    RBRACKET        reduce using rule 124 (matrix -> LBRACKET argument RBRACKET matrix .)


state 218

    (125) matrix -> LBRACKET argument RBRACKET COMMA . matrix
    (122) matrix -> . matrix_arg
    (123) matrix -> . matrix_rec
    (124) matrix -> . LBRACKET argument RBRACKET matrix
    (125) matrix -> . LBRACKET argument RBRACKET COMMA matrix
    (126) matrix_arg -> . LBRACKET argument RBRACKET
    (127) matrix_rec -> . LBRACKET matrix RBRACKET

    LBRACKET        shift and go to state 159

    matrix                         shift and go to state 230
    matrix_arg                     shift and go to state 157
    matrix_rec                     shift and go to state 158

state 219

    (129) argument -> argument COMMA expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    RBRACKET        reduce using rule 129 (argument -> argument COMMA expression .)
    COMMA           reduce using rule 129 (argument -> argument COMMA expression .)
    POINT           reduce using rule 129 (argument -> argument COMMA expression .)
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104


state 220

    (130) argument -> argument POINT expression .
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    RBRACKET        reduce using rule 130 (argument -> argument POINT expression .)
    COMMA           reduce using rule 130 (argument -> argument POINT expression .)
    POINT           reduce using rule 130 (argument -> argument POINT expression .)
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104


state 221

    (93) argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID . RBRACKET

    RBRACKET        shift and go to state 231


state 222

    (37) fors -> for expression_variable LBRACKET expression_variable RBRACKET in . expression LBRACKET do RBRACKET begin bloco end
    (43) expression -> . expression_binop
    (44) expression -> . expression_unitary
    (45) expression -> . expression_const_real
    (46) expression -> . expression_const_interger
    (47) expression -> . expression_const_string
    (48) expression -> . expression_true
    (49) expression -> . expression_false
    (50) expression -> . expression_variable
    (51) expression -> . expression_land
    (56) expression_binop -> . expression_and
    (57) expression_binop -> . expression_or
    (58) expression_binop -> . expression_gt
    (59) expression_binop -> . expression_ge
    (60) expression_binop -> . expression_lt
    (61) expression_binop -> . expression_le
    (62) expression_binop -> . expression_minus
    (63) expression_binop -> . expression_plus
    (64) expression_binop -> . expression_mult
    (65) expression_binop -> . expression_divide
    (66) expression_binop -> . expression_module
    (67) expression_binop -> . expression_equals
    (68) expression_binop -> . expression_different
    (52) expression_unitary -> . unitary_not
    (53) expression_unitary -> . unitary_asterisk
    (54) expression_unitary -> . unitary_plus
    (55) expression_unitary -> . unitary_minus
    (80) expression_const_real -> . CONST_REAL
    (81) expression_const_interger -> . CONST_INTERGER
    (82) expression_const_string -> . CONST_STRING
    (83) expression_true -> . True
    (84) expression_false -> . False
    (95) expression_variable -> . ID
    (96) expression_variable -> . DSING ID
    (79) expression_land -> . LAND expression
    (73) expression_and -> . expression AND expression
    (74) expression_or -> . expression OR expression
    (75) expression_gt -> . expression GT expression
    (76) expression_ge -> . expression GE expression
    (77) expression_lt -> . expression LT expression
    (78) expression_le -> . expression LE expression
    (88) expression_minus -> . expression MINUS expression
    (85) expression_plus -> . expression PLUS expression
    (89) expression_mult -> . expression ASTERISK expression
    (90) expression_divide -> . expression DIVIDE expression
    (91) expression_module -> . expression MODULE expression
    (86) expression_equals -> . expression EQUALS expression
    (87) expression_different -> . expression DIFFERENT expression
    (72) unitary_not -> . NOT expression
    (71) unitary_asterisk -> . ASTERISK expression
    (70) unitary_plus -> . PLUS expression
    (69) unitary_minus -> . MINUS expression

    CONST_REAL      shift and go to state 65
    CONST_INTERGER  shift and go to state 44
    CONST_STRING    shift and go to state 66
    True            shift and go to state 67
    False           shift and go to state 68
    ID              shift and go to state 106
    DSING           shift and go to state 69
    LAND            shift and go to state 107
    NOT             shift and go to state 85
    ASTERISK        shift and go to state 108
    PLUS            shift and go to state 84
    MINUS           shift and go to state 83

    expression_variable            shift and go to state 32
    expression                     shift and go to state 232
    expression_binop               shift and go to state 25
    expression_unitary             shift and go to state 26
    expression_const_real          shift and go to state 27
    expression_const_interger      shift and go to state 28
    expression_const_string        shift and go to state 29
    expression_true                shift and go to state 30
    expression_false               shift and go to state 31
    expression_land                shift and go to state 33
    expression_and                 shift and go to state 48
    expression_or                  shift and go to state 49
    expression_gt                  shift and go to state 50
    expression_ge                  shift and go to state 51
    expression_lt                  shift and go to state 52
    expression_le                  shift and go to state 53
    expression_minus               shift and go to state 54
    expression_plus                shift and go to state 55
    expression_mult                shift and go to state 56
    expression_divide              shift and go to state 57
    expression_module              shift and go to state 58
    expression_equals              shift and go to state 59
    expression_different           shift and go to state 60
    unitary_not                    shift and go to state 61
    unitary_asterisk               shift and go to state 62
    unitary_plus                   shift and go to state 63
    unitary_minus                  shift and go to state 64

state 223

    (38) fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER . bloco end
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 233

state 224

    (40) whiles -> do bloco break if expression end .

    if              reduce using rule 40 (whiles -> do bloco break if expression end .)
    break           reduce using rule 40 (whiles -> do bloco break if expression end .)
    continue        reduce using rule 40 (whiles -> do bloco break if expression end .)
    ID              reduce using rule 40 (whiles -> do bloco break if expression end .)
    ASTERISK        reduce using rule 40 (whiles -> do bloco break if expression end .)
    LBRACKET        reduce using rule 40 (whiles -> do bloco break if expression end .)
    INDENT          reduce using rule 40 (whiles -> do bloco break if expression end .)
    for             reduce using rule 40 (whiles -> do bloco break if expression end .)
    while           reduce using rule 40 (whiles -> do bloco break if expression end .)
    do              reduce using rule 40 (whiles -> do bloco break if expression end .)
    repeat          reduce using rule 40 (whiles -> do bloco break if expression end .)
    unless          reduce using rule 40 (whiles -> do bloco break if expression end .)
    CONST_REAL      reduce using rule 40 (whiles -> do bloco break if expression end .)
    CONST_INTERGER  reduce using rule 40 (whiles -> do bloco break if expression end .)
    CONST_STRING    reduce using rule 40 (whiles -> do bloco break if expression end .)
    True            reduce using rule 40 (whiles -> do bloco break if expression end .)
    False           reduce using rule 40 (whiles -> do bloco break if expression end .)
    DSING           reduce using rule 40 (whiles -> do bloco break if expression end .)
    LAND            reduce using rule 40 (whiles -> do bloco break if expression end .)
    puts            reduce using rule 40 (whiles -> do bloco break if expression end .)
    NOT             reduce using rule 40 (whiles -> do bloco break if expression end .)
    PLUS            reduce using rule 40 (whiles -> do bloco break if expression end .)
    MINUS           reduce using rule 40 (whiles -> do bloco break if expression end .)
    int             reduce using rule 40 (whiles -> do bloco break if expression end .)
    float           reduce using rule 40 (whiles -> do bloco break if expression end .)
    boolean         reduce using rule 40 (whiles -> do bloco break if expression end .)
    AND             reduce using rule 40 (whiles -> do bloco break if expression end .)
    $end            reduce using rule 40 (whiles -> do bloco break if expression end .)
    DEDENT          reduce using rule 40 (whiles -> do bloco break if expression end .)


state 225

    (41) repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .

    if              reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    break           reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    continue        reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    ID              reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    ASTERISK        reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    LBRACKET        reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    INDENT          reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    for             reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    while           reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    do              reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    repeat          reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    unless          reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    CONST_REAL      reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    CONST_INTERGER  reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    CONST_STRING    reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    True            reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    False           reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    DSING           reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    LAND            reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    puts            reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    NOT             reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    PLUS            reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    MINUS           reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    int             reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    float           reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    boolean         reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    AND             reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    $end            reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)
    DEDENT          reduce using rule 41 (repeats -> repeat CONST_INTERGER DPOINT bloco end SEMICOLON .)


state 226

    (42) unlesss -> unless expression then bloco RBRACKET else . bloco LBRACKET end
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 234

state 227

    (31) conditional -> if expression begin bloco else bloco end . SEMICOLON

    SEMICOLON       shift and go to state 235


state 228

    (32) conditional -> if expression begin bloco elsif expression bloco . else bloco end SEMICOLON

    else            shift and go to state 236


state 229

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET . COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    COMMA           shift and go to state 237


state 230

    (125) matrix -> LBRACKET argument RBRACKET COMMA matrix .

    if              reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    break           reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    continue        reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    ID              reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    ASTERISK        reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    LBRACKET        reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    INDENT          reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    for             reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    while           reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    do              reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    repeat          reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    unless          reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    CONST_REAL      reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    CONST_INTERGER  reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    CONST_STRING    reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    True            reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    False           reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    DSING           reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    LAND            reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    puts            reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    NOT             reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    PLUS            reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    MINUS           reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    int             reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    float           reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    boolean         reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    AND             reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    $end            reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    DEDENT          reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)
    RBRACKET        reduce using rule 125 (matrix -> LBRACKET argument RBRACKET COMMA matrix .)


state 231

    (93) argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .

    if              reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    break           reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    continue        reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    ID              reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    ASTERISK        reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    LBRACKET        reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    INDENT          reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    for             reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    while           reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    do              reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    repeat          reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    unless          reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    CONST_REAL      reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    CONST_INTERGER  reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    CONST_STRING    reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    True            reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    False           reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    DSING           reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    LAND            reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    puts            reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    NOT             reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    PLUS            reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    MINUS           reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    int             reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    float           reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    boolean         reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    AND             reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    $end            reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)
    DEDENT          reduce using rule 93 (argumentlist -> ASTERISK ID LBRACKET COMMA LAND ID RBRACKET .)


state 232

    (37) fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression . LBRACKET do RBRACKET begin bloco end
    (73) expression_and -> expression . AND expression
    (74) expression_or -> expression . OR expression
    (75) expression_gt -> expression . GT expression
    (76) expression_ge -> expression . GE expression
    (77) expression_lt -> expression . LT expression
    (78) expression_le -> expression . LE expression
    (88) expression_minus -> expression . MINUS expression
    (85) expression_plus -> expression . PLUS expression
    (89) expression_mult -> expression . ASTERISK expression
    (90) expression_divide -> expression . DIVIDE expression
    (91) expression_module -> expression . MODULE expression
    (86) expression_equals -> expression . EQUALS expression
    (87) expression_different -> expression . DIFFERENT expression

    LBRACKET        shift and go to state 238
    AND             shift and go to state 92
    OR              shift and go to state 93
    GT              shift and go to state 94
    GE              shift and go to state 95
    LT              shift and go to state 96
    LE              shift and go to state 97
    MINUS           shift and go to state 98
    PLUS            shift and go to state 99
    ASTERISK        shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102
    EQUALS          shift and go to state 103
    DIFFERENT       shift and go to state 104


state 233

    (38) fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco . end

    end             shift and go to state 239


state 234

    (42) unlesss -> unless expression then bloco RBRACKET else bloco . LBRACKET end

    LBRACKET        shift and go to state 240


state 235

    (31) conditional -> if expression begin bloco else bloco end SEMICOLON .

    if              reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    break           reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    continue        reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    ID              reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    ASTERISK        reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    LBRACKET        reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    INDENT          reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    for             reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    while           reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    do              reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    repeat          reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    unless          reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    CONST_REAL      reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    CONST_INTERGER  reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    CONST_STRING    reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    True            reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    False           reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    DSING           reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    LAND            reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    puts            reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    NOT             reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    PLUS            reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    MINUS           reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    int             reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    float           reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    boolean         reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    AND             reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    $end            reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)
    DEDENT          reduce using rule 31 (conditional -> if expression begin bloco else bloco end SEMICOLON .)


state 236

    (32) conditional -> if expression begin bloco elsif expression bloco else . bloco end SEMICOLON
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 241

state 237

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA . ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    ASTERISK        shift and go to state 242


state 238

    (37) fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET . do RBRACKET begin bloco end

    do              shift and go to state 243


state 239

    (38) fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .

    if              reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    break           reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    continue        reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    ID              reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    ASTERISK        reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    LBRACKET        reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    INDENT          reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    for             reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    while           reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    do              reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    repeat          reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    unless          reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    CONST_REAL      reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    CONST_INTERGER  reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    CONST_STRING    reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    True            reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    False           reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    DSING           reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    LAND            reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    puts            reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    NOT             reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    PLUS            reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    MINUS           reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    int             reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    float           reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    boolean         reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    AND             reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    $end            reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)
    DEDENT          reduce using rule 38 (fors -> for expression in CONST_INTERGER POINTPOINT CONST_INTERGER bloco end .)


state 240

    (42) unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET . end

    end             shift and go to state 244


state 241

    (32) conditional -> if expression begin bloco elsif expression bloco else bloco . end SEMICOLON

    end             shift and go to state 245


state 242

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK . LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    LBRACKET        shift and go to state 246


state 243

    (37) fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do . RBRACKET begin bloco end

    RBRACKET        shift and go to state 247


state 244

    (42) unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .

    if              reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    break           reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    continue        reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    ID              reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    ASTERISK        reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    LBRACKET        reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    INDENT          reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    for             reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    while           reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    do              reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    repeat          reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    unless          reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    CONST_REAL      reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    CONST_INTERGER  reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    CONST_STRING    reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    True            reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    False           reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    DSING           reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    LAND            reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    puts            reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    NOT             reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    PLUS            reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    MINUS           reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    int             reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    float           reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    boolean         reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    AND             reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    $end            reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)
    DEDENT          reduce using rule 42 (unlesss -> unless expression then bloco RBRACKET else bloco LBRACKET end .)


state 245

    (32) conditional -> if expression begin bloco elsif expression bloco else bloco end . SEMICOLON

    SEMICOLON       shift and go to state 248


state 246

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET . ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    ID              shift and go to state 249


state 247

    (37) fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET . begin bloco end

    begin           shift and go to state 250


state 248

    (32) conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .

    if              reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    break           reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    continue        reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    ID              reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    ASTERISK        reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    LBRACKET        reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    INDENT          reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    for             reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    while           reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    do              reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    repeat          reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    unless          reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    CONST_REAL      reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    CONST_INTERGER  reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    CONST_STRING    reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    True            reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    False           reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    DSING           reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    LAND            reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    puts            reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    NOT             reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    PLUS            reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    MINUS           reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    int             reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    float           reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    boolean         reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    AND             reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    $end            reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)
    DEDENT          reduce using rule 32 (conditional -> if expression begin bloco elsif expression bloco else bloco end SEMICOLON .)


state 249

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID . RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET

    RBRACKET        shift and go to state 251


state 250

    (37) fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin . bloco end
    (3) bloco -> . INDENT program DEDENT

    INDENT          shift and go to state 24

    bloco                          shift and go to state 252

state 251

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET . RBRACKET LBRACKET COMMA LAND ID RBRACKET

    RBRACKET        shift and go to state 253


state 252

    (37) fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco . end

    end             shift and go to state 254


state 253

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET . LBRACKET COMMA LAND ID RBRACKET

    LBRACKET        shift and go to state 255


state 254

    (37) fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .

    if              reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    break           reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    continue        reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    ID              reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    ASTERISK        reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    LBRACKET        reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    INDENT          reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    for             reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    while           reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    do              reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    repeat          reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    unless          reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    CONST_REAL      reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    CONST_INTERGER  reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    CONST_STRING    reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    True            reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    False           reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    DSING           reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    LAND            reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    puts            reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    NOT             reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    PLUS            reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    MINUS           reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    int             reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    float           reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    boolean         reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    AND             reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    $end            reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)
    DEDENT          reduce using rule 37 (fors -> for expression_variable LBRACKET expression_variable RBRACKET in expression LBRACKET do RBRACKET begin bloco end .)


state 255

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET . COMMA LAND ID RBRACKET

    COMMA           shift and go to state 256


state 256

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA . LAND ID RBRACKET

    LAND            shift and go to state 257


state 257

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND . ID RBRACKET

    ID              shift and go to state 258


state 258

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID . RBRACKET

    RBRACKET        shift and go to state 259


state 259

    (92) argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .

    if              reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    break           reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    continue        reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    ID              reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    ASTERISK        reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    LBRACKET        reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    INDENT          reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    for             reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    while           reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    do              reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    repeat          reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    unless          reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    CONST_REAL      reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    CONST_INTERGER  reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    CONST_STRING    reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    True            reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    False           reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    DSING           reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    LAND            reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    puts            reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    NOT             reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    PLUS            reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    MINUS           reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    int             reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    float           reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    boolean         reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    AND             reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    $end            reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)
    DEDENT          reduce using rule 92 (argumentlist -> ID LPAREN COMMA ID RPAREN ASTERISK LBRACKET COMMA ASTERISK LBRACKET ID RBRACKET RBRACKET LBRACKET COMMA LAND ID RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 9 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 9 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 9 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 9 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 112 resolved as shift
